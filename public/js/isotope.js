/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkmofidSanat"] = self["webpackChunkmofidSanat"] || []).push([["/js/isotope"],{

/***/ "./resources/assets/js/isotope.js":
/*!****************************************!*\
  !*** ./resources/assets/js/isotope.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_LOCAL_MODULE_1__, __WEBPACK_LOCAL_MODULE_1__factory, __WEBPACK_LOCAL_MODULE_1__module;var __WEBPACK_LOCAL_MODULE_2__, __WEBPACK_LOCAL_MODULE_2__factory, __WEBPACK_LOCAL_MODULE_2__module;var __WEBPACK_LOCAL_MODULE_3__, __WEBPACK_LOCAL_MODULE_3__factory, __WEBPACK_LOCAL_MODULE_3__module;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_4__, __WEBPACK_LOCAL_MODULE_4__exports;var __WEBPACK_LOCAL_MODULE_5__array, __WEBPACK_LOCAL_MODULE_5__factory, __WEBPACK_LOCAL_MODULE_5__exports, __WEBPACK_LOCAL_MODULE_5__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_6__, __WEBPACK_LOCAL_MODULE_6__exports;var __WEBPACK_LOCAL_MODULE_7__array, __WEBPACK_LOCAL_MODULE_7__factory, __WEBPACK_LOCAL_MODULE_7__exports, __WEBPACK_LOCAL_MODULE_7__;var __WEBPACK_LOCAL_MODULE_8__array, __WEBPACK_LOCAL_MODULE_8__factory, __WEBPACK_LOCAL_MODULE_8__exports, __WEBPACK_LOCAL_MODULE_8__;var __WEBPACK_LOCAL_MODULE_9__array, __WEBPACK_LOCAL_MODULE_9__factory, __WEBPACK_LOCAL_MODULE_9__exports, __WEBPACK_LOCAL_MODULE_9__;var __WEBPACK_LOCAL_MODULE_10__array, __WEBPACK_LOCAL_MODULE_10__factory, __WEBPACK_LOCAL_MODULE_10__exports, __WEBPACK_LOCAL_MODULE_10__;var __WEBPACK_LOCAL_MODULE_11__array, __WEBPACK_LOCAL_MODULE_11__factory, __WEBPACK_LOCAL_MODULE_11__exports, __WEBPACK_LOCAL_MODULE_11__;var __WEBPACK_LOCAL_MODULE_12__array, __WEBPACK_LOCAL_MODULE_12__factory, __WEBPACK_LOCAL_MODULE_12__exports, __WEBPACK_LOCAL_MODULE_12__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n * Isotope PACKAGED v3.0.6\n *\n * Licensed GPLv3 for open source use\n * or Isotope Commercial License for commercial use\n *\n * https://isotope.metafizzy.co\n * Copyright 2010-2018 Metafizzy\n */\n\n/**\n * Bridget makes jQuery widgets\n * v2.0.1\n * MIT license\n */\n\n/* jshint browser: true, strict: true, undef: true, unused: true */\n(function (window, factory) {\n  // universal module definition\n\n  /*jshint strict: false */\n\n  /* globals define, module, require */\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {\n      return factory(window, jQuery);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function factory(window, jQuery) {\n  'use strict'; // ----- utils ----- //\n\n  var arraySlice = Array.prototype.slice; // helper function for logging errors\n  // $.error breaks jQuery chaining\n\n  var console = window.console;\n  var logError = typeof console == 'undefined' ? function () {} : function (message) {\n    console.error(message);\n  }; // ----- jQueryBridget ----- //\n\n  function jQueryBridget(namespace, PluginClass, $) {\n    $ = $ || jQuery || window.jQuery;\n\n    if (!$) {\n      return;\n    } // add option method -> $().plugin('option', {...})\n\n\n    if (!PluginClass.prototype.option) {\n      // option setter\n      PluginClass.prototype.option = function (opts) {\n        // bail out if not an object\n        if (!$.isPlainObject(opts)) {\n          return;\n        }\n\n        this.options = $.extend(true, this.options, opts);\n      };\n    } // make jQuery plugin\n\n\n    $.fn[namespace] = function (arg0\n    /*, arg1 */\n    ) {\n      if (typeof arg0 == 'string') {\n        // method call $().plugin( 'methodName', { options } )\n        // shift arguments by 1\n        var args = arraySlice.call(arguments, 1);\n        return methodCall(this, arg0, args);\n      } // just $().plugin({ options })\n\n\n      plainCall(this, arg0);\n      return this;\n    }; // $().plugin('methodName')\n\n\n    function methodCall($elems, methodName, args) {\n      var returnValue;\n      var pluginMethodStr = '$().' + namespace + '(\"' + methodName + '\")';\n      $elems.each(function (i, elem) {\n        // get instance\n        var instance = $.data(elem, namespace);\n\n        if (!instance) {\n          logError(namespace + ' not initialized. Cannot call methods, i.e. ' + pluginMethodStr);\n          return;\n        }\n\n        var method = instance[methodName];\n\n        if (!method || methodName.charAt(0) == '_') {\n          logError(pluginMethodStr + ' is not a valid method');\n          return;\n        } // apply method, get return value\n\n\n        var value = method.apply(instance, args); // set return value if value is returned, use only first value\n\n        returnValue = returnValue === undefined ? value : returnValue;\n      });\n      return returnValue !== undefined ? returnValue : $elems;\n    }\n\n    function plainCall($elems, options) {\n      $elems.each(function (i, elem) {\n        var instance = $.data(elem, namespace);\n\n        if (instance) {\n          // set options & init\n          instance.option(options);\n\n          instance._init();\n        } else {\n          // initialize new instance\n          instance = new PluginClass(elem, options);\n          $.data(elem, namespace, instance);\n        }\n      });\n    }\n\n    updateJQuery($);\n  } // ----- updateJQuery ----- //\n  // set $.bridget for v1 backwards compatibility\n\n\n  function updateJQuery($) {\n    if (!$ || $ && $.bridget) {\n      return;\n    }\n\n    $.bridget = jQueryBridget;\n  }\n\n  updateJQuery(jQuery || window.jQuery); // -----  ----- //\n\n  return jQueryBridget;\n});\n/**\n * EvEmitter v1.1.0\n * Lil' event emitter\n * MIT License\n */\n\n/* jshint unused: true, undef: true, strict: true */\n\n\n(function (global, factory) {\n  // universal module definition\n\n  /* jshint strict: false */\n\n  /* globals define, module, window */\n  if (true) {\n    // AMD - RequireJS\n    !(__WEBPACK_LOCAL_MODULE_1__factory = (factory), (typeof __WEBPACK_LOCAL_MODULE_1__factory === 'function' ? ((__WEBPACK_LOCAL_MODULE_1__module = { id: \"ev-emitter/ev-emitter\", exports: {}, loaded: false }), (__WEBPACK_LOCAL_MODULE_1__ = __WEBPACK_LOCAL_MODULE_1__factory.call(__WEBPACK_LOCAL_MODULE_1__module.exports, __webpack_require__, __WEBPACK_LOCAL_MODULE_1__module.exports, __WEBPACK_LOCAL_MODULE_1__module)), (__WEBPACK_LOCAL_MODULE_1__module.loaded = true), __WEBPACK_LOCAL_MODULE_1__ === undefined && (__WEBPACK_LOCAL_MODULE_1__ = __WEBPACK_LOCAL_MODULE_1__module.exports)) : __WEBPACK_LOCAL_MODULE_1__ = __WEBPACK_LOCAL_MODULE_1__factory));\n  } else {}\n})(typeof window != 'undefined' ? window : this, function () {\n  function EvEmitter() {}\n\n  var proto = EvEmitter.prototype;\n\n  proto.on = function (eventName, listener) {\n    if (!eventName || !listener) {\n      return;\n    } // set events hash\n\n\n    var events = this._events = this._events || {}; // set listeners array\n\n    var listeners = events[eventName] = events[eventName] || []; // only add once\n\n    if (listeners.indexOf(listener) == -1) {\n      listeners.push(listener);\n    }\n\n    return this;\n  };\n\n  proto.once = function (eventName, listener) {\n    if (!eventName || !listener) {\n      return;\n    } // add event\n\n\n    this.on(eventName, listener); // set once flag\n    // set onceEvents hash\n\n    var onceEvents = this._onceEvents = this._onceEvents || {}; // set onceListeners object\n\n    var onceListeners = onceEvents[eventName] = onceEvents[eventName] || {}; // set flag\n\n    onceListeners[listener] = true;\n    return this;\n  };\n\n  proto.off = function (eventName, listener) {\n    var listeners = this._events && this._events[eventName];\n\n    if (!listeners || !listeners.length) {\n      return;\n    }\n\n    var index = listeners.indexOf(listener);\n\n    if (index != -1) {\n      listeners.splice(index, 1);\n    }\n\n    return this;\n  };\n\n  proto.emitEvent = function (eventName, args) {\n    var listeners = this._events && this._events[eventName];\n\n    if (!listeners || !listeners.length) {\n      return;\n    } // copy over to avoid interference if .off() in listener\n\n\n    listeners = listeners.slice(0);\n    args = args || []; // once stuff\n\n    var onceListeners = this._onceEvents && this._onceEvents[eventName];\n\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      var isOnce = onceListeners && onceListeners[listener];\n\n      if (isOnce) {\n        // remove listener\n        // remove before trigger to prevent recursion\n        this.off(eventName, listener); // unset once flag\n\n        delete onceListeners[listener];\n      } // trigger listener\n\n\n      listener.apply(this, args);\n    }\n\n    return this;\n  };\n\n  proto.allOff = function () {\n    delete this._events;\n    delete this._onceEvents;\n  };\n\n  return EvEmitter;\n});\n/*!\n * getSize v2.0.3\n * measure size of elements\n * MIT license\n */\n\n/* jshint browser: true, strict: true, undef: true, unused: true */\n\n/* globals console: false */\n\n\n(function (window, factory) {\n  /* jshint strict: false */\n\n  /* globals define, module */\n  if (true) {\n    // AMD\n    !(__WEBPACK_LOCAL_MODULE_2__factory = (factory), (typeof __WEBPACK_LOCAL_MODULE_2__factory === 'function' ? ((__WEBPACK_LOCAL_MODULE_2__module = { id: \"get-size/get-size\", exports: {}, loaded: false }), (__WEBPACK_LOCAL_MODULE_2__ = __WEBPACK_LOCAL_MODULE_2__factory.call(__WEBPACK_LOCAL_MODULE_2__module.exports, __webpack_require__, __WEBPACK_LOCAL_MODULE_2__module.exports, __WEBPACK_LOCAL_MODULE_2__module)), (__WEBPACK_LOCAL_MODULE_2__module.loaded = true), __WEBPACK_LOCAL_MODULE_2__ === undefined && (__WEBPACK_LOCAL_MODULE_2__ = __WEBPACK_LOCAL_MODULE_2__module.exports)) : __WEBPACK_LOCAL_MODULE_2__ = __WEBPACK_LOCAL_MODULE_2__factory));\n  } else {}\n})(window, function factory() {\n  'use strict'; // -------------------------- helpers -------------------------- //\n  // get a number from a string, not a percentage\n\n  function getStyleSize(value) {\n    var num = parseFloat(value); // not a percent like '100%', and a number\n\n    var isValid = value.indexOf('%') == -1 && !isNaN(num);\n    return isValid && num;\n  }\n\n  function noop() {}\n\n  var logError = typeof console == 'undefined' ? noop : function (message) {\n    console.error(message);\n  }; // -------------------------- measurements -------------------------- //\n\n  var measurements = ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom', 'marginLeft', 'marginRight', 'marginTop', 'marginBottom', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth', 'borderBottomWidth'];\n  var measurementsLength = measurements.length;\n\n  function getZeroSize() {\n    var size = {\n      width: 0,\n      height: 0,\n      innerWidth: 0,\n      innerHeight: 0,\n      outerWidth: 0,\n      outerHeight: 0\n    };\n\n    for (var i = 0; i < measurementsLength; i++) {\n      var measurement = measurements[i];\n      size[measurement] = 0;\n    }\n\n    return size;\n  } // -------------------------- getStyle -------------------------- //\n\n  /**\n   * getStyle, get style of element, check for Firefox bug\n   * https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n   */\n\n\n  function getStyle(elem) {\n    var style = getComputedStyle(elem);\n\n    if (!style) {\n      logError('Style returned ' + style + '. Are you running this code in a hidden iframe on Firefox? ' + 'See https://bit.ly/getsizebug1');\n    }\n\n    return style;\n  } // -------------------------- setup -------------------------- //\n\n\n  var isSetup = false;\n  var isBoxSizeOuter;\n  /**\n   * setup\n   * check isBoxSizerOuter\n   * do on first getSize() rather than on page load for Firefox bug\n   */\n\n  function setup() {\n    // setup once\n    if (isSetup) {\n      return;\n    }\n\n    isSetup = true; // -------------------------- box sizing -------------------------- //\n\n    /**\n     * Chrome & Safari measure the outer-width on style.width on border-box elems\n     * IE11 & Firefox<29 measures the inner-width\n     */\n\n    var div = document.createElement('div');\n    div.style.width = '200px';\n    div.style.padding = '1px 2px 3px 4px';\n    div.style.borderStyle = 'solid';\n    div.style.borderWidth = '1px 2px 3px 4px';\n    div.style.boxSizing = 'border-box';\n    var body = document.body || document.documentElement;\n    body.appendChild(div);\n    var style = getStyle(div); // round value for browser zoom. desandro/masonry#928\n\n    isBoxSizeOuter = Math.round(getStyleSize(style.width)) == 200;\n    getSize.isBoxSizeOuter = isBoxSizeOuter;\n    body.removeChild(div);\n  } // -------------------------- getSize -------------------------- //\n\n\n  function getSize(elem) {\n    setup(); // use querySeletor if elem is string\n\n    if (typeof elem == 'string') {\n      elem = document.querySelector(elem);\n    } // do not proceed on non-objects\n\n\n    if (!elem || _typeof(elem) != 'object' || !elem.nodeType) {\n      return;\n    }\n\n    var style = getStyle(elem); // if hidden, everything is 0\n\n    if (style.display == 'none') {\n      return getZeroSize();\n    }\n\n    var size = {};\n    size.width = elem.offsetWidth;\n    size.height = elem.offsetHeight;\n    var isBorderBox = size.isBorderBox = style.boxSizing == 'border-box'; // get all measurements\n\n    for (var i = 0; i < measurementsLength; i++) {\n      var measurement = measurements[i];\n      var value = style[measurement];\n      var num = parseFloat(value); // any 'auto', 'medium' value will be 0\n\n      size[measurement] = !isNaN(num) ? num : 0;\n    }\n\n    var paddingWidth = size.paddingLeft + size.paddingRight;\n    var paddingHeight = size.paddingTop + size.paddingBottom;\n    var marginWidth = size.marginLeft + size.marginRight;\n    var marginHeight = size.marginTop + size.marginBottom;\n    var borderWidth = size.borderLeftWidth + size.borderRightWidth;\n    var borderHeight = size.borderTopWidth + size.borderBottomWidth;\n    var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter; // overwrite width and height if we can get it from style\n\n    var styleWidth = getStyleSize(style.width);\n\n    if (styleWidth !== false) {\n      size.width = styleWidth + ( // add padding and border unless it's already including it\n      isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth);\n    }\n\n    var styleHeight = getStyleSize(style.height);\n\n    if (styleHeight !== false) {\n      size.height = styleHeight + ( // add padding and border unless it's already including it\n      isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight);\n    }\n\n    size.innerWidth = size.width - (paddingWidth + borderWidth);\n    size.innerHeight = size.height - (paddingHeight + borderHeight);\n    size.outerWidth = size.width + marginWidth;\n    size.outerHeight = size.height + marginHeight;\n    return size;\n  }\n\n  return getSize;\n});\n/**\n * matchesSelector v2.0.2\n * matchesSelector( element, '.selector' )\n * MIT license\n */\n\n/*jshint browser: true, strict: true, undef: true, unused: true */\n\n\n(function (window, factory) {\n  /*global define: false, module: false */\n  'use strict'; // universal module definition\n\n  if (true) {\n    // AMD\n    !(__WEBPACK_LOCAL_MODULE_3__factory = (factory), (typeof __WEBPACK_LOCAL_MODULE_3__factory === 'function' ? ((__WEBPACK_LOCAL_MODULE_3__module = { id: \"desandro-matches-selector/matches-selector\", exports: {}, loaded: false }), (__WEBPACK_LOCAL_MODULE_3__ = __WEBPACK_LOCAL_MODULE_3__factory.call(__WEBPACK_LOCAL_MODULE_3__module.exports, __webpack_require__, __WEBPACK_LOCAL_MODULE_3__module.exports, __WEBPACK_LOCAL_MODULE_3__module)), (__WEBPACK_LOCAL_MODULE_3__module.loaded = true), __WEBPACK_LOCAL_MODULE_3__ === undefined && (__WEBPACK_LOCAL_MODULE_3__ = __WEBPACK_LOCAL_MODULE_3__module.exports)) : __WEBPACK_LOCAL_MODULE_3__ = __WEBPACK_LOCAL_MODULE_3__factory));\n  } else {}\n})(window, function factory() {\n  'use strict';\n\n  var matchesMethod = function () {\n    var ElemProto = window.Element.prototype; // check for the standard method name first\n\n    if (ElemProto.matches) {\n      return 'matches';\n    } // check un-prefixed\n\n\n    if (ElemProto.matchesSelector) {\n      return 'matchesSelector';\n    } // check vendor prefixes\n\n\n    var prefixes = ['webkit', 'moz', 'ms', 'o'];\n\n    for (var i = 0; i < prefixes.length; i++) {\n      var prefix = prefixes[i];\n      var method = prefix + 'MatchesSelector';\n\n      if (ElemProto[method]) {\n        return method;\n      }\n    }\n  }();\n\n  return function matchesSelector(elem, selector) {\n    return elem[matchesMethod](selector);\n  };\n});\n/**\n * Fizzy UI utils v2.0.7\n * MIT license\n */\n\n/*jshint browser: true, undef: true, unused: true, strict: true */\n\n\n(function (window, factory) {\n  // universal module definition\n\n  /*jshint strict: false */\n\n  /*globals define, module, require */\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_3__], __WEBPACK_LOCAL_MODULE_4__ = (function (matchesSelector) {\n      return factory(window, matchesSelector);\n    }).apply(__WEBPACK_LOCAL_MODULE_4__exports = {}, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_LOCAL_MODULE_4__ === undefined && (__WEBPACK_LOCAL_MODULE_4__ = __WEBPACK_LOCAL_MODULE_4__exports));\n  } else {}\n})(window, function factory(window, matchesSelector) {\n  var utils = {}; // ----- extend ----- //\n  // extends objects\n\n  utils.extend = function (a, b) {\n    for (var prop in b) {\n      a[prop] = b[prop];\n    }\n\n    return a;\n  }; // ----- modulo ----- //\n\n\n  utils.modulo = function (num, div) {\n    return (num % div + div) % div;\n  }; // ----- makeArray ----- //\n\n\n  var arraySlice = Array.prototype.slice; // turn element or nodeList into an array\n\n  utils.makeArray = function (obj) {\n    if (Array.isArray(obj)) {\n      // use object if already an array\n      return obj;\n    } // return empty array if undefined or null. #6\n\n\n    if (obj === null || obj === undefined) {\n      return [];\n    }\n\n    var isArrayLike = _typeof(obj) == 'object' && typeof obj.length == 'number';\n\n    if (isArrayLike) {\n      // convert nodeList to array\n      return arraySlice.call(obj);\n    } // array of single index\n\n\n    return [obj];\n  }; // ----- removeFrom ----- //\n\n\n  utils.removeFrom = function (ary, obj) {\n    var index = ary.indexOf(obj);\n\n    if (index != -1) {\n      ary.splice(index, 1);\n    }\n  }; // ----- getParent ----- //\n\n\n  utils.getParent = function (elem, selector) {\n    while (elem.parentNode && elem != document.body) {\n      elem = elem.parentNode;\n\n      if (matchesSelector(elem, selector)) {\n        return elem;\n      }\n    }\n  }; // ----- getQueryElement ----- //\n  // use element as selector string\n\n\n  utils.getQueryElement = function (elem) {\n    if (typeof elem == 'string') {\n      return document.querySelector(elem);\n    }\n\n    return elem;\n  }; // ----- handleEvent ----- //\n  // enable .ontype to trigger from .addEventListener( elem, 'type' )\n\n\n  utils.handleEvent = function (event) {\n    var method = 'on' + event.type;\n\n    if (this[method]) {\n      this[method](event);\n    }\n  }; // ----- filterFindElements ----- //\n\n\n  utils.filterFindElements = function (elems, selector) {\n    // make array of elems\n    elems = utils.makeArray(elems);\n    var ffElems = [];\n    elems.forEach(function (elem) {\n      // check that elem is an actual element\n      if (!(elem instanceof HTMLElement)) {\n        return;\n      } // add elem if no selector\n\n\n      if (!selector) {\n        ffElems.push(elem);\n        return;\n      } // filter & find items if we have a selector\n      // filter\n\n\n      if (matchesSelector(elem, selector)) {\n        ffElems.push(elem);\n      } // find children\n\n\n      var childElems = elem.querySelectorAll(selector); // concat childElems to filterFound array\n\n      for (var i = 0; i < childElems.length; i++) {\n        ffElems.push(childElems[i]);\n      }\n    });\n    return ffElems;\n  }; // ----- debounceMethod ----- //\n\n\n  utils.debounceMethod = function (_class, methodName, threshold) {\n    threshold = threshold || 100; // original method\n\n    var method = _class.prototype[methodName];\n    var timeoutName = methodName + 'Timeout';\n\n    _class.prototype[methodName] = function () {\n      var timeout = this[timeoutName];\n      clearTimeout(timeout);\n      var args = arguments;\n\n      var _this = this;\n\n      this[timeoutName] = setTimeout(function () {\n        method.apply(_this, args);\n        delete _this[timeoutName];\n      }, threshold);\n    };\n  }; // ----- docReady ----- //\n\n\n  utils.docReady = function (callback) {\n    var readyState = document.readyState;\n\n    if (readyState == 'complete' || readyState == 'interactive') {\n      // do async to allow for other scripts to run. metafizzy/flickity#441\n      setTimeout(callback);\n    } else {\n      document.addEventListener('DOMContentLoaded', callback);\n    }\n  }; // ----- htmlInit ----- //\n  // http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/\n\n\n  utils.toDashed = function (str) {\n    return str.replace(/(.)([A-Z])/g, function (match, $1, $2) {\n      return $1 + '-' + $2;\n    }).toLowerCase();\n  };\n\n  var console = window.console;\n  /**\n   * allow user to initialize classes via [data-namespace] or .js-namespace class\n   * htmlInit( Widget, 'widgetName' )\n   * options are parsed from data-namespace-options\n   */\n\n  utils.htmlInit = function (WidgetClass, namespace) {\n    utils.docReady(function () {\n      var dashedNamespace = utils.toDashed(namespace);\n      var dataAttr = 'data-' + dashedNamespace;\n      var dataAttrElems = document.querySelectorAll('[' + dataAttr + ']');\n      var jsDashElems = document.querySelectorAll('.js-' + dashedNamespace);\n      var elems = utils.makeArray(dataAttrElems).concat(utils.makeArray(jsDashElems));\n      var dataOptionsAttr = dataAttr + '-options';\n      var jQuery = window.jQuery;\n      elems.forEach(function (elem) {\n        var attr = elem.getAttribute(dataAttr) || elem.getAttribute(dataOptionsAttr);\n        var options;\n\n        try {\n          options = attr && JSON.parse(attr);\n        } catch (error) {\n          // log error, do not initialize\n          if (console) {\n            console.error('Error parsing ' + dataAttr + ' on ' + elem.className + ': ' + error);\n          }\n\n          return;\n        } // initialize\n\n\n        var instance = new WidgetClass(elem, options); // make available via $().data('namespace')\n\n        if (jQuery) {\n          jQuery.data(elem, namespace, instance);\n        }\n      });\n    });\n  }; // -----  ----- //\n\n\n  return utils;\n});\n/**\n * Outlayer Item\n */\n\n\n(function (window, factory) {\n  // universal module definition\n\n  /* jshint strict: false */\n\n  /* globals define, module, require */\n  if (true) {\n    // AMD - RequireJS\n    !(__WEBPACK_LOCAL_MODULE_5__array = [__WEBPACK_LOCAL_MODULE_1__, __WEBPACK_LOCAL_MODULE_2__], __WEBPACK_LOCAL_MODULE_5__factory = (factory),\n\t\t(typeof __WEBPACK_LOCAL_MODULE_5__factory === 'function' ?\n\t\t\t((__WEBPACK_LOCAL_MODULE_5__ = __WEBPACK_LOCAL_MODULE_5__factory.apply(__WEBPACK_LOCAL_MODULE_5__exports = {}, __WEBPACK_LOCAL_MODULE_5__array)), __WEBPACK_LOCAL_MODULE_5__ === undefined && (__WEBPACK_LOCAL_MODULE_5__ = __WEBPACK_LOCAL_MODULE_5__exports)) :\n\t\t\t(__WEBPACK_LOCAL_MODULE_5__ = __WEBPACK_LOCAL_MODULE_5__factory)\n\t\t));\n  } else {}\n})(window, function factory(EvEmitter, getSize) {\n  'use strict'; // ----- helpers ----- //\n\n  function isEmptyObj(obj) {\n    for (var prop in obj) {\n      return false;\n    }\n\n    prop = null;\n    return true;\n  } // -------------------------- CSS3 support -------------------------- //\n\n\n  var docElemStyle = document.documentElement.style;\n  var transitionProperty = typeof docElemStyle.transition == 'string' ? 'transition' : 'WebkitTransition';\n  var transformProperty = typeof docElemStyle.transform == 'string' ? 'transform' : 'WebkitTransform';\n  var transitionEndEvent = {\n    WebkitTransition: 'webkitTransitionEnd',\n    transition: 'transitionend'\n  }[transitionProperty]; // cache all vendor properties that could have vendor prefix\n\n  var vendorProperties = {\n    transform: transformProperty,\n    transition: transitionProperty,\n    transitionDuration: transitionProperty + 'Duration',\n    transitionProperty: transitionProperty + 'Property',\n    transitionDelay: transitionProperty + 'Delay'\n  }; // -------------------------- Item -------------------------- //\n\n  function Item(element, layout) {\n    if (!element) {\n      return;\n    }\n\n    this.element = element; // parent layout class, i.e. Masonry, Isotope, or Packery\n\n    this.layout = layout;\n    this.position = {\n      x: 0,\n      y: 0\n    };\n\n    this._create();\n  } // inherit EvEmitter\n\n\n  var proto = Item.prototype = Object.create(EvEmitter.prototype);\n  proto.constructor = Item;\n\n  proto._create = function () {\n    // transition objects\n    this._transn = {\n      ingProperties: {},\n      clean: {},\n      onEnd: {}\n    };\n    this.css({\n      position: 'absolute'\n    });\n  }; // trigger specified handler for event type\n\n\n  proto.handleEvent = function (event) {\n    var method = 'on' + event.type;\n\n    if (this[method]) {\n      this[method](event);\n    }\n  };\n\n  proto.getSize = function () {\n    this.size = getSize(this.element);\n  };\n  /**\n   * apply CSS styles to element\n   * @param {Object} style\n   */\n\n\n  proto.css = function (style) {\n    var elemStyle = this.element.style;\n\n    for (var prop in style) {\n      // use vendor property if available\n      var supportedProp = vendorProperties[prop] || prop;\n      elemStyle[supportedProp] = style[prop];\n    }\n  }; // measure position, and sets it\n\n\n  proto.getPosition = function () {\n    var style = getComputedStyle(this.element);\n\n    var isOriginLeft = this.layout._getOption('originLeft');\n\n    var isOriginTop = this.layout._getOption('originTop');\n\n    var xValue = style[isOriginLeft ? 'left' : 'right'];\n    var yValue = style[isOriginTop ? 'top' : 'bottom'];\n    var x = parseFloat(xValue);\n    var y = parseFloat(yValue); // convert percent to pixels\n\n    var layoutSize = this.layout.size;\n\n    if (xValue.indexOf('%') != -1) {\n      x = x / 100 * layoutSize.width;\n    }\n\n    if (yValue.indexOf('%') != -1) {\n      y = y / 100 * layoutSize.height;\n    } // clean up 'auto' or other non-integer values\n\n\n    x = isNaN(x) ? 0 : x;\n    y = isNaN(y) ? 0 : y; // remove padding from measurement\n\n    x -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;\n    y -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;\n    this.position.x = x;\n    this.position.y = y;\n  }; // set settled position, apply padding\n\n\n  proto.layoutPosition = function () {\n    var layoutSize = this.layout.size;\n    var style = {};\n\n    var isOriginLeft = this.layout._getOption('originLeft');\n\n    var isOriginTop = this.layout._getOption('originTop'); // x\n\n\n    var xPadding = isOriginLeft ? 'paddingLeft' : 'paddingRight';\n    var xProperty = isOriginLeft ? 'left' : 'right';\n    var xResetProperty = isOriginLeft ? 'right' : 'left';\n    var x = this.position.x + layoutSize[xPadding]; // set in percentage or pixels\n\n    style[xProperty] = this.getXValue(x); // reset other property\n\n    style[xResetProperty] = ''; // y\n\n    var yPadding = isOriginTop ? 'paddingTop' : 'paddingBottom';\n    var yProperty = isOriginTop ? 'top' : 'bottom';\n    var yResetProperty = isOriginTop ? 'bottom' : 'top';\n    var y = this.position.y + layoutSize[yPadding]; // set in percentage or pixels\n\n    style[yProperty] = this.getYValue(y); // reset other property\n\n    style[yResetProperty] = '';\n    this.css(style);\n    this.emitEvent('layout', [this]);\n  };\n\n  proto.getXValue = function (x) {\n    var isHorizontal = this.layout._getOption('horizontal');\n\n    return this.layout.options.percentPosition && !isHorizontal ? x / this.layout.size.width * 100 + '%' : x + 'px';\n  };\n\n  proto.getYValue = function (y) {\n    var isHorizontal = this.layout._getOption('horizontal');\n\n    return this.layout.options.percentPosition && isHorizontal ? y / this.layout.size.height * 100 + '%' : y + 'px';\n  };\n\n  proto._transitionTo = function (x, y) {\n    this.getPosition(); // get current x & y from top/left\n\n    var curX = this.position.x;\n    var curY = this.position.y;\n    var didNotMove = x == this.position.x && y == this.position.y; // save end position\n\n    this.setPosition(x, y); // if did not move and not transitioning, just go to layout\n\n    if (didNotMove && !this.isTransitioning) {\n      this.layoutPosition();\n      return;\n    }\n\n    var transX = x - curX;\n    var transY = y - curY;\n    var transitionStyle = {};\n    transitionStyle.transform = this.getTranslate(transX, transY);\n    this.transition({\n      to: transitionStyle,\n      onTransitionEnd: {\n        transform: this.layoutPosition\n      },\n      isCleaning: true\n    });\n  };\n\n  proto.getTranslate = function (x, y) {\n    // flip cooridinates if origin on right or bottom\n    var isOriginLeft = this.layout._getOption('originLeft');\n\n    var isOriginTop = this.layout._getOption('originTop');\n\n    x = isOriginLeft ? x : -x;\n    y = isOriginTop ? y : -y;\n    return 'translate3d(' + x + 'px, ' + y + 'px, 0)';\n  }; // non transition + transform support\n\n\n  proto.goTo = function (x, y) {\n    this.setPosition(x, y);\n    this.layoutPosition();\n  };\n\n  proto.moveTo = proto._transitionTo;\n\n  proto.setPosition = function (x, y) {\n    this.position.x = parseFloat(x);\n    this.position.y = parseFloat(y);\n  }; // ----- transition ----- //\n\n  /**\n   * @param {Object} style - CSS\n   * @param {Function} onTransitionEnd\n   */\n  // non transition, just trigger callback\n\n\n  proto._nonTransition = function (args) {\n    this.css(args.to);\n\n    if (args.isCleaning) {\n      this._removeStyles(args.to);\n    }\n\n    for (var prop in args.onTransitionEnd) {\n      args.onTransitionEnd[prop].call(this);\n    }\n  };\n  /**\n   * proper transition\n   * @param {Object} args - arguments\n   *   @param {Object} to - style to transition to\n   *   @param {Object} from - style to start transition from\n   *   @param {Boolean} isCleaning - removes transition styles after transition\n   *   @param {Function} onTransitionEnd - callback\n   */\n\n\n  proto.transition = function (args) {\n    // redirect to nonTransition if no transition duration\n    if (!parseFloat(this.layout.options.transitionDuration)) {\n      this._nonTransition(args);\n\n      return;\n    }\n\n    var _transition = this._transn; // keep track of onTransitionEnd callback by css property\n\n    for (var prop in args.onTransitionEnd) {\n      _transition.onEnd[prop] = args.onTransitionEnd[prop];\n    } // keep track of properties that are transitioning\n\n\n    for (prop in args.to) {\n      _transition.ingProperties[prop] = true; // keep track of properties to clean up when transition is done\n\n      if (args.isCleaning) {\n        _transition.clean[prop] = true;\n      }\n    } // set from styles\n\n\n    if (args.from) {\n      this.css(args.from); // force redraw. http://blog.alexmaccaw.com/css-transitions\n\n      var h = this.element.offsetHeight; // hack for JSHint to hush about unused var\n\n      h = null;\n    } // enable transition\n\n\n    this.enableTransition(args.to); // set styles that are transitioning\n\n    this.css(args.to);\n    this.isTransitioning = true;\n  }; // dash before all cap letters, including first for\n  // WebkitTransform => -webkit-transform\n\n\n  function toDashedAll(str) {\n    return str.replace(/([A-Z])/g, function ($1) {\n      return '-' + $1.toLowerCase();\n    });\n  }\n\n  var transitionProps = 'opacity,' + toDashedAll(transformProperty);\n\n  proto.enableTransition = function ()\n  /* style */\n  {\n    // HACK changing transitionProperty during a transition\n    // will cause transition to jump\n    if (this.isTransitioning) {\n      return;\n    } // make `transition: foo, bar, baz` from style object\n    // HACK un-comment this when enableTransition can work\n    // while a transition is happening\n    // var transitionValues = [];\n    // for ( var prop in style ) {\n    //   // dash-ify camelCased properties like WebkitTransition\n    //   prop = vendorProperties[ prop ] || prop;\n    //   transitionValues.push( toDashedAll( prop ) );\n    // }\n    // munge number to millisecond, to match stagger\n\n\n    var duration = this.layout.options.transitionDuration;\n    duration = typeof duration == 'number' ? duration + 'ms' : duration; // enable transition styles\n\n    this.css({\n      transitionProperty: transitionProps,\n      transitionDuration: duration,\n      transitionDelay: this.staggerDelay || 0\n    }); // listen for transition end event\n\n    this.element.addEventListener(transitionEndEvent, this, false);\n  }; // ----- events ----- //\n\n\n  proto.onwebkitTransitionEnd = function (event) {\n    this.ontransitionend(event);\n  };\n\n  proto.onotransitionend = function (event) {\n    this.ontransitionend(event);\n  }; // properties that I munge to make my life easier\n\n\n  var dashedVendorProperties = {\n    '-webkit-transform': 'transform'\n  };\n\n  proto.ontransitionend = function (event) {\n    // disregard bubbled events from children\n    if (event.target !== this.element) {\n      return;\n    }\n\n    var _transition = this._transn; // get property name of transitioned property, convert to prefix-free\n\n    var propertyName = dashedVendorProperties[event.propertyName] || event.propertyName; // remove property that has completed transitioning\n\n    delete _transition.ingProperties[propertyName]; // check if any properties are still transitioning\n\n    if (isEmptyObj(_transition.ingProperties)) {\n      // all properties have completed transitioning\n      this.disableTransition();\n    } // clean style\n\n\n    if (propertyName in _transition.clean) {\n      // clean up style\n      this.element.style[event.propertyName] = '';\n      delete _transition.clean[propertyName];\n    } // trigger onTransitionEnd callback\n\n\n    if (propertyName in _transition.onEnd) {\n      var onTransitionEnd = _transition.onEnd[propertyName];\n      onTransitionEnd.call(this);\n      delete _transition.onEnd[propertyName];\n    }\n\n    this.emitEvent('transitionEnd', [this]);\n  };\n\n  proto.disableTransition = function () {\n    this.removeTransitionStyles();\n    this.element.removeEventListener(transitionEndEvent, this, false);\n    this.isTransitioning = false;\n  };\n  /**\n   * removes style property from element\n   * @param {Object} style\n  **/\n\n\n  proto._removeStyles = function (style) {\n    // clean up transition styles\n    var cleanStyle = {};\n\n    for (var prop in style) {\n      cleanStyle[prop] = '';\n    }\n\n    this.css(cleanStyle);\n  };\n\n  var cleanTransitionStyle = {\n    transitionProperty: '',\n    transitionDuration: '',\n    transitionDelay: ''\n  };\n\n  proto.removeTransitionStyles = function () {\n    // remove transition\n    this.css(cleanTransitionStyle);\n  }; // ----- stagger ----- //\n\n\n  proto.stagger = function (delay) {\n    delay = isNaN(delay) ? 0 : delay;\n    this.staggerDelay = delay + 'ms';\n  }; // ----- show/hide/remove ----- //\n  // remove element from DOM\n\n\n  proto.removeElem = function () {\n    this.element.parentNode.removeChild(this.element); // remove display: none\n\n    this.css({\n      display: ''\n    });\n    this.emitEvent('remove', [this]);\n  };\n\n  proto.remove = function () {\n    // just remove element if no transition support or no transition\n    if (!transitionProperty || !parseFloat(this.layout.options.transitionDuration)) {\n      this.removeElem();\n      return;\n    } // start transition\n\n\n    this.once('transitionEnd', function () {\n      this.removeElem();\n    });\n    this.hide();\n  };\n\n  proto.reveal = function () {\n    delete this.isHidden; // remove display: none\n\n    this.css({\n      display: ''\n    });\n    var options = this.layout.options;\n    var onTransitionEnd = {};\n    var transitionEndProperty = this.getHideRevealTransitionEndProperty('visibleStyle');\n    onTransitionEnd[transitionEndProperty] = this.onRevealTransitionEnd;\n    this.transition({\n      from: options.hiddenStyle,\n      to: options.visibleStyle,\n      isCleaning: true,\n      onTransitionEnd: onTransitionEnd\n    });\n  };\n\n  proto.onRevealTransitionEnd = function () {\n    // check if still visible\n    // during transition, item may have been hidden\n    if (!this.isHidden) {\n      this.emitEvent('reveal');\n    }\n  };\n  /**\n   * get style property use for hide/reveal transition end\n   * @param {String} styleProperty - hiddenStyle/visibleStyle\n   * @returns {String}\n   */\n\n\n  proto.getHideRevealTransitionEndProperty = function (styleProperty) {\n    var optionStyle = this.layout.options[styleProperty]; // use opacity\n\n    if (optionStyle.opacity) {\n      return 'opacity';\n    } // get first property\n\n\n    for (var prop in optionStyle) {\n      return prop;\n    }\n  };\n\n  proto.hide = function () {\n    // set flag\n    this.isHidden = true; // remove display: none\n\n    this.css({\n      display: ''\n    });\n    var options = this.layout.options;\n    var onTransitionEnd = {};\n    var transitionEndProperty = this.getHideRevealTransitionEndProperty('hiddenStyle');\n    onTransitionEnd[transitionEndProperty] = this.onHideTransitionEnd;\n    this.transition({\n      from: options.visibleStyle,\n      to: options.hiddenStyle,\n      // keep hidden stuff hidden\n      isCleaning: true,\n      onTransitionEnd: onTransitionEnd\n    });\n  };\n\n  proto.onHideTransitionEnd = function () {\n    // check if still hidden\n    // during transition, item may have been un-hidden\n    if (this.isHidden) {\n      this.css({\n        display: 'none'\n      });\n      this.emitEvent('hide');\n    }\n  };\n\n  proto.destroy = function () {\n    this.css({\n      position: '',\n      left: '',\n      right: '',\n      top: '',\n      bottom: '',\n      transition: '',\n      transform: ''\n    });\n  };\n\n  return Item;\n});\n/*!\n * Outlayer v2.1.1\n * the brains and guts of a layout library\n * MIT license\n */\n\n\n(function (window, factory) {\n  'use strict'; // universal module definition\n\n  /* jshint strict: false */\n\n  /* globals define, module, require */\n\n  if (true) {\n    // AMD - RequireJS\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_1__, __WEBPACK_LOCAL_MODULE_2__, __WEBPACK_LOCAL_MODULE_4__, __WEBPACK_LOCAL_MODULE_5__], __WEBPACK_LOCAL_MODULE_6__ = (function (EvEmitter, getSize, utils, Item) {\n      return factory(window, EvEmitter, getSize, utils, Item);\n    }).apply(__WEBPACK_LOCAL_MODULE_6__exports = {}, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_LOCAL_MODULE_6__ === undefined && (__WEBPACK_LOCAL_MODULE_6__ = __WEBPACK_LOCAL_MODULE_6__exports));\n  } else {}\n})(window, function factory(window, EvEmitter, getSize, utils, Item) {\n  'use strict'; // ----- vars ----- //\n\n  var console = window.console;\n  var jQuery = window.jQuery;\n\n  var noop = function noop() {}; // -------------------------- Outlayer -------------------------- //\n  // globally unique identifiers\n\n\n  var GUID = 0; // internal store of all Outlayer intances\n\n  var instances = {};\n  /**\n   * @param {Element, String} element\n   * @param {Object} options\n   * @constructor\n   */\n\n  function Outlayer(element, options) {\n    var queryElement = utils.getQueryElement(element);\n\n    if (!queryElement) {\n      if (console) {\n        console.error('Bad element for ' + this.constructor.namespace + ': ' + (queryElement || element));\n      }\n\n      return;\n    }\n\n    this.element = queryElement; // add jQuery\n\n    if (jQuery) {\n      this.$element = jQuery(this.element);\n    } // options\n\n\n    this.options = utils.extend({}, this.constructor.defaults);\n    this.option(options); // add id for Outlayer.getFromElement\n\n    var id = ++GUID;\n    this.element.outlayerGUID = id; // expando\n\n    instances[id] = this; // associate via id\n    // kick it off\n\n    this._create();\n\n    var isInitLayout = this._getOption('initLayout');\n\n    if (isInitLayout) {\n      this.layout();\n    }\n  } // settings are for internal use only\n\n\n  Outlayer.namespace = 'outlayer';\n  Outlayer.Item = Item; // default options\n\n  Outlayer.defaults = {\n    containerStyle: {\n      position: 'relative'\n    },\n    initLayout: true,\n    originLeft: true,\n    originTop: true,\n    resize: true,\n    resizeContainer: true,\n    // item options\n    transitionDuration: '0.4s',\n    hiddenStyle: {\n      opacity: 0,\n      transform: 'scale(0.001)'\n    },\n    visibleStyle: {\n      opacity: 1,\n      transform: 'scale(1)'\n    }\n  };\n  var proto = Outlayer.prototype; // inherit EvEmitter\n\n  utils.extend(proto, EvEmitter.prototype);\n  /**\n   * set options\n   * @param {Object} opts\n   */\n\n  proto.option = function (opts) {\n    utils.extend(this.options, opts);\n  };\n  /**\n   * get backwards compatible option value, check old name\n   */\n\n\n  proto._getOption = function (option) {\n    var oldOption = this.constructor.compatOptions[option];\n    return oldOption && this.options[oldOption] !== undefined ? this.options[oldOption] : this.options[option];\n  };\n\n  Outlayer.compatOptions = {\n    // currentName: oldName\n    initLayout: 'isInitLayout',\n    horizontal: 'isHorizontal',\n    layoutInstant: 'isLayoutInstant',\n    originLeft: 'isOriginLeft',\n    originTop: 'isOriginTop',\n    resize: 'isResizeBound',\n    resizeContainer: 'isResizingContainer'\n  };\n\n  proto._create = function () {\n    // get items from children\n    this.reloadItems(); // elements that affect layout, but are not laid out\n\n    this.stamps = [];\n    this.stamp(this.options.stamp); // set container style\n\n    utils.extend(this.element.style, this.options.containerStyle); // bind resize method\n\n    var canBindResize = this._getOption('resize');\n\n    if (canBindResize) {\n      this.bindResize();\n    }\n  }; // goes through all children again and gets bricks in proper order\n\n\n  proto.reloadItems = function () {\n    // collection of item elements\n    this.items = this._itemize(this.element.children);\n  };\n  /**\n   * turn elements into Outlayer.Items to be used in layout\n   * @param {Array or NodeList or HTMLElement} elems\n   * @returns {Array} items - collection of new Outlayer Items\n   */\n\n\n  proto._itemize = function (elems) {\n    var itemElems = this._filterFindItemElements(elems);\n\n    var Item = this.constructor.Item; // create new Outlayer Items for collection\n\n    var items = [];\n\n    for (var i = 0; i < itemElems.length; i++) {\n      var elem = itemElems[i];\n      var item = new Item(elem, this);\n      items.push(item);\n    }\n\n    return items;\n  };\n  /**\n   * get item elements to be used in layout\n   * @param {Array or NodeList or HTMLElement} elems\n   * @returns {Array} items - item elements\n   */\n\n\n  proto._filterFindItemElements = function (elems) {\n    return utils.filterFindElements(elems, this.options.itemSelector);\n  };\n  /**\n   * getter method for getting item elements\n   * @returns {Array} elems - collection of item elements\n   */\n\n\n  proto.getItemElements = function () {\n    return this.items.map(function (item) {\n      return item.element;\n    });\n  }; // ----- init & layout ----- //\n\n  /**\n   * lays out all items\n   */\n\n\n  proto.layout = function () {\n    this._resetLayout();\n\n    this._manageStamps(); // don't animate first layout\n\n\n    var layoutInstant = this._getOption('layoutInstant');\n\n    var isInstant = layoutInstant !== undefined ? layoutInstant : !this._isLayoutInited;\n    this.layoutItems(this.items, isInstant); // flag for initalized\n\n    this._isLayoutInited = true;\n  }; // _init is alias for layout\n\n\n  proto._init = proto.layout;\n  /**\n   * logic before any new layout\n   */\n\n  proto._resetLayout = function () {\n    this.getSize();\n  };\n\n  proto.getSize = function () {\n    this.size = getSize(this.element);\n  };\n  /**\n   * get measurement from option, for columnWidth, rowHeight, gutter\n   * if option is String -> get element from selector string, & get size of element\n   * if option is Element -> get size of element\n   * else use option as a number\n   *\n   * @param {String} measurement\n   * @param {String} size - width or height\n   * @private\n   */\n\n\n  proto._getMeasurement = function (measurement, size) {\n    var option = this.options[measurement];\n    var elem;\n\n    if (!option) {\n      // default to 0\n      this[measurement] = 0;\n    } else {\n      // use option as an element\n      if (typeof option == 'string') {\n        elem = this.element.querySelector(option);\n      } else if (option instanceof HTMLElement) {\n        elem = option;\n      } // use size of element, if element\n\n\n      this[measurement] = elem ? getSize(elem)[size] : option;\n    }\n  };\n  /**\n   * layout a collection of item elements\n   * @api public\n   */\n\n\n  proto.layoutItems = function (items, isInstant) {\n    items = this._getItemsForLayout(items);\n\n    this._layoutItems(items, isInstant);\n\n    this._postLayout();\n  };\n  /**\n   * get the items to be laid out\n   * you may want to skip over some items\n   * @param {Array} items\n   * @returns {Array} items\n   */\n\n\n  proto._getItemsForLayout = function (items) {\n    return items.filter(function (item) {\n      return !item.isIgnored;\n    });\n  };\n  /**\n   * layout items\n   * @param {Array} items\n   * @param {Boolean} isInstant\n   */\n\n\n  proto._layoutItems = function (items, isInstant) {\n    this._emitCompleteOnItems('layout', items);\n\n    if (!items || !items.length) {\n      // no items, emit event with empty array\n      return;\n    }\n\n    var queue = [];\n    items.forEach(function (item) {\n      // get x/y object from method\n      var position = this._getItemLayoutPosition(item); // enqueue\n\n\n      position.item = item;\n      position.isInstant = isInstant || item.isLayoutInstant;\n      queue.push(position);\n    }, this);\n\n    this._processLayoutQueue(queue);\n  };\n  /**\n   * get item layout position\n   * @param {Outlayer.Item} item\n   * @returns {Object} x and y position\n   */\n\n\n  proto._getItemLayoutPosition = function ()\n  /* item */\n  {\n    return {\n      x: 0,\n      y: 0\n    };\n  };\n  /**\n   * iterate over array and position each item\n   * Reason being - separating this logic prevents 'layout invalidation'\n   * thx @paul_irish\n   * @param {Array} queue\n   */\n\n\n  proto._processLayoutQueue = function (queue) {\n    this.updateStagger();\n    queue.forEach(function (obj, i) {\n      this._positionItem(obj.item, obj.x, obj.y, obj.isInstant, i);\n    }, this);\n  }; // set stagger from option in milliseconds number\n\n\n  proto.updateStagger = function () {\n    var stagger = this.options.stagger;\n\n    if (stagger === null || stagger === undefined) {\n      this.stagger = 0;\n      return;\n    }\n\n    this.stagger = getMilliseconds(stagger);\n    return this.stagger;\n  };\n  /**\n   * Sets position of item in DOM\n   * @param {Outlayer.Item} item\n   * @param {Number} x - horizontal position\n   * @param {Number} y - vertical position\n   * @param {Boolean} isInstant - disables transitions\n   */\n\n\n  proto._positionItem = function (item, x, y, isInstant, i) {\n    if (isInstant) {\n      // if not transition, just set CSS\n      item.goTo(x, y);\n    } else {\n      item.stagger(i * this.stagger);\n      item.moveTo(x, y);\n    }\n  };\n  /**\n   * Any logic you want to do after each layout,\n   * i.e. size the container\n   */\n\n\n  proto._postLayout = function () {\n    this.resizeContainer();\n  };\n\n  proto.resizeContainer = function () {\n    var isResizingContainer = this._getOption('resizeContainer');\n\n    if (!isResizingContainer) {\n      return;\n    }\n\n    var size = this._getContainerSize();\n\n    if (size) {\n      this._setContainerMeasure(size.width, true);\n\n      this._setContainerMeasure(size.height, false);\n    }\n  };\n  /**\n   * Sets width or height of container if returned\n   * @returns {Object} size\n   *   @param {Number} width\n   *   @param {Number} height\n   */\n\n\n  proto._getContainerSize = noop;\n  /**\n   * @param {Number} measure - size of width or height\n   * @param {Boolean} isWidth\n   */\n\n  proto._setContainerMeasure = function (measure, isWidth) {\n    if (measure === undefined) {\n      return;\n    }\n\n    var elemSize = this.size; // add padding and border width if border box\n\n    if (elemSize.isBorderBox) {\n      measure += isWidth ? elemSize.paddingLeft + elemSize.paddingRight + elemSize.borderLeftWidth + elemSize.borderRightWidth : elemSize.paddingBottom + elemSize.paddingTop + elemSize.borderTopWidth + elemSize.borderBottomWidth;\n    }\n\n    measure = Math.max(measure, 0);\n    this.element.style[isWidth ? 'width' : 'height'] = measure + 'px';\n  };\n  /**\n   * emit eventComplete on a collection of items events\n   * @param {String} eventName\n   * @param {Array} items - Outlayer.Items\n   */\n\n\n  proto._emitCompleteOnItems = function (eventName, items) {\n    var _this = this;\n\n    function onComplete() {\n      _this.dispatchEvent(eventName + 'Complete', null, [items]);\n    }\n\n    var count = items.length;\n\n    if (!items || !count) {\n      onComplete();\n      return;\n    }\n\n    var doneCount = 0;\n\n    function tick() {\n      doneCount++;\n\n      if (doneCount == count) {\n        onComplete();\n      }\n    } // bind callback\n\n\n    items.forEach(function (item) {\n      item.once(eventName, tick);\n    });\n  };\n  /**\n   * emits events via EvEmitter and jQuery events\n   * @param {String} type - name of event\n   * @param {Event} event - original event\n   * @param {Array} args - extra arguments\n   */\n\n\n  proto.dispatchEvent = function (type, event, args) {\n    // add original event to arguments\n    var emitArgs = event ? [event].concat(args) : args;\n    this.emitEvent(type, emitArgs);\n\n    if (jQuery) {\n      // set this.$element\n      this.$element = this.$element || jQuery(this.element);\n\n      if (event) {\n        // create jQuery event\n        var $event = jQuery.Event(event);\n        $event.type = type;\n        this.$element.trigger($event, args);\n      } else {\n        // just trigger with type if no event available\n        this.$element.trigger(type, args);\n      }\n    }\n  }; // -------------------------- ignore & stamps -------------------------- //\n\n  /**\n   * keep item in collection, but do not lay it out\n   * ignored items do not get skipped in layout\n   * @param {Element} elem\n   */\n\n\n  proto.ignore = function (elem) {\n    var item = this.getItem(elem);\n\n    if (item) {\n      item.isIgnored = true;\n    }\n  };\n  /**\n   * return item to layout collection\n   * @param {Element} elem\n   */\n\n\n  proto.unignore = function (elem) {\n    var item = this.getItem(elem);\n\n    if (item) {\n      delete item.isIgnored;\n    }\n  };\n  /**\n   * adds elements to stamps\n   * @param {NodeList, Array, Element, or String} elems\n   */\n\n\n  proto.stamp = function (elems) {\n    elems = this._find(elems);\n\n    if (!elems) {\n      return;\n    }\n\n    this.stamps = this.stamps.concat(elems); // ignore\n\n    elems.forEach(this.ignore, this);\n  };\n  /**\n   * removes elements to stamps\n   * @param {NodeList, Array, or Element} elems\n   */\n\n\n  proto.unstamp = function (elems) {\n    elems = this._find(elems);\n\n    if (!elems) {\n      return;\n    }\n\n    elems.forEach(function (elem) {\n      // filter out removed stamp elements\n      utils.removeFrom(this.stamps, elem);\n      this.unignore(elem);\n    }, this);\n  };\n  /**\n   * finds child elements\n   * @param {NodeList, Array, Element, or String} elems\n   * @returns {Array} elems\n   */\n\n\n  proto._find = function (elems) {\n    if (!elems) {\n      return;\n    } // if string, use argument as selector string\n\n\n    if (typeof elems == 'string') {\n      elems = this.element.querySelectorAll(elems);\n    }\n\n    elems = utils.makeArray(elems);\n    return elems;\n  };\n\n  proto._manageStamps = function () {\n    if (!this.stamps || !this.stamps.length) {\n      return;\n    }\n\n    this._getBoundingRect();\n\n    this.stamps.forEach(this._manageStamp, this);\n  }; // update boundingLeft / Top\n\n\n  proto._getBoundingRect = function () {\n    // get bounding rect for container element\n    var boundingRect = this.element.getBoundingClientRect();\n    var size = this.size;\n    this._boundingRect = {\n      left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,\n      top: boundingRect.top + size.paddingTop + size.borderTopWidth,\n      right: boundingRect.right - (size.paddingRight + size.borderRightWidth),\n      bottom: boundingRect.bottom - (size.paddingBottom + size.borderBottomWidth)\n    };\n  };\n  /**\n   * @param {Element} stamp\n  **/\n\n\n  proto._manageStamp = noop;\n  /**\n   * get x/y position of element relative to container element\n   * @param {Element} elem\n   * @returns {Object} offset - has left, top, right, bottom\n   */\n\n  proto._getElementOffset = function (elem) {\n    var boundingRect = elem.getBoundingClientRect();\n    var thisRect = this._boundingRect;\n    var size = getSize(elem);\n    var offset = {\n      left: boundingRect.left - thisRect.left - size.marginLeft,\n      top: boundingRect.top - thisRect.top - size.marginTop,\n      right: thisRect.right - boundingRect.right - size.marginRight,\n      bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom\n    };\n    return offset;\n  }; // -------------------------- resize -------------------------- //\n  // enable event handlers for listeners\n  // i.e. resize -> onresize\n\n\n  proto.handleEvent = utils.handleEvent;\n  /**\n   * Bind layout to window resizing\n   */\n\n  proto.bindResize = function () {\n    window.addEventListener('resize', this);\n    this.isResizeBound = true;\n  };\n  /**\n   * Unbind layout to window resizing\n   */\n\n\n  proto.unbindResize = function () {\n    window.removeEventListener('resize', this);\n    this.isResizeBound = false;\n  };\n\n  proto.onresize = function () {\n    this.resize();\n  };\n\n  utils.debounceMethod(Outlayer, 'onresize', 100);\n\n  proto.resize = function () {\n    // don't trigger if size did not change\n    // or if resize was unbound. See #9\n    if (!this.isResizeBound || !this.needsResizeLayout()) {\n      return;\n    }\n\n    this.layout();\n  };\n  /**\n   * check if layout is needed post layout\n   * @returns Boolean\n   */\n\n\n  proto.needsResizeLayout = function () {\n    var size = getSize(this.element); // check that this.size and size are there\n    // IE8 triggers resize on body size change, so they might not be\n\n    var hasSizes = this.size && size;\n    return hasSizes && size.innerWidth !== this.size.innerWidth;\n  }; // -------------------------- methods -------------------------- //\n\n  /**\n   * add items to Outlayer instance\n   * @param {Array or NodeList or Element} elems\n   * @returns {Array} items - Outlayer.Items\n  **/\n\n\n  proto.addItems = function (elems) {\n    var items = this._itemize(elems); // add items to collection\n\n\n    if (items.length) {\n      this.items = this.items.concat(items);\n    }\n\n    return items;\n  };\n  /**\n   * Layout newly-appended item elements\n   * @param {Array or NodeList or Element} elems\n   */\n\n\n  proto.appended = function (elems) {\n    var items = this.addItems(elems);\n\n    if (!items.length) {\n      return;\n    } // layout and reveal just the new items\n\n\n    this.layoutItems(items, true);\n    this.reveal(items);\n  };\n  /**\n   * Layout prepended elements\n   * @param {Array or NodeList or Element} elems\n   */\n\n\n  proto.prepended = function (elems) {\n    var items = this._itemize(elems);\n\n    if (!items.length) {\n      return;\n    } // add items to beginning of collection\n\n\n    var previousItems = this.items.slice(0);\n    this.items = items.concat(previousItems); // start new layout\n\n    this._resetLayout();\n\n    this._manageStamps(); // layout new stuff without transition\n\n\n    this.layoutItems(items, true);\n    this.reveal(items); // layout previous items\n\n    this.layoutItems(previousItems);\n  };\n  /**\n   * reveal a collection of items\n   * @param {Array of Outlayer.Items} items\n   */\n\n\n  proto.reveal = function (items) {\n    this._emitCompleteOnItems('reveal', items);\n\n    if (!items || !items.length) {\n      return;\n    }\n\n    var stagger = this.updateStagger();\n    items.forEach(function (item, i) {\n      item.stagger(i * stagger);\n      item.reveal();\n    });\n  };\n  /**\n   * hide a collection of items\n   * @param {Array of Outlayer.Items} items\n   */\n\n\n  proto.hide = function (items) {\n    this._emitCompleteOnItems('hide', items);\n\n    if (!items || !items.length) {\n      return;\n    }\n\n    var stagger = this.updateStagger();\n    items.forEach(function (item, i) {\n      item.stagger(i * stagger);\n      item.hide();\n    });\n  };\n  /**\n   * reveal item elements\n   * @param {Array}, {Element}, {NodeList} items\n   */\n\n\n  proto.revealItemElements = function (elems) {\n    var items = this.getItems(elems);\n    this.reveal(items);\n  };\n  /**\n   * hide item elements\n   * @param {Array}, {Element}, {NodeList} items\n   */\n\n\n  proto.hideItemElements = function (elems) {\n    var items = this.getItems(elems);\n    this.hide(items);\n  };\n  /**\n   * get Outlayer.Item, given an Element\n   * @param {Element} elem\n   * @param {Function} callback\n   * @returns {Outlayer.Item} item\n   */\n\n\n  proto.getItem = function (elem) {\n    // loop through items to get the one that matches\n    for (var i = 0; i < this.items.length; i++) {\n      var item = this.items[i];\n\n      if (item.element == elem) {\n        // return item\n        return item;\n      }\n    }\n  };\n  /**\n   * get collection of Outlayer.Items, given Elements\n   * @param {Array} elems\n   * @returns {Array} items - Outlayer.Items\n   */\n\n\n  proto.getItems = function (elems) {\n    elems = utils.makeArray(elems);\n    var items = [];\n    elems.forEach(function (elem) {\n      var item = this.getItem(elem);\n\n      if (item) {\n        items.push(item);\n      }\n    }, this);\n    return items;\n  };\n  /**\n   * remove element(s) from instance and DOM\n   * @param {Array or NodeList or Element} elems\n   */\n\n\n  proto.remove = function (elems) {\n    var removeItems = this.getItems(elems);\n\n    this._emitCompleteOnItems('remove', removeItems); // bail if no items to remove\n\n\n    if (!removeItems || !removeItems.length) {\n      return;\n    }\n\n    removeItems.forEach(function (item) {\n      item.remove(); // remove item from collection\n\n      utils.removeFrom(this.items, item);\n    }, this);\n  }; // ----- destroy ----- //\n  // remove and disable Outlayer instance\n\n\n  proto.destroy = function () {\n    // clean up dynamic styles\n    var style = this.element.style;\n    style.height = '';\n    style.position = '';\n    style.width = ''; // destroy items\n\n    this.items.forEach(function (item) {\n      item.destroy();\n    });\n    this.unbindResize();\n    var id = this.element.outlayerGUID;\n    delete instances[id]; // remove reference to instance by id\n\n    delete this.element.outlayerGUID; // remove data for jQuery\n\n    if (jQuery) {\n      jQuery.removeData(this.element, this.constructor.namespace);\n    }\n  }; // -------------------------- data -------------------------- //\n\n  /**\n   * get Outlayer instance from element\n   * @param {Element} elem\n   * @returns {Outlayer}\n   */\n\n\n  Outlayer.data = function (elem) {\n    elem = utils.getQueryElement(elem);\n    var id = elem && elem.outlayerGUID;\n    return id && instances[id];\n  }; // -------------------------- create Outlayer class -------------------------- //\n\n  /**\n   * create a layout class\n   * @param {String} namespace\n   */\n\n\n  Outlayer.create = function (namespace, options) {\n    // sub-class Outlayer\n    var Layout = subclass(Outlayer); // apply new options and compatOptions\n\n    Layout.defaults = utils.extend({}, Outlayer.defaults);\n    utils.extend(Layout.defaults, options);\n    Layout.compatOptions = utils.extend({}, Outlayer.compatOptions);\n    Layout.namespace = namespace;\n    Layout.data = Outlayer.data; // sub-class Item\n\n    Layout.Item = subclass(Item); // -------------------------- declarative -------------------------- //\n\n    utils.htmlInit(Layout, namespace); // -------------------------- jQuery bridge -------------------------- //\n    // make into jQuery plugin\n\n    if (jQuery && jQuery.bridget) {\n      jQuery.bridget(namespace, Layout);\n    }\n\n    return Layout;\n  };\n\n  function subclass(Parent) {\n    function SubClass() {\n      Parent.apply(this, arguments);\n    }\n\n    SubClass.prototype = Object.create(Parent.prototype);\n    SubClass.prototype.constructor = SubClass;\n    return SubClass;\n  } // ----- helpers ----- //\n  // how many milliseconds are in each unit\n\n\n  var msUnits = {\n    ms: 1,\n    s: 1000\n  }; // munge time-like parameter into millisecond number\n  // '0.4s' -> 40\n\n  function getMilliseconds(time) {\n    if (typeof time == 'number') {\n      return time;\n    }\n\n    var matches = time.match(/(^\\d*\\.?\\d*)(\\w*)/);\n    var num = matches && matches[1];\n    var unit = matches && matches[2];\n\n    if (!num.length) {\n      return 0;\n    }\n\n    num = parseFloat(num);\n    var mult = msUnits[unit] || 1;\n    return num * mult;\n  } // ----- fin ----- //\n  // back in global\n\n\n  Outlayer.Item = Item;\n  return Outlayer;\n});\n/**\n * Isotope Item\n**/\n\n\n(function (window, factory) {\n  // universal module definition\n\n  /* jshint strict: false */\n\n  /*globals define, module, require */\n  if (true) {\n    // AMD\n    !(__WEBPACK_LOCAL_MODULE_7__array = [__WEBPACK_LOCAL_MODULE_6__], __WEBPACK_LOCAL_MODULE_7__factory = (factory),\n\t\t(typeof __WEBPACK_LOCAL_MODULE_7__factory === 'function' ?\n\t\t\t((__WEBPACK_LOCAL_MODULE_7__ = __WEBPACK_LOCAL_MODULE_7__factory.apply(__WEBPACK_LOCAL_MODULE_7__exports = {}, __WEBPACK_LOCAL_MODULE_7__array)), __WEBPACK_LOCAL_MODULE_7__ === undefined && (__WEBPACK_LOCAL_MODULE_7__ = __WEBPACK_LOCAL_MODULE_7__exports)) :\n\t\t\t(__WEBPACK_LOCAL_MODULE_7__ = __WEBPACK_LOCAL_MODULE_7__factory)\n\t\t));\n  } else {}\n})(window, function factory(Outlayer) {\n  'use strict'; // -------------------------- Item -------------------------- //\n  // sub-class Outlayer Item\n\n  function Item() {\n    Outlayer.Item.apply(this, arguments);\n  }\n\n  var proto = Item.prototype = Object.create(Outlayer.Item.prototype);\n  var _create = proto._create;\n\n  proto._create = function () {\n    // assign id, used for original-order sorting\n    this.id = this.layout.itemGUID++;\n\n    _create.call(this);\n\n    this.sortData = {};\n  };\n\n  proto.updateSortData = function () {\n    if (this.isIgnored) {\n      return;\n    } // default sorters\n\n\n    this.sortData.id = this.id; // for backward compatibility\n\n    this.sortData['original-order'] = this.id;\n    this.sortData.random = Math.random(); // go thru getSortData obj and apply the sorters\n\n    var getSortData = this.layout.options.getSortData;\n    var sorters = this.layout._sorters;\n\n    for (var key in getSortData) {\n      var sorter = sorters[key];\n      this.sortData[key] = sorter(this.element, this);\n    }\n  };\n\n  var _destroy = proto.destroy;\n\n  proto.destroy = function () {\n    // call super\n    _destroy.apply(this, arguments); // reset display, #741\n\n\n    this.css({\n      display: ''\n    });\n  };\n\n  return Item;\n});\n/**\n * Isotope LayoutMode\n */\n\n\n(function (window, factory) {\n  // universal module definition\n\n  /* jshint strict: false */\n\n  /*globals define, module, require */\n  if (true) {\n    // AMD\n    !(__WEBPACK_LOCAL_MODULE_8__array = [__WEBPACK_LOCAL_MODULE_2__, __WEBPACK_LOCAL_MODULE_6__], __WEBPACK_LOCAL_MODULE_8__factory = (factory),\n\t\t(typeof __WEBPACK_LOCAL_MODULE_8__factory === 'function' ?\n\t\t\t((__WEBPACK_LOCAL_MODULE_8__ = __WEBPACK_LOCAL_MODULE_8__factory.apply(__WEBPACK_LOCAL_MODULE_8__exports = {}, __WEBPACK_LOCAL_MODULE_8__array)), __WEBPACK_LOCAL_MODULE_8__ === undefined && (__WEBPACK_LOCAL_MODULE_8__ = __WEBPACK_LOCAL_MODULE_8__exports)) :\n\t\t\t(__WEBPACK_LOCAL_MODULE_8__ = __WEBPACK_LOCAL_MODULE_8__factory)\n\t\t));\n  } else {}\n})(window, function factory(getSize, Outlayer) {\n  'use strict'; // layout mode class\n\n  function LayoutMode(isotope) {\n    this.isotope = isotope; // link properties\n\n    if (isotope) {\n      this.options = isotope.options[this.namespace];\n      this.element = isotope.element;\n      this.items = isotope.filteredItems;\n      this.size = isotope.size;\n    }\n  }\n\n  var proto = LayoutMode.prototype;\n  /**\n   * some methods should just defer to default Outlayer method\n   * and reference the Isotope instance as `this`\n  **/\n\n  var facadeMethods = ['_resetLayout', '_getItemLayoutPosition', '_manageStamp', '_getContainerSize', '_getElementOffset', 'needsResizeLayout', '_getOption'];\n  facadeMethods.forEach(function (methodName) {\n    proto[methodName] = function () {\n      return Outlayer.prototype[methodName].apply(this.isotope, arguments);\n    };\n  }); // -----  ----- //\n  // for horizontal layout modes, check vertical size\n\n  proto.needsVerticalResizeLayout = function () {\n    // don't trigger if size did not change\n    var size = getSize(this.isotope.element); // check that this.size and size are there\n    // IE8 triggers resize on body size change, so they might not be\n\n    var hasSizes = this.isotope.size && size;\n    return hasSizes && size.innerHeight != this.isotope.size.innerHeight;\n  }; // ----- measurements ----- //\n\n\n  proto._getMeasurement = function () {\n    this.isotope._getMeasurement.apply(this, arguments);\n  };\n\n  proto.getColumnWidth = function () {\n    this.getSegmentSize('column', 'Width');\n  };\n\n  proto.getRowHeight = function () {\n    this.getSegmentSize('row', 'Height');\n  };\n  /**\n   * get columnWidth or rowHeight\n   * segment: 'column' or 'row'\n   * size 'Width' or 'Height'\n  **/\n\n\n  proto.getSegmentSize = function (segment, size) {\n    var segmentName = segment + size;\n    var outerSize = 'outer' + size; // columnWidth / outerWidth // rowHeight / outerHeight\n\n    this._getMeasurement(segmentName, outerSize); // got rowHeight or columnWidth, we can chill\n\n\n    if (this[segmentName]) {\n      return;\n    } // fall back to item of first element\n\n\n    var firstItemSize = this.getFirstItemSize();\n    this[segmentName] = firstItemSize && firstItemSize[outerSize] || // or size of container\n    this.isotope.size['inner' + size];\n  };\n\n  proto.getFirstItemSize = function () {\n    var firstItem = this.isotope.filteredItems[0];\n    return firstItem && firstItem.element && getSize(firstItem.element);\n  }; // ----- methods that should reference isotope ----- //\n\n\n  proto.layout = function () {\n    this.isotope.layout.apply(this.isotope, arguments);\n  };\n\n  proto.getSize = function () {\n    this.isotope.getSize();\n    this.size = this.isotope.size;\n  }; // -------------------------- create -------------------------- //\n\n\n  LayoutMode.modes = {};\n\n  LayoutMode.create = function (namespace, options) {\n    function Mode() {\n      LayoutMode.apply(this, arguments);\n    }\n\n    Mode.prototype = Object.create(proto);\n    Mode.prototype.constructor = Mode; // default options\n\n    if (options) {\n      Mode.options = options;\n    }\n\n    Mode.prototype.namespace = namespace; // register in Isotope\n\n    LayoutMode.modes[namespace] = Mode;\n    return Mode;\n  };\n\n  return LayoutMode;\n});\n/*!\n * Masonry v4.2.1\n * Cascading grid layout library\n * https://masonry.desandro.com\n * MIT License\n * by David DeSandro\n */\n\n\n(function (window, factory) {\n  // universal module definition\n\n  /* jshint strict: false */\n\n  /*globals define, module, require */\n  if (true) {\n    // AMD\n    !(__WEBPACK_LOCAL_MODULE_9__array = [__WEBPACK_LOCAL_MODULE_6__, __WEBPACK_LOCAL_MODULE_2__], __WEBPACK_LOCAL_MODULE_9__factory = (factory),\n\t\t(typeof __WEBPACK_LOCAL_MODULE_9__factory === 'function' ?\n\t\t\t((__WEBPACK_LOCAL_MODULE_9__ = __WEBPACK_LOCAL_MODULE_9__factory.apply(__WEBPACK_LOCAL_MODULE_9__exports = {}, __WEBPACK_LOCAL_MODULE_9__array)), __WEBPACK_LOCAL_MODULE_9__ === undefined && (__WEBPACK_LOCAL_MODULE_9__ = __WEBPACK_LOCAL_MODULE_9__exports)) :\n\t\t\t(__WEBPACK_LOCAL_MODULE_9__ = __WEBPACK_LOCAL_MODULE_9__factory)\n\t\t));\n  } else {}\n})(window, function factory(Outlayer, getSize) {\n  // -------------------------- masonryDefinition -------------------------- //\n  // create an Outlayer layout class\n  var Masonry = Outlayer.create('masonry'); // isFitWidth -> fitWidth\n\n  Masonry.compatOptions.fitWidth = 'isFitWidth';\n  var proto = Masonry.prototype;\n\n  proto._resetLayout = function () {\n    this.getSize();\n\n    this._getMeasurement('columnWidth', 'outerWidth');\n\n    this._getMeasurement('gutter', 'outerWidth');\n\n    this.measureColumns(); // reset column Y\n\n    this.colYs = [];\n\n    for (var i = 0; i < this.cols; i++) {\n      this.colYs.push(0);\n    }\n\n    this.maxY = 0;\n    this.horizontalColIndex = 0;\n  };\n\n  proto.measureColumns = function () {\n    this.getContainerWidth(); // if columnWidth is 0, default to outerWidth of first item\n\n    if (!this.columnWidth) {\n      var firstItem = this.items[0];\n      var firstItemElem = firstItem && firstItem.element; // columnWidth fall back to item of first element\n\n      this.columnWidth = firstItemElem && getSize(firstItemElem).outerWidth || // if first elem has no width, default to size of container\n      this.containerWidth;\n    }\n\n    var columnWidth = this.columnWidth += this.gutter; // calculate columns\n\n    var containerWidth = this.containerWidth + this.gutter;\n    var cols = containerWidth / columnWidth; // fix rounding errors, typically with gutters\n\n    var excess = columnWidth - containerWidth % columnWidth; // if overshoot is less than a pixel, round up, otherwise floor it\n\n    var mathMethod = excess && excess < 1 ? 'round' : 'floor';\n    cols = Math[mathMethod](cols);\n    this.cols = Math.max(cols, 1);\n  };\n\n  proto.getContainerWidth = function () {\n    // container is parent if fit width\n    var isFitWidth = this._getOption('fitWidth');\n\n    var container = isFitWidth ? this.element.parentNode : this.element; // check that this.size and size are there\n    // IE8 triggers resize on body size change, so they might not be\n\n    var size = getSize(container);\n    this.containerWidth = size && size.innerWidth;\n  };\n\n  proto._getItemLayoutPosition = function (item) {\n    item.getSize(); // how many columns does this brick span\n\n    var remainder = item.size.outerWidth % this.columnWidth;\n    var mathMethod = remainder && remainder < 1 ? 'round' : 'ceil'; // round if off by 1 pixel, otherwise use ceil\n\n    var colSpan = Math[mathMethod](item.size.outerWidth / this.columnWidth);\n    colSpan = Math.min(colSpan, this.cols); // use horizontal or top column position\n\n    var colPosMethod = this.options.horizontalOrder ? '_getHorizontalColPosition' : '_getTopColPosition';\n    var colPosition = this[colPosMethod](colSpan, item); // position the brick\n\n    var position = {\n      x: this.columnWidth * colPosition.col,\n      y: colPosition.y\n    }; // apply setHeight to necessary columns\n\n    var setHeight = colPosition.y + item.size.outerHeight;\n    var setMax = colSpan + colPosition.col;\n\n    for (var i = colPosition.col; i < setMax; i++) {\n      this.colYs[i] = setHeight;\n    }\n\n    return position;\n  };\n\n  proto._getTopColPosition = function (colSpan) {\n    var colGroup = this._getTopColGroup(colSpan); // get the minimum Y value from the columns\n\n\n    var minimumY = Math.min.apply(Math, colGroup);\n    return {\n      col: colGroup.indexOf(minimumY),\n      y: minimumY\n    };\n  };\n  /**\n   * @param {Number} colSpan - number of columns the element spans\n   * @returns {Array} colGroup\n   */\n\n\n  proto._getTopColGroup = function (colSpan) {\n    if (colSpan < 2) {\n      // if brick spans only one column, use all the column Ys\n      return this.colYs;\n    }\n\n    var colGroup = []; // how many different places could this brick fit horizontally\n\n    var groupCount = this.cols + 1 - colSpan; // for each group potential horizontal position\n\n    for (var i = 0; i < groupCount; i++) {\n      colGroup[i] = this._getColGroupY(i, colSpan);\n    }\n\n    return colGroup;\n  };\n\n  proto._getColGroupY = function (col, colSpan) {\n    if (colSpan < 2) {\n      return this.colYs[col];\n    } // make an array of colY values for that one group\n\n\n    var groupColYs = this.colYs.slice(col, col + colSpan); // and get the max value of the array\n\n    return Math.max.apply(Math, groupColYs);\n  }; // get column position based on horizontal index. #873\n\n\n  proto._getHorizontalColPosition = function (colSpan, item) {\n    var col = this.horizontalColIndex % this.cols;\n    var isOver = colSpan > 1 && col + colSpan > this.cols; // shift to next row if item can't fit on current row\n\n    col = isOver ? 0 : col; // don't let zero-size items take up space\n\n    var hasSize = item.size.outerWidth && item.size.outerHeight;\n    this.horizontalColIndex = hasSize ? col + colSpan : this.horizontalColIndex;\n    return {\n      col: col,\n      y: this._getColGroupY(col, colSpan)\n    };\n  };\n\n  proto._manageStamp = function (stamp) {\n    var stampSize = getSize(stamp);\n\n    var offset = this._getElementOffset(stamp); // get the columns that this stamp affects\n\n\n    var isOriginLeft = this._getOption('originLeft');\n\n    var firstX = isOriginLeft ? offset.left : offset.right;\n    var lastX = firstX + stampSize.outerWidth;\n    var firstCol = Math.floor(firstX / this.columnWidth);\n    firstCol = Math.max(0, firstCol);\n    var lastCol = Math.floor(lastX / this.columnWidth); // lastCol should not go over if multiple of columnWidth #425\n\n    lastCol -= lastX % this.columnWidth ? 0 : 1;\n    lastCol = Math.min(this.cols - 1, lastCol); // set colYs to bottom of the stamp\n\n    var isOriginTop = this._getOption('originTop');\n\n    var stampMaxY = (isOriginTop ? offset.top : offset.bottom) + stampSize.outerHeight;\n\n    for (var i = firstCol; i <= lastCol; i++) {\n      this.colYs[i] = Math.max(stampMaxY, this.colYs[i]);\n    }\n  };\n\n  proto._getContainerSize = function () {\n    this.maxY = Math.max.apply(Math, this.colYs);\n    var size = {\n      height: this.maxY\n    };\n\n    if (this._getOption('fitWidth')) {\n      size.width = this._getContainerFitWidth();\n    }\n\n    return size;\n  };\n\n  proto._getContainerFitWidth = function () {\n    var unusedCols = 0; // count unused columns\n\n    var i = this.cols;\n\n    while (--i) {\n      if (this.colYs[i] !== 0) {\n        break;\n      }\n\n      unusedCols++;\n    } // fit container to columns that have been used\n\n\n    return (this.cols - unusedCols) * this.columnWidth - this.gutter;\n  };\n\n  proto.needsResizeLayout = function () {\n    var previousWidth = this.containerWidth;\n    this.getContainerWidth();\n    return previousWidth != this.containerWidth;\n  };\n\n  return Masonry;\n});\n/*!\n * Masonry layout mode\n * sub-classes Masonry\n * https://masonry.desandro.com\n */\n\n\n(function (window, factory) {\n  // universal module definition\n\n  /* jshint strict: false */\n\n  /*globals define, module, require */\n  if (true) {\n    // AMD\n    !(__WEBPACK_LOCAL_MODULE_10__array = [__WEBPACK_LOCAL_MODULE_8__, __WEBPACK_LOCAL_MODULE_9__], __WEBPACK_LOCAL_MODULE_10__factory = (factory),\n\t\t(typeof __WEBPACK_LOCAL_MODULE_10__factory === 'function' ?\n\t\t\t((__WEBPACK_LOCAL_MODULE_10__ = __WEBPACK_LOCAL_MODULE_10__factory.apply(__WEBPACK_LOCAL_MODULE_10__exports = {}, __WEBPACK_LOCAL_MODULE_10__array)), __WEBPACK_LOCAL_MODULE_10__ === undefined && (__WEBPACK_LOCAL_MODULE_10__ = __WEBPACK_LOCAL_MODULE_10__exports)) :\n\t\t\t(__WEBPACK_LOCAL_MODULE_10__ = __WEBPACK_LOCAL_MODULE_10__factory)\n\t\t));\n  } else {}\n})(window, function factory(LayoutMode, Masonry) {\n  'use strict'; // -------------------------- masonryDefinition -------------------------- //\n  // create an Outlayer layout class\n\n  var MasonryMode = LayoutMode.create('masonry');\n  var proto = MasonryMode.prototype;\n  var keepModeMethods = {\n    _getElementOffset: true,\n    layout: true,\n    _getMeasurement: true\n  }; // inherit Masonry prototype\n\n  for (var method in Masonry.prototype) {\n    // do not inherit mode methods\n    if (!keepModeMethods[method]) {\n      proto[method] = Masonry.prototype[method];\n    }\n  }\n\n  var measureColumns = proto.measureColumns;\n\n  proto.measureColumns = function () {\n    // set items, used if measuring first item\n    this.items = this.isotope.filteredItems;\n    measureColumns.call(this);\n  }; // point to mode options for fitWidth\n\n\n  var _getOption = proto._getOption;\n\n  proto._getOption = function (option) {\n    if (option == 'fitWidth') {\n      return this.options.isFitWidth !== undefined ? this.options.isFitWidth : this.options.fitWidth;\n    }\n\n    return _getOption.apply(this.isotope, arguments);\n  };\n\n  return MasonryMode;\n});\n/**\n * fitRows layout mode\n */\n\n\n(function (window, factory) {\n  // universal module definition\n\n  /* jshint strict: false */\n\n  /*globals define, module, require */\n  if (true) {\n    // AMD\n    !(__WEBPACK_LOCAL_MODULE_11__array = [__WEBPACK_LOCAL_MODULE_8__], __WEBPACK_LOCAL_MODULE_11__factory = (factory),\n\t\t(typeof __WEBPACK_LOCAL_MODULE_11__factory === 'function' ?\n\t\t\t((__WEBPACK_LOCAL_MODULE_11__ = __WEBPACK_LOCAL_MODULE_11__factory.apply(__WEBPACK_LOCAL_MODULE_11__exports = {}, __WEBPACK_LOCAL_MODULE_11__array)), __WEBPACK_LOCAL_MODULE_11__ === undefined && (__WEBPACK_LOCAL_MODULE_11__ = __WEBPACK_LOCAL_MODULE_11__exports)) :\n\t\t\t(__WEBPACK_LOCAL_MODULE_11__ = __WEBPACK_LOCAL_MODULE_11__factory)\n\t\t));\n  } else {}\n})(window, function factory(LayoutMode) {\n  'use strict';\n\n  var FitRows = LayoutMode.create('fitRows');\n  var proto = FitRows.prototype;\n\n  proto._resetLayout = function () {\n    this.x = 0;\n    this.y = 0;\n    this.maxY = 0;\n\n    this._getMeasurement('gutter', 'outerWidth');\n  };\n\n  proto._getItemLayoutPosition = function (item) {\n    item.getSize();\n    var itemWidth = item.size.outerWidth + this.gutter; // if this element cannot fit in the current row\n\n    var containerWidth = this.isotope.size.innerWidth + this.gutter;\n\n    if (this.x !== 0 && itemWidth + this.x > containerWidth) {\n      this.x = 0;\n      this.y = this.maxY;\n    }\n\n    var position = {\n      x: this.x,\n      y: this.y\n    };\n    this.maxY = Math.max(this.maxY, this.y + item.size.outerHeight);\n    this.x += itemWidth;\n    return position;\n  };\n\n  proto._getContainerSize = function () {\n    return {\n      height: this.maxY\n    };\n  };\n\n  return FitRows;\n});\n/**\n * vertical layout mode\n */\n\n\n(function (window, factory) {\n  // universal module definition\n\n  /* jshint strict: false */\n\n  /*globals define, module, require */\n  if (true) {\n    // AMD\n    !(__WEBPACK_LOCAL_MODULE_12__array = [__WEBPACK_LOCAL_MODULE_8__], __WEBPACK_LOCAL_MODULE_12__factory = (factory),\n\t\t(typeof __WEBPACK_LOCAL_MODULE_12__factory === 'function' ?\n\t\t\t((__WEBPACK_LOCAL_MODULE_12__ = __WEBPACK_LOCAL_MODULE_12__factory.apply(__WEBPACK_LOCAL_MODULE_12__exports = {}, __WEBPACK_LOCAL_MODULE_12__array)), __WEBPACK_LOCAL_MODULE_12__ === undefined && (__WEBPACK_LOCAL_MODULE_12__ = __WEBPACK_LOCAL_MODULE_12__exports)) :\n\t\t\t(__WEBPACK_LOCAL_MODULE_12__ = __WEBPACK_LOCAL_MODULE_12__factory)\n\t\t));\n  } else {}\n})(window, function factory(LayoutMode) {\n  'use strict';\n\n  var Vertical = LayoutMode.create('vertical', {\n    horizontalAlignment: 0\n  });\n  var proto = Vertical.prototype;\n\n  proto._resetLayout = function () {\n    this.y = 0;\n  };\n\n  proto._getItemLayoutPosition = function (item) {\n    item.getSize();\n    var x = (this.isotope.size.innerWidth - item.size.outerWidth) * this.options.horizontalAlignment;\n    var y = this.y;\n    this.y += item.size.outerHeight;\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  proto._getContainerSize = function () {\n    return {\n      height: this.y\n    };\n  };\n\n  return Vertical;\n});\n/*!\n * Isotope v3.0.6\n *\n * Licensed GPLv3 for open source use\n * or Isotope Commercial License for commercial use\n *\n * https://isotope.metafizzy.co\n * Copyright 2010-2018 Metafizzy\n */\n\n\n(function (window, factory) {\n  // universal module definition\n\n  /* jshint strict: false */\n\n  /*globals define, module, require */\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_6__, __WEBPACK_LOCAL_MODULE_2__, __WEBPACK_LOCAL_MODULE_3__, __WEBPACK_LOCAL_MODULE_4__, __WEBPACK_LOCAL_MODULE_7__, __WEBPACK_LOCAL_MODULE_8__, // include default layout modes\n    __WEBPACK_LOCAL_MODULE_10__, __WEBPACK_LOCAL_MODULE_11__, __WEBPACK_LOCAL_MODULE_12__], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Outlayer, getSize, matchesSelector, utils, Item, LayoutMode) {\n      return factory(window, Outlayer, getSize, matchesSelector, utils, Item, LayoutMode);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function factory(window, Outlayer, getSize, matchesSelector, utils, Item, LayoutMode) {\n  // -------------------------- vars -------------------------- //\n  var jQuery = window.jQuery; // -------------------------- helpers -------------------------- //\n\n  var trim = String.prototype.trim ? function (str) {\n    return str.trim();\n  } : function (str) {\n    return str.replace(/^\\s+|\\s+$/g, '');\n  }; // -------------------------- isotopeDefinition -------------------------- //\n  // create an Outlayer layout class\n\n  var Isotope = Outlayer.create('isotope', {\n    layoutMode: 'masonry',\n    isJQueryFiltering: true,\n    sortAscending: true\n  });\n  Isotope.Item = Item;\n  Isotope.LayoutMode = LayoutMode;\n  var proto = Isotope.prototype;\n\n  proto._create = function () {\n    this.itemGUID = 0; // functions that sort items\n\n    this._sorters = {};\n\n    this._getSorters(); // call super\n\n\n    Outlayer.prototype._create.call(this); // create layout modes\n\n\n    this.modes = {}; // start filteredItems with all items\n\n    this.filteredItems = this.items; // keep of track of sortBys\n\n    this.sortHistory = ['original-order']; // create from registered layout modes\n\n    for (var name in LayoutMode.modes) {\n      this._initLayoutMode(name);\n    }\n  };\n\n  proto.reloadItems = function () {\n    // reset item ID counter\n    this.itemGUID = 0; // call super\n\n    Outlayer.prototype.reloadItems.call(this);\n  };\n\n  proto._itemize = function () {\n    var items = Outlayer.prototype._itemize.apply(this, arguments); // assign ID for original-order\n\n\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n      item.id = this.itemGUID++;\n    }\n\n    this._updateItemsSortData(items);\n\n    return items;\n  }; // -------------------------- layout -------------------------- //\n\n\n  proto._initLayoutMode = function (name) {\n    var Mode = LayoutMode.modes[name]; // set mode options\n    // HACK extend initial options, back-fill in default options\n\n    var initialOpts = this.options[name] || {};\n    this.options[name] = Mode.options ? utils.extend(Mode.options, initialOpts) : initialOpts; // init layout mode instance\n\n    this.modes[name] = new Mode(this);\n  };\n\n  proto.layout = function () {\n    // if first time doing layout, do all magic\n    if (!this._isLayoutInited && this._getOption('initLayout')) {\n      this.arrange();\n      return;\n    }\n\n    this._layout();\n  }; // private method to be used in layout() & magic()\n\n\n  proto._layout = function () {\n    // don't animate first layout\n    var isInstant = this._getIsInstant(); // layout flow\n\n\n    this._resetLayout();\n\n    this._manageStamps();\n\n    this.layoutItems(this.filteredItems, isInstant); // flag for initalized\n\n    this._isLayoutInited = true;\n  }; // filter + sort + layout\n\n\n  proto.arrange = function (opts) {\n    // set any options pass\n    this.option(opts);\n\n    this._getIsInstant(); // filter, sort, and layout\n    // filter\n\n\n    var filtered = this._filter(this.items);\n\n    this.filteredItems = filtered.matches;\n\n    this._bindArrangeComplete();\n\n    if (this._isInstant) {\n      this._noTransition(this._hideReveal, [filtered]);\n    } else {\n      this._hideReveal(filtered);\n    }\n\n    this._sort();\n\n    this._layout();\n  }; // alias to _init for main plugin method\n\n\n  proto._init = proto.arrange;\n\n  proto._hideReveal = function (filtered) {\n    this.reveal(filtered.needReveal);\n    this.hide(filtered.needHide);\n  }; // HACK\n  // Don't animate/transition first layout\n  // Or don't animate/transition other layouts\n\n\n  proto._getIsInstant = function () {\n    var isLayoutInstant = this._getOption('layoutInstant');\n\n    var isInstant = isLayoutInstant !== undefined ? isLayoutInstant : !this._isLayoutInited;\n    this._isInstant = isInstant;\n    return isInstant;\n  }; // listen for layoutComplete, hideComplete and revealComplete\n  // to trigger arrangeComplete\n\n\n  proto._bindArrangeComplete = function () {\n    // listen for 3 events to trigger arrangeComplete\n    var isLayoutComplete, isHideComplete, isRevealComplete;\n\n    var _this = this;\n\n    function arrangeParallelCallback() {\n      if (isLayoutComplete && isHideComplete && isRevealComplete) {\n        _this.dispatchEvent('arrangeComplete', null, [_this.filteredItems]);\n      }\n    }\n\n    this.once('layoutComplete', function () {\n      isLayoutComplete = true;\n      arrangeParallelCallback();\n    });\n    this.once('hideComplete', function () {\n      isHideComplete = true;\n      arrangeParallelCallback();\n    });\n    this.once('revealComplete', function () {\n      isRevealComplete = true;\n      arrangeParallelCallback();\n    });\n  }; // -------------------------- filter -------------------------- //\n\n\n  proto._filter = function (items) {\n    var filter = this.options.filter;\n    filter = filter || '*';\n    var matches = [];\n    var hiddenMatched = [];\n    var visibleUnmatched = [];\n\n    var test = this._getFilterTest(filter); // test each item\n\n\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n\n      if (item.isIgnored) {\n        continue;\n      } // add item to either matched or unmatched group\n\n\n      var isMatched = test(item); // item.isFilterMatched = isMatched;\n      // add to matches if its a match\n\n      if (isMatched) {\n        matches.push(item);\n      } // add to additional group if item needs to be hidden or revealed\n\n\n      if (isMatched && item.isHidden) {\n        hiddenMatched.push(item);\n      } else if (!isMatched && !item.isHidden) {\n        visibleUnmatched.push(item);\n      }\n    } // return collections of items to be manipulated\n\n\n    return {\n      matches: matches,\n      needReveal: hiddenMatched,\n      needHide: visibleUnmatched\n    };\n  }; // get a jQuery, function, or a matchesSelector test given the filter\n\n\n  proto._getFilterTest = function (filter) {\n    if (jQuery && this.options.isJQueryFiltering) {\n      // use jQuery\n      return function (item) {\n        return jQuery(item.element).is(filter);\n      };\n    }\n\n    if (typeof filter == 'function') {\n      // use filter as function\n      return function (item) {\n        return filter(item.element);\n      };\n    } // default, use filter as selector string\n\n\n    return function (item) {\n      return matchesSelector(item.element, filter);\n    };\n  }; // -------------------------- sorting -------------------------- //\n\n  /**\n   * @params {Array} elems\n   * @public\n   */\n\n\n  proto.updateSortData = function (elems) {\n    // get items\n    var items;\n\n    if (elems) {\n      elems = utils.makeArray(elems);\n      items = this.getItems(elems);\n    } else {\n      // update all items if no elems provided\n      items = this.items;\n    }\n\n    this._getSorters();\n\n    this._updateItemsSortData(items);\n  };\n\n  proto._getSorters = function () {\n    var getSortData = this.options.getSortData;\n\n    for (var key in getSortData) {\n      var sorter = getSortData[key];\n      this._sorters[key] = mungeSorter(sorter);\n    }\n  };\n  /**\n   * @params {Array} items - of Isotope.Items\n   * @private\n   */\n\n\n  proto._updateItemsSortData = function (items) {\n    // do not update if no items\n    var len = items && items.length;\n\n    for (var i = 0; len && i < len; i++) {\n      var item = items[i];\n      item.updateSortData();\n    }\n  }; // ----- munge sorter ----- //\n  // encapsulate this, as we just need mungeSorter\n  // other functions in here are just for munging\n\n\n  var mungeSorter = function () {\n    // add a magic layer to sorters for convienent shorthands\n    // `.foo-bar` will use the text of .foo-bar querySelector\n    // `[foo-bar]` will use attribute\n    // you can also add parser\n    // `.foo-bar parseInt` will parse that as a number\n    function mungeSorter(sorter) {\n      // if not a string, return function or whatever it is\n      if (typeof sorter != 'string') {\n        return sorter;\n      } // parse the sorter string\n\n\n      var args = trim(sorter).split(' ');\n      var query = args[0]; // check if query looks like [an-attribute]\n\n      var attrMatch = query.match(/^\\[(.+)\\]$/);\n      var attr = attrMatch && attrMatch[1];\n      var getValue = getValueGetter(attr, query); // use second argument as a parser\n\n      var parser = Isotope.sortDataParsers[args[1]]; // parse the value, if there was a parser\n\n      sorter = parser ? function (elem) {\n        return elem && parser(getValue(elem));\n      } : // otherwise just return value\n      function (elem) {\n        return elem && getValue(elem);\n      };\n      return sorter;\n    } // get an attribute getter, or get text of the querySelector\n\n\n    function getValueGetter(attr, query) {\n      // if query looks like [foo-bar], get attribute\n      if (attr) {\n        return function getAttribute(elem) {\n          return elem.getAttribute(attr);\n        };\n      } // otherwise, assume its a querySelector, and get its text\n\n\n      return function getChildText(elem) {\n        var child = elem.querySelector(query);\n        return child && child.textContent;\n      };\n    }\n\n    return mungeSorter;\n  }(); // parsers used in getSortData shortcut strings\n\n\n  Isotope.sortDataParsers = {\n    'parseInt': function (_parseInt) {\n      function parseInt(_x) {\n        return _parseInt.apply(this, arguments);\n      }\n\n      parseInt.toString = function () {\n        return _parseInt.toString();\n      };\n\n      return parseInt;\n    }(function (val) {\n      return parseInt(val, 10);\n    }),\n    'parseFloat': function (_parseFloat) {\n      function parseFloat(_x2) {\n        return _parseFloat.apply(this, arguments);\n      }\n\n      parseFloat.toString = function () {\n        return _parseFloat.toString();\n      };\n\n      return parseFloat;\n    }(function (val) {\n      return parseFloat(val);\n    })\n  }; // ----- sort method ----- //\n  // sort filteredItem order\n\n  proto._sort = function () {\n    if (!this.options.sortBy) {\n      return;\n    } // keep track of sortBy History\n\n\n    var sortBys = utils.makeArray(this.options.sortBy);\n\n    if (!this._getIsSameSortBy(sortBys)) {\n      // concat all sortBy and sortHistory, add to front, oldest goes in last\n      this.sortHistory = sortBys.concat(this.sortHistory);\n    } // sort magic\n\n\n    var itemSorter = getItemSorter(this.sortHistory, this.options.sortAscending);\n    this.filteredItems.sort(itemSorter);\n  }; // check if sortBys is same as start of sortHistory\n\n\n  proto._getIsSameSortBy = function (sortBys) {\n    for (var i = 0; i < sortBys.length; i++) {\n      if (sortBys[i] != this.sortHistory[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }; // returns a function used for sorting\n\n\n  function getItemSorter(sortBys, sortAsc) {\n    return function sorter(itemA, itemB) {\n      // cycle through all sortKeys\n      for (var i = 0; i < sortBys.length; i++) {\n        var sortBy = sortBys[i];\n        var a = itemA.sortData[sortBy];\n        var b = itemB.sortData[sortBy];\n\n        if (a > b || a < b) {\n          // if sortAsc is an object, use the value given the sortBy key\n          var isAscending = sortAsc[sortBy] !== undefined ? sortAsc[sortBy] : sortAsc;\n          var direction = isAscending ? 1 : -1;\n          return (a > b ? 1 : -1) * direction;\n        }\n      }\n\n      return 0;\n    };\n  } // -------------------------- methods -------------------------- //\n  // get layout mode\n\n\n  proto._mode = function () {\n    var layoutMode = this.options.layoutMode;\n    var mode = this.modes[layoutMode];\n\n    if (!mode) {\n      // TODO console.error\n      throw new Error('No layout mode: ' + layoutMode);\n    } // HACK sync mode's options\n    // any options set after init for layout mode need to be synced\n\n\n    mode.options = this.options[layoutMode];\n    return mode;\n  };\n\n  proto._resetLayout = function () {\n    // trigger original reset layout\n    Outlayer.prototype._resetLayout.call(this);\n\n    this._mode()._resetLayout();\n  };\n\n  proto._getItemLayoutPosition = function (item) {\n    return this._mode()._getItemLayoutPosition(item);\n  };\n\n  proto._manageStamp = function (stamp) {\n    this._mode()._manageStamp(stamp);\n  };\n\n  proto._getContainerSize = function () {\n    return this._mode()._getContainerSize();\n  };\n\n  proto.needsResizeLayout = function () {\n    return this._mode().needsResizeLayout();\n  }; // -------------------------- adding & removing -------------------------- //\n  // HEADS UP overwrites default Outlayer appended\n\n\n  proto.appended = function (elems) {\n    var items = this.addItems(elems);\n\n    if (!items.length) {\n      return;\n    } // filter, layout, reveal new items\n\n\n    var filteredItems = this._filterRevealAdded(items); // add to filteredItems\n\n\n    this.filteredItems = this.filteredItems.concat(filteredItems);\n  }; // HEADS UP overwrites default Outlayer prepended\n\n\n  proto.prepended = function (elems) {\n    var items = this._itemize(elems);\n\n    if (!items.length) {\n      return;\n    } // start new layout\n\n\n    this._resetLayout();\n\n    this._manageStamps(); // filter, layout, reveal new items\n\n\n    var filteredItems = this._filterRevealAdded(items); // layout previous items\n\n\n    this.layoutItems(this.filteredItems); // add to items and filteredItems\n\n    this.filteredItems = filteredItems.concat(this.filteredItems);\n    this.items = items.concat(this.items);\n  };\n\n  proto._filterRevealAdded = function (items) {\n    var filtered = this._filter(items);\n\n    this.hide(filtered.needHide); // reveal all new items\n\n    this.reveal(filtered.matches); // layout new items, no transition\n\n    this.layoutItems(filtered.matches, true);\n    return filtered.matches;\n  };\n  /**\n   * Filter, sort, and layout newly-appended item elements\n   * @param {Array or NodeList or Element} elems\n   */\n\n\n  proto.insert = function (elems) {\n    var items = this.addItems(elems);\n\n    if (!items.length) {\n      return;\n    } // append item elements\n\n\n    var i, item;\n    var len = items.length;\n\n    for (i = 0; i < len; i++) {\n      item = items[i];\n      this.element.appendChild(item.element);\n    } // filter new stuff\n\n\n    var filteredInsertItems = this._filter(items).matches; // set flag\n\n\n    for (i = 0; i < len; i++) {\n      items[i].isLayoutInstant = true;\n    }\n\n    this.arrange(); // reset flag\n\n    for (i = 0; i < len; i++) {\n      delete items[i].isLayoutInstant;\n    }\n\n    this.reveal(filteredInsertItems);\n  };\n\n  var _remove = proto.remove;\n\n  proto.remove = function (elems) {\n    elems = utils.makeArray(elems);\n    var removeItems = this.getItems(elems); // do regular thing\n\n    _remove.call(this, elems); // bail if no items to remove\n\n\n    var len = removeItems && removeItems.length; // remove elems from filteredItems\n\n    for (var i = 0; len && i < len; i++) {\n      var item = removeItems[i]; // remove item from collection\n\n      utils.removeFrom(this.filteredItems, item);\n    }\n  };\n\n  proto.shuffle = function () {\n    // update random sortData\n    for (var i = 0; i < this.items.length; i++) {\n      var item = this.items[i];\n      item.sortData.random = Math.random();\n    }\n\n    this.options.sortBy = 'random';\n\n    this._sort();\n\n    this._layout();\n  };\n  /**\n   * trigger fn without transition\n   * kind of hacky to have this in the first place\n   * @param {Function} fn\n   * @param {Array} args\n   * @returns ret\n   * @private\n   */\n\n\n  proto._noTransition = function (fn, args) {\n    // save transitionDuration before disabling\n    var transitionDuration = this.options.transitionDuration; // disable transition\n\n    this.options.transitionDuration = 0; // do it\n\n    var returnValue = fn.apply(this, args); // re-enable transition for reveal\n\n    this.options.transitionDuration = transitionDuration;\n    return returnValue;\n  }; // ----- helper methods ----- //\n\n  /**\n   * getter method for getting filtered item elements\n   * @returns {Array} elems - collection of item elements\n   */\n\n\n  proto.getFilteredItemElements = function () {\n    return this.filteredItems.map(function (item) {\n      return item.element;\n    });\n  }; // -----  ----- //\n\n\n  return Isotope;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2ZpZFNhbmF0Ly4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9pc290b3BlLmpzP2M0OGEiXSwibmFtZXMiOlsid2luZG93IiwiZmFjdG9yeSIsImRlZmluZSIsImpRdWVyeSIsImFycmF5U2xpY2UiLCJBcnJheSIsInByb3RvdHlwZSIsInNsaWNlIiwiY29uc29sZSIsImxvZ0Vycm9yIiwibWVzc2FnZSIsImVycm9yIiwialF1ZXJ5QnJpZGdldCIsIm5hbWVzcGFjZSIsIlBsdWdpbkNsYXNzIiwiJCIsIm9wdGlvbiIsIm9wdHMiLCJpc1BsYWluT2JqZWN0Iiwib3B0aW9ucyIsImV4dGVuZCIsImZuIiwiYXJnMCIsImFyZ3MiLCJjYWxsIiwiYXJndW1lbnRzIiwibWV0aG9kQ2FsbCIsInBsYWluQ2FsbCIsIiRlbGVtcyIsIm1ldGhvZE5hbWUiLCJyZXR1cm5WYWx1ZSIsInBsdWdpbk1ldGhvZFN0ciIsImVhY2giLCJpIiwiZWxlbSIsImluc3RhbmNlIiwiZGF0YSIsIm1ldGhvZCIsImNoYXJBdCIsInZhbHVlIiwiYXBwbHkiLCJ1bmRlZmluZWQiLCJfaW5pdCIsInVwZGF0ZUpRdWVyeSIsImJyaWRnZXQiLCJnbG9iYWwiLCJFdkVtaXR0ZXIiLCJwcm90byIsIm9uIiwiZXZlbnROYW1lIiwibGlzdGVuZXIiLCJldmVudHMiLCJfZXZlbnRzIiwibGlzdGVuZXJzIiwiaW5kZXhPZiIsInB1c2giLCJvbmNlIiwib25jZUV2ZW50cyIsIl9vbmNlRXZlbnRzIiwib25jZUxpc3RlbmVycyIsIm9mZiIsImxlbmd0aCIsImluZGV4Iiwic3BsaWNlIiwiZW1pdEV2ZW50IiwiaXNPbmNlIiwiYWxsT2ZmIiwiZ2V0U3R5bGVTaXplIiwibnVtIiwicGFyc2VGbG9hdCIsImlzVmFsaWQiLCJpc05hTiIsIm5vb3AiLCJtZWFzdXJlbWVudHMiLCJtZWFzdXJlbWVudHNMZW5ndGgiLCJnZXRaZXJvU2l6ZSIsInNpemUiLCJ3aWR0aCIsImhlaWdodCIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsIm91dGVyV2lkdGgiLCJvdXRlckhlaWdodCIsIm1lYXN1cmVtZW50IiwiZ2V0U3R5bGUiLCJzdHlsZSIsImdldENvbXB1dGVkU3R5bGUiLCJpc1NldHVwIiwiaXNCb3hTaXplT3V0ZXIiLCJzZXR1cCIsImRpdiIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInBhZGRpbmciLCJib3JkZXJTdHlsZSIsImJvcmRlcldpZHRoIiwiYm94U2l6aW5nIiwiYm9keSIsImRvY3VtZW50RWxlbWVudCIsImFwcGVuZENoaWxkIiwiTWF0aCIsInJvdW5kIiwiZ2V0U2l6ZSIsInJlbW92ZUNoaWxkIiwicXVlcnlTZWxlY3RvciIsIm5vZGVUeXBlIiwiZGlzcGxheSIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiaXNCb3JkZXJCb3giLCJwYWRkaW5nV2lkdGgiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsInBhZGRpbmdIZWlnaHQiLCJwYWRkaW5nVG9wIiwicGFkZGluZ0JvdHRvbSIsIm1hcmdpbldpZHRoIiwibWFyZ2luTGVmdCIsIm1hcmdpblJpZ2h0IiwibWFyZ2luSGVpZ2h0IiwibWFyZ2luVG9wIiwibWFyZ2luQm90dG9tIiwiYm9yZGVyTGVmdFdpZHRoIiwiYm9yZGVyUmlnaHRXaWR0aCIsImJvcmRlckhlaWdodCIsImJvcmRlclRvcFdpZHRoIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJpc0JvcmRlckJveFNpemVPdXRlciIsInN0eWxlV2lkdGgiLCJzdHlsZUhlaWdodCIsIm1hdGNoZXNNZXRob2QiLCJFbGVtUHJvdG8iLCJFbGVtZW50IiwibWF0Y2hlcyIsIm1hdGNoZXNTZWxlY3RvciIsInByZWZpeGVzIiwicHJlZml4Iiwic2VsZWN0b3IiLCJ1dGlscyIsImEiLCJiIiwicHJvcCIsIm1vZHVsbyIsIm1ha2VBcnJheSIsIm9iaiIsImlzQXJyYXkiLCJpc0FycmF5TGlrZSIsInJlbW92ZUZyb20iLCJhcnkiLCJnZXRQYXJlbnQiLCJwYXJlbnROb2RlIiwiZ2V0UXVlcnlFbGVtZW50IiwiaGFuZGxlRXZlbnQiLCJldmVudCIsInR5cGUiLCJmaWx0ZXJGaW5kRWxlbWVudHMiLCJlbGVtcyIsImZmRWxlbXMiLCJmb3JFYWNoIiwiSFRNTEVsZW1lbnQiLCJjaGlsZEVsZW1zIiwicXVlcnlTZWxlY3RvckFsbCIsImRlYm91bmNlTWV0aG9kIiwiX2NsYXNzIiwidGhyZXNob2xkIiwidGltZW91dE5hbWUiLCJ0aW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiX3RoaXMiLCJzZXRUaW1lb3V0IiwiZG9jUmVhZHkiLCJjYWxsYmFjayIsInJlYWR5U3RhdGUiLCJhZGRFdmVudExpc3RlbmVyIiwidG9EYXNoZWQiLCJzdHIiLCJyZXBsYWNlIiwibWF0Y2giLCIkMSIsIiQyIiwidG9Mb3dlckNhc2UiLCJodG1sSW5pdCIsIldpZGdldENsYXNzIiwiZGFzaGVkTmFtZXNwYWNlIiwiZGF0YUF0dHIiLCJkYXRhQXR0ckVsZW1zIiwianNEYXNoRWxlbXMiLCJjb25jYXQiLCJkYXRhT3B0aW9uc0F0dHIiLCJhdHRyIiwiZ2V0QXR0cmlidXRlIiwiSlNPTiIsInBhcnNlIiwiY2xhc3NOYW1lIiwiaXNFbXB0eU9iaiIsImRvY0VsZW1TdHlsZSIsInRyYW5zaXRpb25Qcm9wZXJ0eSIsInRyYW5zaXRpb24iLCJ0cmFuc2Zvcm1Qcm9wZXJ0eSIsInRyYW5zZm9ybSIsInRyYW5zaXRpb25FbmRFdmVudCIsIldlYmtpdFRyYW5zaXRpb24iLCJ2ZW5kb3JQcm9wZXJ0aWVzIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwidHJhbnNpdGlvbkRlbGF5IiwiSXRlbSIsImVsZW1lbnQiLCJsYXlvdXQiLCJwb3NpdGlvbiIsIngiLCJ5IiwiX2NyZWF0ZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiX3RyYW5zbiIsImluZ1Byb3BlcnRpZXMiLCJjbGVhbiIsIm9uRW5kIiwiY3NzIiwiZWxlbVN0eWxlIiwic3VwcG9ydGVkUHJvcCIsImdldFBvc2l0aW9uIiwiaXNPcmlnaW5MZWZ0IiwiX2dldE9wdGlvbiIsImlzT3JpZ2luVG9wIiwieFZhbHVlIiwieVZhbHVlIiwibGF5b3V0U2l6ZSIsImxheW91dFBvc2l0aW9uIiwieFBhZGRpbmciLCJ4UHJvcGVydHkiLCJ4UmVzZXRQcm9wZXJ0eSIsImdldFhWYWx1ZSIsInlQYWRkaW5nIiwieVByb3BlcnR5IiwieVJlc2V0UHJvcGVydHkiLCJnZXRZVmFsdWUiLCJpc0hvcml6b250YWwiLCJwZXJjZW50UG9zaXRpb24iLCJfdHJhbnNpdGlvblRvIiwiY3VyWCIsImN1clkiLCJkaWROb3RNb3ZlIiwic2V0UG9zaXRpb24iLCJpc1RyYW5zaXRpb25pbmciLCJ0cmFuc1giLCJ0cmFuc1kiLCJ0cmFuc2l0aW9uU3R5bGUiLCJnZXRUcmFuc2xhdGUiLCJ0byIsIm9uVHJhbnNpdGlvbkVuZCIsImlzQ2xlYW5pbmciLCJnb1RvIiwibW92ZVRvIiwiX25vblRyYW5zaXRpb24iLCJfcmVtb3ZlU3R5bGVzIiwiX3RyYW5zaXRpb24iLCJmcm9tIiwiaCIsImVuYWJsZVRyYW5zaXRpb24iLCJ0b0Rhc2hlZEFsbCIsInRyYW5zaXRpb25Qcm9wcyIsImR1cmF0aW9uIiwic3RhZ2dlckRlbGF5Iiwib253ZWJraXRUcmFuc2l0aW9uRW5kIiwib250cmFuc2l0aW9uZW5kIiwib25vdHJhbnNpdGlvbmVuZCIsImRhc2hlZFZlbmRvclByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wZXJ0eU5hbWUiLCJkaXNhYmxlVHJhbnNpdGlvbiIsInJlbW92ZVRyYW5zaXRpb25TdHlsZXMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xlYW5TdHlsZSIsImNsZWFuVHJhbnNpdGlvblN0eWxlIiwic3RhZ2dlciIsImRlbGF5IiwicmVtb3ZlRWxlbSIsInJlbW92ZSIsImhpZGUiLCJyZXZlYWwiLCJpc0hpZGRlbiIsInRyYW5zaXRpb25FbmRQcm9wZXJ0eSIsImdldEhpZGVSZXZlYWxUcmFuc2l0aW9uRW5kUHJvcGVydHkiLCJvblJldmVhbFRyYW5zaXRpb25FbmQiLCJoaWRkZW5TdHlsZSIsInZpc2libGVTdHlsZSIsInN0eWxlUHJvcGVydHkiLCJvcHRpb25TdHlsZSIsIm9wYWNpdHkiLCJvbkhpZGVUcmFuc2l0aW9uRW5kIiwiZGVzdHJveSIsImxlZnQiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsIkdVSUQiLCJpbnN0YW5jZXMiLCJPdXRsYXllciIsInF1ZXJ5RWxlbWVudCIsIiRlbGVtZW50IiwiZGVmYXVsdHMiLCJpZCIsIm91dGxheWVyR1VJRCIsImlzSW5pdExheW91dCIsImNvbnRhaW5lclN0eWxlIiwiaW5pdExheW91dCIsIm9yaWdpbkxlZnQiLCJvcmlnaW5Ub3AiLCJyZXNpemUiLCJyZXNpemVDb250YWluZXIiLCJvbGRPcHRpb24iLCJjb21wYXRPcHRpb25zIiwiaG9yaXpvbnRhbCIsImxheW91dEluc3RhbnQiLCJyZWxvYWRJdGVtcyIsInN0YW1wcyIsInN0YW1wIiwiY2FuQmluZFJlc2l6ZSIsImJpbmRSZXNpemUiLCJpdGVtcyIsIl9pdGVtaXplIiwiY2hpbGRyZW4iLCJpdGVtRWxlbXMiLCJfZmlsdGVyRmluZEl0ZW1FbGVtZW50cyIsIml0ZW0iLCJpdGVtU2VsZWN0b3IiLCJnZXRJdGVtRWxlbWVudHMiLCJtYXAiLCJfcmVzZXRMYXlvdXQiLCJfbWFuYWdlU3RhbXBzIiwiaXNJbnN0YW50IiwiX2lzTGF5b3V0SW5pdGVkIiwibGF5b3V0SXRlbXMiLCJfZ2V0TWVhc3VyZW1lbnQiLCJfZ2V0SXRlbXNGb3JMYXlvdXQiLCJfbGF5b3V0SXRlbXMiLCJfcG9zdExheW91dCIsImZpbHRlciIsImlzSWdub3JlZCIsIl9lbWl0Q29tcGxldGVPbkl0ZW1zIiwicXVldWUiLCJfZ2V0SXRlbUxheW91dFBvc2l0aW9uIiwiaXNMYXlvdXRJbnN0YW50IiwiX3Byb2Nlc3NMYXlvdXRRdWV1ZSIsInVwZGF0ZVN0YWdnZXIiLCJfcG9zaXRpb25JdGVtIiwiZ2V0TWlsbGlzZWNvbmRzIiwiaXNSZXNpemluZ0NvbnRhaW5lciIsIl9nZXRDb250YWluZXJTaXplIiwiX3NldENvbnRhaW5lck1lYXN1cmUiLCJtZWFzdXJlIiwiaXNXaWR0aCIsImVsZW1TaXplIiwibWF4Iiwib25Db21wbGV0ZSIsImRpc3BhdGNoRXZlbnQiLCJjb3VudCIsImRvbmVDb3VudCIsInRpY2siLCJlbWl0QXJncyIsIiRldmVudCIsIkV2ZW50IiwidHJpZ2dlciIsImlnbm9yZSIsImdldEl0ZW0iLCJ1bmlnbm9yZSIsIl9maW5kIiwidW5zdGFtcCIsIl9nZXRCb3VuZGluZ1JlY3QiLCJfbWFuYWdlU3RhbXAiLCJib3VuZGluZ1JlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJfYm91bmRpbmdSZWN0IiwiX2dldEVsZW1lbnRPZmZzZXQiLCJ0aGlzUmVjdCIsIm9mZnNldCIsImlzUmVzaXplQm91bmQiLCJ1bmJpbmRSZXNpemUiLCJvbnJlc2l6ZSIsIm5lZWRzUmVzaXplTGF5b3V0IiwiaGFzU2l6ZXMiLCJhZGRJdGVtcyIsImFwcGVuZGVkIiwicHJlcGVuZGVkIiwicHJldmlvdXNJdGVtcyIsInJldmVhbEl0ZW1FbGVtZW50cyIsImdldEl0ZW1zIiwiaGlkZUl0ZW1FbGVtZW50cyIsInJlbW92ZUl0ZW1zIiwicmVtb3ZlRGF0YSIsIkxheW91dCIsInN1YmNsYXNzIiwiUGFyZW50IiwiU3ViQ2xhc3MiLCJtc1VuaXRzIiwibXMiLCJzIiwidGltZSIsInVuaXQiLCJtdWx0IiwiaXRlbUdVSUQiLCJzb3J0RGF0YSIsInVwZGF0ZVNvcnREYXRhIiwicmFuZG9tIiwiZ2V0U29ydERhdGEiLCJzb3J0ZXJzIiwiX3NvcnRlcnMiLCJrZXkiLCJzb3J0ZXIiLCJfZGVzdHJveSIsIkxheW91dE1vZGUiLCJpc290b3BlIiwiZmlsdGVyZWRJdGVtcyIsImZhY2FkZU1ldGhvZHMiLCJuZWVkc1ZlcnRpY2FsUmVzaXplTGF5b3V0IiwiZ2V0Q29sdW1uV2lkdGgiLCJnZXRTZWdtZW50U2l6ZSIsImdldFJvd0hlaWdodCIsInNlZ21lbnQiLCJzZWdtZW50TmFtZSIsIm91dGVyU2l6ZSIsImZpcnN0SXRlbVNpemUiLCJnZXRGaXJzdEl0ZW1TaXplIiwiZmlyc3RJdGVtIiwibW9kZXMiLCJNb2RlIiwiTWFzb25yeSIsImZpdFdpZHRoIiwibWVhc3VyZUNvbHVtbnMiLCJjb2xZcyIsImNvbHMiLCJtYXhZIiwiaG9yaXpvbnRhbENvbEluZGV4IiwiZ2V0Q29udGFpbmVyV2lkdGgiLCJjb2x1bW5XaWR0aCIsImZpcnN0SXRlbUVsZW0iLCJjb250YWluZXJXaWR0aCIsImd1dHRlciIsImV4Y2VzcyIsIm1hdGhNZXRob2QiLCJpc0ZpdFdpZHRoIiwiY29udGFpbmVyIiwicmVtYWluZGVyIiwiY29sU3BhbiIsIm1pbiIsImNvbFBvc01ldGhvZCIsImhvcml6b250YWxPcmRlciIsImNvbFBvc2l0aW9uIiwiY29sIiwic2V0SGVpZ2h0Iiwic2V0TWF4IiwiX2dldFRvcENvbFBvc2l0aW9uIiwiY29sR3JvdXAiLCJfZ2V0VG9wQ29sR3JvdXAiLCJtaW5pbXVtWSIsImdyb3VwQ291bnQiLCJfZ2V0Q29sR3JvdXBZIiwiZ3JvdXBDb2xZcyIsIl9nZXRIb3Jpem9udGFsQ29sUG9zaXRpb24iLCJpc092ZXIiLCJoYXNTaXplIiwic3RhbXBTaXplIiwiZmlyc3RYIiwibGFzdFgiLCJmaXJzdENvbCIsImZsb29yIiwibGFzdENvbCIsInN0YW1wTWF4WSIsIl9nZXRDb250YWluZXJGaXRXaWR0aCIsInVudXNlZENvbHMiLCJwcmV2aW91c1dpZHRoIiwiTWFzb25yeU1vZGUiLCJrZWVwTW9kZU1ldGhvZHMiLCJGaXRSb3dzIiwiaXRlbVdpZHRoIiwiVmVydGljYWwiLCJob3Jpem9udGFsQWxpZ25tZW50IiwidHJpbSIsIlN0cmluZyIsIklzb3RvcGUiLCJsYXlvdXRNb2RlIiwiaXNKUXVlcnlGaWx0ZXJpbmciLCJzb3J0QXNjZW5kaW5nIiwiX2dldFNvcnRlcnMiLCJzb3J0SGlzdG9yeSIsIm5hbWUiLCJfaW5pdExheW91dE1vZGUiLCJfdXBkYXRlSXRlbXNTb3J0RGF0YSIsImluaXRpYWxPcHRzIiwiYXJyYW5nZSIsIl9sYXlvdXQiLCJfZ2V0SXNJbnN0YW50IiwiZmlsdGVyZWQiLCJfZmlsdGVyIiwiX2JpbmRBcnJhbmdlQ29tcGxldGUiLCJfaXNJbnN0YW50IiwiX25vVHJhbnNpdGlvbiIsIl9oaWRlUmV2ZWFsIiwiX3NvcnQiLCJuZWVkUmV2ZWFsIiwibmVlZEhpZGUiLCJpc0xheW91dENvbXBsZXRlIiwiaXNIaWRlQ29tcGxldGUiLCJpc1JldmVhbENvbXBsZXRlIiwiYXJyYW5nZVBhcmFsbGVsQ2FsbGJhY2siLCJoaWRkZW5NYXRjaGVkIiwidmlzaWJsZVVubWF0Y2hlZCIsInRlc3QiLCJfZ2V0RmlsdGVyVGVzdCIsImlzTWF0Y2hlZCIsImlzIiwibXVuZ2VTb3J0ZXIiLCJsZW4iLCJzcGxpdCIsInF1ZXJ5IiwiYXR0ck1hdGNoIiwiZ2V0VmFsdWUiLCJnZXRWYWx1ZUdldHRlciIsInBhcnNlciIsInNvcnREYXRhUGFyc2VycyIsImdldENoaWxkVGV4dCIsImNoaWxkIiwidGV4dENvbnRlbnQiLCJ2YWwiLCJwYXJzZUludCIsInNvcnRCeSIsInNvcnRCeXMiLCJfZ2V0SXNTYW1lU29ydEJ5IiwiaXRlbVNvcnRlciIsImdldEl0ZW1Tb3J0ZXIiLCJzb3J0Iiwic29ydEFzYyIsIml0ZW1BIiwiaXRlbUIiLCJpc0FzY2VuZGluZyIsImRpcmVjdGlvbiIsIl9tb2RlIiwibW9kZSIsIkVycm9yIiwiX2ZpbHRlclJldmVhbEFkZGVkIiwiaW5zZXJ0IiwiZmlsdGVyZWRJbnNlcnRJdGVtcyIsIl9yZW1vdmUiLCJzaHVmZmxlIiwiZ2V0RmlsdGVyZWRJdGVtRWxlbWVudHMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFRSxXQUFVQSxNQUFWLEVBQWtCQyxPQUFsQixFQUE0QjtBQUMxQjs7QUFDQTs7QUFBMEI7QUFDMUIsTUFBSyxJQUFMLEVBQWlEO0FBQy9DO0FBQ0FDLHFDQUF3QyxDQUFFLHlFQUFGLENBQWxDLG1DQUFnRCxVQUFVQyxN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YixPQUFLLENBQUNtYyxhQUFOLEdBQXNCLFVBQVU3ZCxFQUFWLEVBQWNFLElBQWQsRUFBcUI7QUFDekM7QUFDQSxRQUFJb0wsa0JBQWtCLEdBQUcsS0FBS3hMLE9BQUwsQ0FBYXdMLGtCQUF0QyxDQUZ5QyxDQUd6Qzs7QUFDQSxTQUFLeEwsT0FBTCxDQUFhd0wsa0JBQWIsR0FBa0MsQ0FBbEMsQ0FKeUMsQ0FLekM7O0FBQ0EsUUFBSTdLLFdBQVcsR0FBR1QsRUFBRSxDQUFDbUIsS0FBSCxDQUFVLElBQVYsRUFBZ0JqQixJQUFoQixDQUFsQixDQU55QyxDQU96Qzs7QUFDQSxTQUFLSixPQUFMLENBQWF3TCxrQkFBYixHQUFrQ0Esa0JBQWxDO0FBQ0EsV0FBTzdLLFdBQVA7QUFDRCxHQVZELENBcmhCbUIsQ0FpaUJuQjs7QUFFQTtBQUNKO0FBQ0E7QUFDQTs7O0FBQ0lpQixPQUFLLENBQUNtZix1QkFBTixHQUFnQyxZQUFXO0FBQ3pDLFdBQU8sS0FBS3BJLGFBQUwsQ0FBbUJyRixHQUFuQixDQUF3QixVQUFVSCxJQUFWLEVBQWlCO0FBQzlDLGFBQU9BLElBQUksQ0FBQ3hILE9BQVo7QUFDRCxLQUZNLENBQVA7QUFHRCxHQUpELENBdmlCbUIsQ0E2aUJuQjs7O0FBRUEsU0FBT21SLE9BQVA7QUFFRCxDQWxtQkMsQ0FBRiIsImZpbGUiOiIuL3Jlc291cmNlcy9hc3NldHMvanMvaXNvdG9wZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogSXNvdG9wZSBQQUNLQUdFRCB2My4wLjZcbiAqXG4gKiBMaWNlbnNlZCBHUEx2MyBmb3Igb3BlbiBzb3VyY2UgdXNlXG4gKiBvciBJc290b3BlIENvbW1lcmNpYWwgTGljZW5zZSBmb3IgY29tbWVyY2lhbCB1c2VcbiAqXG4gKiBodHRwczovL2lzb3RvcGUubWV0YWZpenp5LmNvXG4gKiBDb3B5cmlnaHQgMjAxMC0yMDE4IE1ldGFmaXp6eVxuICovXG5cbi8qKlxuICogQnJpZGdldCBtYWtlcyBqUXVlcnkgd2lkZ2V0c1xuICogdjIuMC4xXG4gKiBNSVQgbGljZW5zZVxuICovXG5cbi8qIGpzaGludCBicm93c2VyOiB0cnVlLCBzdHJpY3Q6IHRydWUsIHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cblxuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAgIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICAgIC8qanNoaW50IHN0cmljdDogZmFsc2UgKi8gLyogZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSAqL1xuICAgIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgICAvLyBBTURcbiAgICAgIGRlZmluZSggJ2pxdWVyeS1icmlkZ2V0L2pxdWVyeS1icmlkZ2V0JyxbICdqcXVlcnknIF0sIGZ1bmN0aW9uKCBqUXVlcnkgKSB7XG4gICAgICAgIHJldHVybiBmYWN0b3J5KCB3aW5kb3csIGpRdWVyeSApO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAgIC8vIENvbW1vbkpTXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXG4gICAgICAgIHdpbmRvdyxcbiAgICAgICAgcmVxdWlyZSgnanF1ZXJ5JylcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgICB3aW5kb3cualF1ZXJ5QnJpZGdldCA9IGZhY3RvcnkoXG4gICAgICAgIHdpbmRvdyxcbiAgICAgICAgd2luZG93LmpRdWVyeVxuICAgICAgKTtcbiAgICB9XG4gIFxuICB9KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgalF1ZXJ5ICkge1xuICAndXNlIHN0cmljdCc7XG4gIFxuICAvLyAtLS0tLSB1dGlscyAtLS0tLSAvL1xuICBcbiAgdmFyIGFycmF5U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gIFxuICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIGxvZ2dpbmcgZXJyb3JzXG4gIC8vICQuZXJyb3IgYnJlYWtzIGpRdWVyeSBjaGFpbmluZ1xuICB2YXIgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlO1xuICB2YXIgbG9nRXJyb3IgPSB0eXBlb2YgY29uc29sZSA9PSAndW5kZWZpbmVkJyA/IGZ1bmN0aW9uKCkge30gOlxuICAgIGZ1bmN0aW9uKCBtZXNzYWdlICkge1xuICAgICAgY29uc29sZS5lcnJvciggbWVzc2FnZSApO1xuICAgIH07XG4gIFxuICAvLyAtLS0tLSBqUXVlcnlCcmlkZ2V0IC0tLS0tIC8vXG4gIFxuICBmdW5jdGlvbiBqUXVlcnlCcmlkZ2V0KCBuYW1lc3BhY2UsIFBsdWdpbkNsYXNzLCAkICkge1xuICAgICQgPSAkIHx8IGpRdWVyeSB8fCB3aW5kb3cualF1ZXJ5O1xuICAgIGlmICggISQgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICBcbiAgICAvLyBhZGQgb3B0aW9uIG1ldGhvZCAtPiAkKCkucGx1Z2luKCdvcHRpb24nLCB7Li4ufSlcbiAgICBpZiAoICFQbHVnaW5DbGFzcy5wcm90b3R5cGUub3B0aW9uICkge1xuICAgICAgLy8gb3B0aW9uIHNldHRlclxuICAgICAgUGx1Z2luQ2xhc3MucHJvdG90eXBlLm9wdGlvbiA9IGZ1bmN0aW9uKCBvcHRzICkge1xuICAgICAgICAvLyBiYWlsIG91dCBpZiBub3QgYW4gb2JqZWN0XG4gICAgICAgIGlmICggISQuaXNQbGFpbk9iamVjdCggb3B0cyApICl7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKCB0cnVlLCB0aGlzLm9wdGlvbnMsIG9wdHMgKTtcbiAgICAgIH07XG4gICAgfVxuICBcbiAgICAvLyBtYWtlIGpRdWVyeSBwbHVnaW5cbiAgICAkLmZuWyBuYW1lc3BhY2UgXSA9IGZ1bmN0aW9uKCBhcmcwIC8qLCBhcmcxICovICkge1xuICAgICAgaWYgKCB0eXBlb2YgYXJnMCA9PSAnc3RyaW5nJyApIHtcbiAgICAgICAgLy8gbWV0aG9kIGNhbGwgJCgpLnBsdWdpbiggJ21ldGhvZE5hbWUnLCB7IG9wdGlvbnMgfSApXG4gICAgICAgIC8vIHNoaWZ0IGFyZ3VtZW50cyBieSAxXG4gICAgICAgIHZhciBhcmdzID0gYXJyYXlTbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKTtcbiAgICAgICAgcmV0dXJuIG1ldGhvZENhbGwoIHRoaXMsIGFyZzAsIGFyZ3MgKTtcbiAgICAgIH1cbiAgICAgIC8vIGp1c3QgJCgpLnBsdWdpbih7IG9wdGlvbnMgfSlcbiAgICAgIHBsYWluQ2FsbCggdGhpcywgYXJnMCApO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgXG4gICAgLy8gJCgpLnBsdWdpbignbWV0aG9kTmFtZScpXG4gICAgZnVuY3Rpb24gbWV0aG9kQ2FsbCggJGVsZW1zLCBtZXRob2ROYW1lLCBhcmdzICkge1xuICAgICAgdmFyIHJldHVyblZhbHVlO1xuICAgICAgdmFyIHBsdWdpbk1ldGhvZFN0ciA9ICckKCkuJyArIG5hbWVzcGFjZSArICcoXCInICsgbWV0aG9kTmFtZSArICdcIiknO1xuICBcbiAgICAgICRlbGVtcy5lYWNoKCBmdW5jdGlvbiggaSwgZWxlbSApIHtcbiAgICAgICAgLy8gZ2V0IGluc3RhbmNlXG4gICAgICAgIHZhciBpbnN0YW5jZSA9ICQuZGF0YSggZWxlbSwgbmFtZXNwYWNlICk7XG4gICAgICAgIGlmICggIWluc3RhbmNlICkge1xuICAgICAgICAgIGxvZ0Vycm9yKCBuYW1lc3BhY2UgKyAnIG5vdCBpbml0aWFsaXplZC4gQ2Fubm90IGNhbGwgbWV0aG9kcywgaS5lLiAnICtcbiAgICAgICAgICAgIHBsdWdpbk1ldGhvZFN0ciApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICBcbiAgICAgICAgdmFyIG1ldGhvZCA9IGluc3RhbmNlWyBtZXRob2ROYW1lIF07XG4gICAgICAgIGlmICggIW1ldGhvZCB8fCBtZXRob2ROYW1lLmNoYXJBdCgwKSA9PSAnXycgKSB7XG4gICAgICAgICAgbG9nRXJyb3IoIHBsdWdpbk1ldGhvZFN0ciArICcgaXMgbm90IGEgdmFsaWQgbWV0aG9kJyApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICBcbiAgICAgICAgLy8gYXBwbHkgbWV0aG9kLCBnZXQgcmV0dXJuIHZhbHVlXG4gICAgICAgIHZhciB2YWx1ZSA9IG1ldGhvZC5hcHBseSggaW5zdGFuY2UsIGFyZ3MgKTtcbiAgICAgICAgLy8gc2V0IHJldHVybiB2YWx1ZSBpZiB2YWx1ZSBpcyByZXR1cm5lZCwgdXNlIG9ubHkgZmlyc3QgdmFsdWVcbiAgICAgICAgcmV0dXJuVmFsdWUgPSByZXR1cm5WYWx1ZSA9PT0gdW5kZWZpbmVkID8gdmFsdWUgOiByZXR1cm5WYWx1ZTtcbiAgICAgIH0pO1xuICBcbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZSAhPT0gdW5kZWZpbmVkID8gcmV0dXJuVmFsdWUgOiAkZWxlbXM7XG4gICAgfVxuICBcbiAgICBmdW5jdGlvbiBwbGFpbkNhbGwoICRlbGVtcywgb3B0aW9ucyApIHtcbiAgICAgICRlbGVtcy5lYWNoKCBmdW5jdGlvbiggaSwgZWxlbSApIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gJC5kYXRhKCBlbGVtLCBuYW1lc3BhY2UgKTtcbiAgICAgICAgaWYgKCBpbnN0YW5jZSApIHtcbiAgICAgICAgICAvLyBzZXQgb3B0aW9ucyAmIGluaXRcbiAgICAgICAgICBpbnN0YW5jZS5vcHRpb24oIG9wdGlvbnMgKTtcbiAgICAgICAgICBpbnN0YW5jZS5faW5pdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGluaXRpYWxpemUgbmV3IGluc3RhbmNlXG4gICAgICAgICAgaW5zdGFuY2UgPSBuZXcgUGx1Z2luQ2xhc3MoIGVsZW0sIG9wdGlvbnMgKTtcbiAgICAgICAgICAkLmRhdGEoIGVsZW0sIG5hbWVzcGFjZSwgaW5zdGFuY2UgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICBcbiAgICB1cGRhdGVKUXVlcnkoICQgKTtcbiAgXG4gIH1cbiAgXG4gIC8vIC0tLS0tIHVwZGF0ZUpRdWVyeSAtLS0tLSAvL1xuICBcbiAgLy8gc2V0ICQuYnJpZGdldCBmb3IgdjEgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgZnVuY3Rpb24gdXBkYXRlSlF1ZXJ5KCAkICkge1xuICAgIGlmICggISQgfHwgKCAkICYmICQuYnJpZGdldCApICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAkLmJyaWRnZXQgPSBqUXVlcnlCcmlkZ2V0O1xuICB9XG4gIFxuICB1cGRhdGVKUXVlcnkoIGpRdWVyeSB8fCB3aW5kb3cualF1ZXJ5ICk7XG4gIFxuICAvLyAtLS0tLSAgLS0tLS0gLy9cbiAgXG4gIHJldHVybiBqUXVlcnlCcmlkZ2V0O1xuICBcbiAgfSkpO1xuICBcbiAgLyoqXG4gICAqIEV2RW1pdHRlciB2MS4xLjBcbiAgICogTGlsJyBldmVudCBlbWl0dGVyXG4gICAqIE1JVCBMaWNlbnNlXG4gICAqL1xuICBcbiAgLyoganNoaW50IHVudXNlZDogdHJ1ZSwgdW5kZWY6IHRydWUsIHN0cmljdDogdHJ1ZSAqL1xuICBcbiAgKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuICAgIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICAgIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qIGdsb2JhbHMgZGVmaW5lLCBtb2R1bGUsIHdpbmRvdyAqL1xuICAgIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgICAvLyBBTUQgLSBSZXF1aXJlSlNcbiAgICAgIGRlZmluZSggJ2V2LWVtaXR0ZXIvZXYtZW1pdHRlcicsZmFjdG9yeSApO1xuICAgIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgICAvLyBDb21tb25KUyAtIEJyb3dzZXJpZnksIFdlYnBhY2tcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCcm93c2VyIGdsb2JhbHNcbiAgICAgIGdsb2JhbC5FdkVtaXR0ZXIgPSBmYWN0b3J5KCk7XG4gICAgfVxuICBcbiAgfSggdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCkge1xuICBcbiAgXG4gIFxuICBmdW5jdGlvbiBFdkVtaXR0ZXIoKSB7fVxuICBcbiAgdmFyIHByb3RvID0gRXZFbWl0dGVyLnByb3RvdHlwZTtcbiAgXG4gIHByb3RvLm9uID0gZnVuY3Rpb24oIGV2ZW50TmFtZSwgbGlzdGVuZXIgKSB7XG4gICAgaWYgKCAhZXZlbnROYW1lIHx8ICFsaXN0ZW5lciApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gc2V0IGV2ZW50cyBoYXNoXG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgICAvLyBzZXQgbGlzdGVuZXJzIGFycmF5XG4gICAgdmFyIGxpc3RlbmVycyA9IGV2ZW50c1sgZXZlbnROYW1lIF0gPSBldmVudHNbIGV2ZW50TmFtZSBdIHx8IFtdO1xuICAgIC8vIG9ubHkgYWRkIG9uY2VcbiAgICBpZiAoIGxpc3RlbmVycy5pbmRleE9mKCBsaXN0ZW5lciApID09IC0xICkge1xuICAgICAgbGlzdGVuZXJzLnB1c2goIGxpc3RlbmVyICk7XG4gICAgfVxuICBcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgXG4gIHByb3RvLm9uY2UgPSBmdW5jdGlvbiggZXZlbnROYW1lLCBsaXN0ZW5lciApIHtcbiAgICBpZiAoICFldmVudE5hbWUgfHwgIWxpc3RlbmVyICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBhZGQgZXZlbnRcbiAgICB0aGlzLm9uKCBldmVudE5hbWUsIGxpc3RlbmVyICk7XG4gICAgLy8gc2V0IG9uY2UgZmxhZ1xuICAgIC8vIHNldCBvbmNlRXZlbnRzIGhhc2hcbiAgICB2YXIgb25jZUV2ZW50cyA9IHRoaXMuX29uY2VFdmVudHMgPSB0aGlzLl9vbmNlRXZlbnRzIHx8IHt9O1xuICAgIC8vIHNldCBvbmNlTGlzdGVuZXJzIG9iamVjdFxuICAgIHZhciBvbmNlTGlzdGVuZXJzID0gb25jZUV2ZW50c1sgZXZlbnROYW1lIF0gPSBvbmNlRXZlbnRzWyBldmVudE5hbWUgXSB8fCB7fTtcbiAgICAvLyBzZXQgZmxhZ1xuICAgIG9uY2VMaXN0ZW5lcnNbIGxpc3RlbmVyIF0gPSB0cnVlO1xuICBcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgXG4gIHByb3RvLm9mZiA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGxpc3RlbmVyICkge1xuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzWyBldmVudE5hbWUgXTtcbiAgICBpZiAoICFsaXN0ZW5lcnMgfHwgIWxpc3RlbmVycy5sZW5ndGggKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKCBsaXN0ZW5lciApO1xuICAgIGlmICggaW5kZXggIT0gLTEgKSB7XG4gICAgICBsaXN0ZW5lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuICAgIH1cbiAgXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIFxuICBwcm90by5lbWl0RXZlbnQgPSBmdW5jdGlvbiggZXZlbnROYW1lLCBhcmdzICkge1xuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzWyBldmVudE5hbWUgXTtcbiAgICBpZiAoICFsaXN0ZW5lcnMgfHwgIWxpc3RlbmVycy5sZW5ndGggKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGNvcHkgb3ZlciB0byBhdm9pZCBpbnRlcmZlcmVuY2UgaWYgLm9mZigpIGluIGxpc3RlbmVyXG4gICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKDApO1xuICAgIGFyZ3MgPSBhcmdzIHx8IFtdO1xuICAgIC8vIG9uY2Ugc3R1ZmZcbiAgICB2YXIgb25jZUxpc3RlbmVycyA9IHRoaXMuX29uY2VFdmVudHMgJiYgdGhpcy5fb25jZUV2ZW50c1sgZXZlbnROYW1lIF07XG4gIFxuICAgIGZvciAoIHZhciBpPTA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKysgKSB7XG4gICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV1cbiAgICAgIHZhciBpc09uY2UgPSBvbmNlTGlzdGVuZXJzICYmIG9uY2VMaXN0ZW5lcnNbIGxpc3RlbmVyIF07XG4gICAgICBpZiAoIGlzT25jZSApIHtcbiAgICAgICAgLy8gcmVtb3ZlIGxpc3RlbmVyXG4gICAgICAgIC8vIHJlbW92ZSBiZWZvcmUgdHJpZ2dlciB0byBwcmV2ZW50IHJlY3Vyc2lvblxuICAgICAgICB0aGlzLm9mZiggZXZlbnROYW1lLCBsaXN0ZW5lciApO1xuICAgICAgICAvLyB1bnNldCBvbmNlIGZsYWdcbiAgICAgICAgZGVsZXRlIG9uY2VMaXN0ZW5lcnNbIGxpc3RlbmVyIF07XG4gICAgICB9XG4gICAgICAvLyB0cmlnZ2VyIGxpc3RlbmVyXG4gICAgICBsaXN0ZW5lci5hcHBseSggdGhpcywgYXJncyApO1xuICAgIH1cbiAgXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIFxuICBwcm90by5hbGxPZmYgPSBmdW5jdGlvbigpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzO1xuICAgIGRlbGV0ZSB0aGlzLl9vbmNlRXZlbnRzO1xuICB9O1xuICBcbiAgcmV0dXJuIEV2RW1pdHRlcjtcbiAgXG4gIH0pKTtcbiAgXG4gIC8qIVxuICAgKiBnZXRTaXplIHYyLjAuM1xuICAgKiBtZWFzdXJlIHNpemUgb2YgZWxlbWVudHNcbiAgICogTUlUIGxpY2Vuc2VcbiAgICovXG4gIFxuICAvKiBqc2hpbnQgYnJvd3NlcjogdHJ1ZSwgc3RyaWN0OiB0cnVlLCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlICovXG4gIC8qIGdsb2JhbHMgY29uc29sZTogZmFsc2UgKi9cbiAgXG4gICggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgICAvKiBqc2hpbnQgc3RyaWN0OiBmYWxzZSAqLyAvKiBnbG9iYWxzIGRlZmluZSwgbW9kdWxlICovXG4gICAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAgIC8vIEFNRFxuICAgICAgZGVmaW5lKCAnZ2V0LXNpemUvZ2V0LXNpemUnLGZhY3RvcnkgKTtcbiAgICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgICAgLy8gQ29tbW9uSlNcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgICAgd2luZG93LmdldFNpemUgPSBmYWN0b3J5KCk7XG4gICAgfVxuICBcbiAgfSkoIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICBcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gaGVscGVycyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICBcbiAgLy8gZ2V0IGEgbnVtYmVyIGZyb20gYSBzdHJpbmcsIG5vdCBhIHBlcmNlbnRhZ2VcbiAgZnVuY3Rpb24gZ2V0U3R5bGVTaXplKCB2YWx1ZSApIHtcbiAgICB2YXIgbnVtID0gcGFyc2VGbG9hdCggdmFsdWUgKTtcbiAgICAvLyBub3QgYSBwZXJjZW50IGxpa2UgJzEwMCUnLCBhbmQgYSBudW1iZXJcbiAgICB2YXIgaXNWYWxpZCA9IHZhbHVlLmluZGV4T2YoJyUnKSA9PSAtMSAmJiAhaXNOYU4oIG51bSApO1xuICAgIHJldHVybiBpc1ZhbGlkICYmIG51bTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gbm9vcCgpIHt9XG4gIFxuICB2YXIgbG9nRXJyb3IgPSB0eXBlb2YgY29uc29sZSA9PSAndW5kZWZpbmVkJyA/IG5vb3AgOlxuICAgIGZ1bmN0aW9uKCBtZXNzYWdlICkge1xuICAgICAgY29uc29sZS5lcnJvciggbWVzc2FnZSApO1xuICAgIH07XG4gIFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBtZWFzdXJlbWVudHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cbiAgXG4gIHZhciBtZWFzdXJlbWVudHMgPSBbXG4gICAgJ3BhZGRpbmdMZWZ0JyxcbiAgICAncGFkZGluZ1JpZ2h0JyxcbiAgICAncGFkZGluZ1RvcCcsXG4gICAgJ3BhZGRpbmdCb3R0b20nLFxuICAgICdtYXJnaW5MZWZ0JyxcbiAgICAnbWFyZ2luUmlnaHQnLFxuICAgICdtYXJnaW5Ub3AnLFxuICAgICdtYXJnaW5Cb3R0b20nLFxuICAgICdib3JkZXJMZWZ0V2lkdGgnLFxuICAgICdib3JkZXJSaWdodFdpZHRoJyxcbiAgICAnYm9yZGVyVG9wV2lkdGgnLFxuICAgICdib3JkZXJCb3R0b21XaWR0aCdcbiAgXTtcbiAgXG4gIHZhciBtZWFzdXJlbWVudHNMZW5ndGggPSBtZWFzdXJlbWVudHMubGVuZ3RoO1xuICBcbiAgZnVuY3Rpb24gZ2V0WmVyb1NpemUoKSB7XG4gICAgdmFyIHNpemUgPSB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIGlubmVyV2lkdGg6IDAsXG4gICAgICBpbm5lckhlaWdodDogMCxcbiAgICAgIG91dGVyV2lkdGg6IDAsXG4gICAgICBvdXRlckhlaWdodDogMFxuICAgIH07XG4gICAgZm9yICggdmFyIGk9MDsgaSA8IG1lYXN1cmVtZW50c0xlbmd0aDsgaSsrICkge1xuICAgICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW2ldO1xuICAgICAgc2l6ZVsgbWVhc3VyZW1lbnQgXSA9IDA7XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xuICB9XG4gIFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBnZXRTdHlsZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICBcbiAgLyoqXG4gICAqIGdldFN0eWxlLCBnZXQgc3R5bGUgb2YgZWxlbWVudCwgY2hlY2sgZm9yIEZpcmVmb3ggYnVnXG4gICAqIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU0ODM5N1xuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U3R5bGUoIGVsZW0gKSB7XG4gICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuICAgIGlmICggIXN0eWxlICkge1xuICAgICAgbG9nRXJyb3IoICdTdHlsZSByZXR1cm5lZCAnICsgc3R5bGUgK1xuICAgICAgICAnLiBBcmUgeW91IHJ1bm5pbmcgdGhpcyBjb2RlIGluIGEgaGlkZGVuIGlmcmFtZSBvbiBGaXJlZm94PyAnICtcbiAgICAgICAgJ1NlZSBodHRwczovL2JpdC5seS9nZXRzaXplYnVnMScgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG4gIFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBzZXR1cCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICBcbiAgdmFyIGlzU2V0dXAgPSBmYWxzZTtcbiAgXG4gIHZhciBpc0JveFNpemVPdXRlcjtcbiAgXG4gIC8qKlxuICAgKiBzZXR1cFxuICAgKiBjaGVjayBpc0JveFNpemVyT3V0ZXJcbiAgICogZG8gb24gZmlyc3QgZ2V0U2l6ZSgpIHJhdGhlciB0aGFuIG9uIHBhZ2UgbG9hZCBmb3IgRmlyZWZveCBidWdcbiAgICovXG4gIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgIC8vIHNldHVwIG9uY2VcbiAgICBpZiAoIGlzU2V0dXAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlzU2V0dXAgPSB0cnVlO1xuICBcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBib3ggc2l6aW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG4gIFxuICAgIC8qKlxuICAgICAqIENocm9tZSAmIFNhZmFyaSBtZWFzdXJlIHRoZSBvdXRlci13aWR0aCBvbiBzdHlsZS53aWR0aCBvbiBib3JkZXItYm94IGVsZW1zXG4gICAgICogSUUxMSAmIEZpcmVmb3g8MjkgbWVhc3VyZXMgdGhlIGlubmVyLXdpZHRoXG4gICAgICovXG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5zdHlsZS53aWR0aCA9ICcyMDBweCc7XG4gICAgZGl2LnN0eWxlLnBhZGRpbmcgPSAnMXB4IDJweCAzcHggNHB4JztcbiAgICBkaXYuc3R5bGUuYm9yZGVyU3R5bGUgPSAnc29saWQnO1xuICAgIGRpdi5zdHlsZS5ib3JkZXJXaWR0aCA9ICcxcHggMnB4IDNweCA0cHgnO1xuICAgIGRpdi5zdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCc7XG4gIFxuICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgYm9keS5hcHBlbmRDaGlsZCggZGl2ICk7XG4gICAgdmFyIHN0eWxlID0gZ2V0U3R5bGUoIGRpdiApO1xuICAgIC8vIHJvdW5kIHZhbHVlIGZvciBicm93c2VyIHpvb20uIGRlc2FuZHJvL21hc29ucnkjOTI4XG4gICAgaXNCb3hTaXplT3V0ZXIgPSBNYXRoLnJvdW5kKCBnZXRTdHlsZVNpemUoIHN0eWxlLndpZHRoICkgKSA9PSAyMDA7XG4gICAgZ2V0U2l6ZS5pc0JveFNpemVPdXRlciA9IGlzQm94U2l6ZU91dGVyO1xuICBcbiAgICBib2R5LnJlbW92ZUNoaWxkKCBkaXYgKTtcbiAgfVxuICBcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZ2V0U2l6ZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICBcbiAgZnVuY3Rpb24gZ2V0U2l6ZSggZWxlbSApIHtcbiAgICBzZXR1cCgpO1xuICBcbiAgICAvLyB1c2UgcXVlcnlTZWxldG9yIGlmIGVsZW0gaXMgc3RyaW5nXG4gICAgaWYgKCB0eXBlb2YgZWxlbSA9PSAnc3RyaW5nJyApIHtcbiAgICAgIGVsZW0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCBlbGVtICk7XG4gICAgfVxuICBcbiAgICAvLyBkbyBub3QgcHJvY2VlZCBvbiBub24tb2JqZWN0c1xuICAgIGlmICggIWVsZW0gfHwgdHlwZW9mIGVsZW0gIT0gJ29iamVjdCcgfHwgIWVsZW0ubm9kZVR5cGUgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICBcbiAgICB2YXIgc3R5bGUgPSBnZXRTdHlsZSggZWxlbSApO1xuICBcbiAgICAvLyBpZiBoaWRkZW4sIGV2ZXJ5dGhpbmcgaXMgMFxuICAgIGlmICggc3R5bGUuZGlzcGxheSA9PSAnbm9uZScgKSB7XG4gICAgICByZXR1cm4gZ2V0WmVyb1NpemUoKTtcbiAgICB9XG4gIFxuICAgIHZhciBzaXplID0ge307XG4gICAgc2l6ZS53aWR0aCA9IGVsZW0ub2Zmc2V0V2lkdGg7XG4gICAgc2l6ZS5oZWlnaHQgPSBlbGVtLm9mZnNldEhlaWdodDtcbiAgXG4gICAgdmFyIGlzQm9yZGVyQm94ID0gc2l6ZS5pc0JvcmRlckJveCA9IHN0eWxlLmJveFNpemluZyA9PSAnYm9yZGVyLWJveCc7XG4gIFxuICAgIC8vIGdldCBhbGwgbWVhc3VyZW1lbnRzXG4gICAgZm9yICggdmFyIGk9MDsgaSA8IG1lYXN1cmVtZW50c0xlbmd0aDsgaSsrICkge1xuICAgICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gc3R5bGVbIG1lYXN1cmVtZW50IF07XG4gICAgICB2YXIgbnVtID0gcGFyc2VGbG9hdCggdmFsdWUgKTtcbiAgICAgIC8vIGFueSAnYXV0bycsICdtZWRpdW0nIHZhbHVlIHdpbGwgYmUgMFxuICAgICAgc2l6ZVsgbWVhc3VyZW1lbnQgXSA9ICFpc05hTiggbnVtICkgPyBudW0gOiAwO1xuICAgIH1cbiAgXG4gICAgdmFyIHBhZGRpbmdXaWR0aCA9IHNpemUucGFkZGluZ0xlZnQgKyBzaXplLnBhZGRpbmdSaWdodDtcbiAgICB2YXIgcGFkZGluZ0hlaWdodCA9IHNpemUucGFkZGluZ1RvcCArIHNpemUucGFkZGluZ0JvdHRvbTtcbiAgICB2YXIgbWFyZ2luV2lkdGggPSBzaXplLm1hcmdpbkxlZnQgKyBzaXplLm1hcmdpblJpZ2h0O1xuICAgIHZhciBtYXJnaW5IZWlnaHQgPSBzaXplLm1hcmdpblRvcCArIHNpemUubWFyZ2luQm90dG9tO1xuICAgIHZhciBib3JkZXJXaWR0aCA9IHNpemUuYm9yZGVyTGVmdFdpZHRoICsgc2l6ZS5ib3JkZXJSaWdodFdpZHRoO1xuICAgIHZhciBib3JkZXJIZWlnaHQgPSBzaXplLmJvcmRlclRvcFdpZHRoICsgc2l6ZS5ib3JkZXJCb3R0b21XaWR0aDtcbiAgXG4gICAgdmFyIGlzQm9yZGVyQm94U2l6ZU91dGVyID0gaXNCb3JkZXJCb3ggJiYgaXNCb3hTaXplT3V0ZXI7XG4gIFxuICAgIC8vIG92ZXJ3cml0ZSB3aWR0aCBhbmQgaGVpZ2h0IGlmIHdlIGNhbiBnZXQgaXQgZnJvbSBzdHlsZVxuICAgIHZhciBzdHlsZVdpZHRoID0gZ2V0U3R5bGVTaXplKCBzdHlsZS53aWR0aCApO1xuICAgIGlmICggc3R5bGVXaWR0aCAhPT0gZmFsc2UgKSB7XG4gICAgICBzaXplLndpZHRoID0gc3R5bGVXaWR0aCArXG4gICAgICAgIC8vIGFkZCBwYWRkaW5nIGFuZCBib3JkZXIgdW5sZXNzIGl0J3MgYWxyZWFkeSBpbmNsdWRpbmcgaXRcbiAgICAgICAgKCBpc0JvcmRlckJveFNpemVPdXRlciA/IDAgOiBwYWRkaW5nV2lkdGggKyBib3JkZXJXaWR0aCApO1xuICAgIH1cbiAgXG4gICAgdmFyIHN0eWxlSGVpZ2h0ID0gZ2V0U3R5bGVTaXplKCBzdHlsZS5oZWlnaHQgKTtcbiAgICBpZiAoIHN0eWxlSGVpZ2h0ICE9PSBmYWxzZSApIHtcbiAgICAgIHNpemUuaGVpZ2h0ID0gc3R5bGVIZWlnaHQgK1xuICAgICAgICAvLyBhZGQgcGFkZGluZyBhbmQgYm9yZGVyIHVubGVzcyBpdCdzIGFscmVhZHkgaW5jbHVkaW5nIGl0XG4gICAgICAgICggaXNCb3JkZXJCb3hTaXplT3V0ZXIgPyAwIDogcGFkZGluZ0hlaWdodCArIGJvcmRlckhlaWdodCApO1xuICAgIH1cbiAgXG4gICAgc2l6ZS5pbm5lcldpZHRoID0gc2l6ZS53aWR0aCAtICggcGFkZGluZ1dpZHRoICsgYm9yZGVyV2lkdGggKTtcbiAgICBzaXplLmlubmVySGVpZ2h0ID0gc2l6ZS5oZWlnaHQgLSAoIHBhZGRpbmdIZWlnaHQgKyBib3JkZXJIZWlnaHQgKTtcbiAgXG4gICAgc2l6ZS5vdXRlcldpZHRoID0gc2l6ZS53aWR0aCArIG1hcmdpbldpZHRoO1xuICAgIHNpemUub3V0ZXJIZWlnaHQgPSBzaXplLmhlaWdodCArIG1hcmdpbkhlaWdodDtcbiAgXG4gICAgcmV0dXJuIHNpemU7XG4gIH1cbiAgXG4gIHJldHVybiBnZXRTaXplO1xuICBcbiAgfSk7XG4gIFxuICAvKipcbiAgICogbWF0Y2hlc1NlbGVjdG9yIHYyLjAuMlxuICAgKiBtYXRjaGVzU2VsZWN0b3IoIGVsZW1lbnQsICcuc2VsZWN0b3InIClcbiAgICogTUlUIGxpY2Vuc2VcbiAgICovXG4gIFxuICAvKmpzaGludCBicm93c2VyOiB0cnVlLCBzdHJpY3Q6IHRydWUsIHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cbiAgXG4gICggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgICAvKmdsb2JhbCBkZWZpbmU6IGZhbHNlLCBtb2R1bGU6IGZhbHNlICovXG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICAgIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgICAvLyBBTURcbiAgICAgIGRlZmluZSggJ2Rlc2FuZHJvLW1hdGNoZXMtc2VsZWN0b3IvbWF0Y2hlcy1zZWxlY3RvcicsZmFjdG9yeSApO1xuICAgIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgICAvLyBDb21tb25KU1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgICB3aW5kb3cubWF0Y2hlc1NlbGVjdG9yID0gZmFjdG9yeSgpO1xuICAgIH1cbiAgXG4gIH0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gIFxuICAgIHZhciBtYXRjaGVzTWV0aG9kID0gKCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBFbGVtUHJvdG8gPSB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGU7XG4gICAgICAvLyBjaGVjayBmb3IgdGhlIHN0YW5kYXJkIG1ldGhvZCBuYW1lIGZpcnN0XG4gICAgICBpZiAoIEVsZW1Qcm90by5tYXRjaGVzICkge1xuICAgICAgICByZXR1cm4gJ21hdGNoZXMnO1xuICAgICAgfVxuICAgICAgLy8gY2hlY2sgdW4tcHJlZml4ZWRcbiAgICAgIGlmICggRWxlbVByb3RvLm1hdGNoZXNTZWxlY3RvciApIHtcbiAgICAgICAgcmV0dXJuICdtYXRjaGVzU2VsZWN0b3InO1xuICAgICAgfVxuICAgICAgLy8gY2hlY2sgdmVuZG9yIHByZWZpeGVzXG4gICAgICB2YXIgcHJlZml4ZXMgPSBbICd3ZWJraXQnLCAnbW96JywgJ21zJywgJ28nIF07XG4gIFxuICAgICAgZm9yICggdmFyIGk9MDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICB2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV07XG4gICAgICAgIHZhciBtZXRob2QgPSBwcmVmaXggKyAnTWF0Y2hlc1NlbGVjdG9yJztcbiAgICAgICAgaWYgKCBFbGVtUHJvdG9bIG1ldGhvZCBdICkge1xuICAgICAgICAgIHJldHVybiBtZXRob2Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSgpO1xuICBcbiAgICByZXR1cm4gZnVuY3Rpb24gbWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBzZWxlY3RvciApIHtcbiAgICAgIHJldHVybiBlbGVtWyBtYXRjaGVzTWV0aG9kIF0oIHNlbGVjdG9yICk7XG4gICAgfTtcbiAgXG4gIH0pKTtcbiAgXG4gIC8qKlxuICAgKiBGaXp6eSBVSSB1dGlscyB2Mi4wLjdcbiAgICogTUlUIGxpY2Vuc2VcbiAgICovXG4gIFxuICAvKmpzaGludCBicm93c2VyOiB0cnVlLCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlLCBzdHJpY3Q6IHRydWUgKi9cbiAgXG4gICggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgICAvKmpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSAqL1xuICBcbiAgICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgICAgLy8gQU1EXG4gICAgICBkZWZpbmUoICdmaXp6eS11aS11dGlscy91dGlscycsW1xuICAgICAgICAnZGVzYW5kcm8tbWF0Y2hlcy1zZWxlY3Rvci9tYXRjaGVzLXNlbGVjdG9yJ1xuICAgICAgXSwgZnVuY3Rpb24oIG1hdGNoZXNTZWxlY3RvciApIHtcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkoIHdpbmRvdywgbWF0Y2hlc1NlbGVjdG9yICk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgICAgLy8gQ29tbW9uSlNcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgICAgd2luZG93LFxuICAgICAgICByZXF1aXJlKCdkZXNhbmRyby1tYXRjaGVzLXNlbGVjdG9yJylcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgICB3aW5kb3cuZml6enlVSVV0aWxzID0gZmFjdG9yeShcbiAgICAgICAgd2luZG93LFxuICAgICAgICB3aW5kb3cubWF0Y2hlc1NlbGVjdG9yXG4gICAgICApO1xuICAgIH1cbiAgXG4gIH0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSggd2luZG93LCBtYXRjaGVzU2VsZWN0b3IgKSB7XG4gIFxuICBcbiAgXG4gIHZhciB1dGlscyA9IHt9O1xuICBcbiAgLy8gLS0tLS0gZXh0ZW5kIC0tLS0tIC8vXG4gIFxuICAvLyBleHRlbmRzIG9iamVjdHNcbiAgdXRpbHMuZXh0ZW5kID0gZnVuY3Rpb24oIGEsIGIgKSB7XG4gICAgZm9yICggdmFyIHByb3AgaW4gYiApIHtcbiAgICAgIGFbIHByb3AgXSA9IGJbIHByb3AgXTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH07XG4gIFxuICAvLyAtLS0tLSBtb2R1bG8gLS0tLS0gLy9cbiAgXG4gIHV0aWxzLm1vZHVsbyA9IGZ1bmN0aW9uKCBudW0sIGRpdiApIHtcbiAgICByZXR1cm4gKCAoIG51bSAlIGRpdiApICsgZGl2ICkgJSBkaXY7XG4gIH07XG4gIFxuICAvLyAtLS0tLSBtYWtlQXJyYXkgLS0tLS0gLy9cbiAgXG4gIHZhciBhcnJheVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuICBcbiAgLy8gdHVybiBlbGVtZW50IG9yIG5vZGVMaXN0IGludG8gYW4gYXJyYXlcbiAgdXRpbHMubWFrZUFycmF5ID0gZnVuY3Rpb24oIG9iaiApIHtcbiAgICBpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xuICAgICAgLy8gdXNlIG9iamVjdCBpZiBhbHJlYWR5IGFuIGFycmF5XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgYXJyYXkgaWYgdW5kZWZpbmVkIG9yIG51bGwuICM2XG4gICAgaWYgKCBvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQgKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICBcbiAgICB2YXIgaXNBcnJheUxpa2UgPSB0eXBlb2Ygb2JqID09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoubGVuZ3RoID09ICdudW1iZXInO1xuICAgIGlmICggaXNBcnJheUxpa2UgKSB7XG4gICAgICAvLyBjb252ZXJ0IG5vZGVMaXN0IHRvIGFycmF5XG4gICAgICByZXR1cm4gYXJyYXlTbGljZS5jYWxsKCBvYmogKTtcbiAgICB9XG4gIFxuICAgIC8vIGFycmF5IG9mIHNpbmdsZSBpbmRleFxuICAgIHJldHVybiBbIG9iaiBdO1xuICB9O1xuICBcbiAgLy8gLS0tLS0gcmVtb3ZlRnJvbSAtLS0tLSAvL1xuICBcbiAgdXRpbHMucmVtb3ZlRnJvbSA9IGZ1bmN0aW9uKCBhcnksIG9iaiApIHtcbiAgICB2YXIgaW5kZXggPSBhcnkuaW5kZXhPZiggb2JqICk7XG4gICAgaWYgKCBpbmRleCAhPSAtMSApIHtcbiAgICAgIGFyeS5zcGxpY2UoIGluZGV4LCAxICk7XG4gICAgfVxuICB9O1xuICBcbiAgLy8gLS0tLS0gZ2V0UGFyZW50IC0tLS0tIC8vXG4gIFxuICB1dGlscy5nZXRQYXJlbnQgPSBmdW5jdGlvbiggZWxlbSwgc2VsZWN0b3IgKSB7XG4gICAgd2hpbGUgKCBlbGVtLnBhcmVudE5vZGUgJiYgZWxlbSAhPSBkb2N1bWVudC5ib2R5ICkge1xuICAgICAgZWxlbSA9IGVsZW0ucGFyZW50Tm9kZTtcbiAgICAgIGlmICggbWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBzZWxlY3RvciApICkge1xuICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFxuICAvLyAtLS0tLSBnZXRRdWVyeUVsZW1lbnQgLS0tLS0gLy9cbiAgXG4gIC8vIHVzZSBlbGVtZW50IGFzIHNlbGVjdG9yIHN0cmluZ1xuICB1dGlscy5nZXRRdWVyeUVsZW1lbnQgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgICBpZiAoIHR5cGVvZiBlbGVtID09ICdzdHJpbmcnICkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIGVsZW0gKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW07XG4gIH07XG4gIFxuICAvLyAtLS0tLSBoYW5kbGVFdmVudCAtLS0tLSAvL1xuICBcbiAgLy8gZW5hYmxlIC5vbnR5cGUgdG8gdHJpZ2dlciBmcm9tIC5hZGRFdmVudExpc3RlbmVyKCBlbGVtLCAndHlwZScgKVxuICB1dGlscy5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICB2YXIgbWV0aG9kID0gJ29uJyArIGV2ZW50LnR5cGU7XG4gICAgaWYgKCB0aGlzWyBtZXRob2QgXSApIHtcbiAgICAgIHRoaXNbIG1ldGhvZCBdKCBldmVudCApO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIC0tLS0tIGZpbHRlckZpbmRFbGVtZW50cyAtLS0tLSAvL1xuICBcbiAgdXRpbHMuZmlsdGVyRmluZEVsZW1lbnRzID0gZnVuY3Rpb24oIGVsZW1zLCBzZWxlY3RvciApIHtcbiAgICAvLyBtYWtlIGFycmF5IG9mIGVsZW1zXG4gICAgZWxlbXMgPSB1dGlscy5tYWtlQXJyYXkoIGVsZW1zICk7XG4gICAgdmFyIGZmRWxlbXMgPSBbXTtcbiAgXG4gICAgZWxlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAvLyBjaGVjayB0aGF0IGVsZW0gaXMgYW4gYWN0dWFsIGVsZW1lbnRcbiAgICAgIGlmICggISggZWxlbSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICkgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGFkZCBlbGVtIGlmIG5vIHNlbGVjdG9yXG4gICAgICBpZiAoICFzZWxlY3RvciApIHtcbiAgICAgICAgZmZFbGVtcy5wdXNoKCBlbGVtICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGZpbHRlciAmIGZpbmQgaXRlbXMgaWYgd2UgaGF2ZSBhIHNlbGVjdG9yXG4gICAgICAvLyBmaWx0ZXJcbiAgICAgIGlmICggbWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBzZWxlY3RvciApICkge1xuICAgICAgICBmZkVsZW1zLnB1c2goIGVsZW0gKTtcbiAgICAgIH1cbiAgICAgIC8vIGZpbmQgY2hpbGRyZW5cbiAgICAgIHZhciBjaGlsZEVsZW1zID0gZWxlbS5xdWVyeVNlbGVjdG9yQWxsKCBzZWxlY3RvciApO1xuICAgICAgLy8gY29uY2F0IGNoaWxkRWxlbXMgdG8gZmlsdGVyRm91bmQgYXJyYXlcbiAgICAgIGZvciAoIHZhciBpPTA7IGkgPCBjaGlsZEVsZW1zLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBmZkVsZW1zLnB1c2goIGNoaWxkRWxlbXNbaV0gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgXG4gICAgcmV0dXJuIGZmRWxlbXM7XG4gIH07XG4gIFxuICAvLyAtLS0tLSBkZWJvdW5jZU1ldGhvZCAtLS0tLSAvL1xuICBcbiAgdXRpbHMuZGVib3VuY2VNZXRob2QgPSBmdW5jdGlvbiggX2NsYXNzLCBtZXRob2ROYW1lLCB0aHJlc2hvbGQgKSB7XG4gICAgdGhyZXNob2xkID0gdGhyZXNob2xkIHx8IDEwMDtcbiAgICAvLyBvcmlnaW5hbCBtZXRob2RcbiAgICB2YXIgbWV0aG9kID0gX2NsYXNzLnByb3RvdHlwZVsgbWV0aG9kTmFtZSBdO1xuICAgIHZhciB0aW1lb3V0TmFtZSA9IG1ldGhvZE5hbWUgKyAnVGltZW91dCc7XG4gIFxuICAgIF9jbGFzcy5wcm90b3R5cGVbIG1ldGhvZE5hbWUgXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRpbWVvdXQgPSB0aGlzWyB0aW1lb3V0TmFtZSBdO1xuICAgICAgY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG4gIFxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpc1sgdGltZW91dE5hbWUgXSA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgICBtZXRob2QuYXBwbHkoIF90aGlzLCBhcmdzICk7XG4gICAgICAgIGRlbGV0ZSBfdGhpc1sgdGltZW91dE5hbWUgXTtcbiAgICAgIH0sIHRocmVzaG9sZCApO1xuICAgIH07XG4gIH07XG4gIFxuICAvLyAtLS0tLSBkb2NSZWFkeSAtLS0tLSAvL1xuICBcbiAgdXRpbHMuZG9jUmVhZHkgPSBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG4gICAgdmFyIHJlYWR5U3RhdGUgPSBkb2N1bWVudC5yZWFkeVN0YXRlO1xuICAgIGlmICggcmVhZHlTdGF0ZSA9PSAnY29tcGxldGUnIHx8IHJlYWR5U3RhdGUgPT0gJ2ludGVyYWN0aXZlJyApIHtcbiAgICAgIC8vIGRvIGFzeW5jIHRvIGFsbG93IGZvciBvdGhlciBzY3JpcHRzIHRvIHJ1bi4gbWV0YWZpenp5L2ZsaWNraXR5IzQ0MVxuICAgICAgc2V0VGltZW91dCggY2FsbGJhY2sgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ0RPTUNvbnRlbnRMb2FkZWQnLCBjYWxsYmFjayApO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIC0tLS0tIGh0bWxJbml0IC0tLS0tIC8vXG4gIFxuICAvLyBodHRwOi8vamFtZXNyb2JlcnRzLm5hbWUvYmxvZy8yMDEwLzAyLzIyL3N0cmluZy1mdW5jdGlvbnMtZm9yLWphdmFzY3JpcHQtdHJpbS10by1jYW1lbC1jYXNlLXRvLWRhc2hlZC1hbmQtdG8tdW5kZXJzY29yZS9cbiAgdXRpbHMudG9EYXNoZWQgPSBmdW5jdGlvbiggc3RyICkge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSggLyguKShbQS1aXSkvZywgZnVuY3Rpb24oIG1hdGNoLCAkMSwgJDIgKSB7XG4gICAgICByZXR1cm4gJDEgKyAnLScgKyAkMjtcbiAgICB9KS50b0xvd2VyQ2FzZSgpO1xuICB9O1xuICBcbiAgdmFyIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZTtcbiAgLyoqXG4gICAqIGFsbG93IHVzZXIgdG8gaW5pdGlhbGl6ZSBjbGFzc2VzIHZpYSBbZGF0YS1uYW1lc3BhY2VdIG9yIC5qcy1uYW1lc3BhY2UgY2xhc3NcbiAgICogaHRtbEluaXQoIFdpZGdldCwgJ3dpZGdldE5hbWUnIClcbiAgICogb3B0aW9ucyBhcmUgcGFyc2VkIGZyb20gZGF0YS1uYW1lc3BhY2Utb3B0aW9uc1xuICAgKi9cbiAgdXRpbHMuaHRtbEluaXQgPSBmdW5jdGlvbiggV2lkZ2V0Q2xhc3MsIG5hbWVzcGFjZSApIHtcbiAgICB1dGlscy5kb2NSZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGFzaGVkTmFtZXNwYWNlID0gdXRpbHMudG9EYXNoZWQoIG5hbWVzcGFjZSApO1xuICAgICAgdmFyIGRhdGFBdHRyID0gJ2RhdGEtJyArIGRhc2hlZE5hbWVzcGFjZTtcbiAgICAgIHZhciBkYXRhQXR0ckVsZW1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCggJ1snICsgZGF0YUF0dHIgKyAnXScgKTtcbiAgICAgIHZhciBqc0Rhc2hFbGVtcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoICcuanMtJyArIGRhc2hlZE5hbWVzcGFjZSApO1xuICAgICAgdmFyIGVsZW1zID0gdXRpbHMubWFrZUFycmF5KCBkYXRhQXR0ckVsZW1zIClcbiAgICAgICAgLmNvbmNhdCggdXRpbHMubWFrZUFycmF5KCBqc0Rhc2hFbGVtcyApICk7XG4gICAgICB2YXIgZGF0YU9wdGlvbnNBdHRyID0gZGF0YUF0dHIgKyAnLW9wdGlvbnMnO1xuICAgICAgdmFyIGpRdWVyeSA9IHdpbmRvdy5qUXVlcnk7XG4gIFxuICAgICAgZWxlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgIHZhciBhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoIGRhdGFBdHRyICkgfHxcbiAgICAgICAgICBlbGVtLmdldEF0dHJpYnV0ZSggZGF0YU9wdGlvbnNBdHRyICk7XG4gICAgICAgIHZhciBvcHRpb25zO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG9wdGlvbnMgPSBhdHRyICYmIEpTT04ucGFyc2UoIGF0dHIgKTtcbiAgICAgICAgfSBjYXRjaCAoIGVycm9yICkge1xuICAgICAgICAgIC8vIGxvZyBlcnJvciwgZG8gbm90IGluaXRpYWxpemVcbiAgICAgICAgICBpZiAoIGNvbnNvbGUgKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnRXJyb3IgcGFyc2luZyAnICsgZGF0YUF0dHIgKyAnIG9uICcgKyBlbGVtLmNsYXNzTmFtZSArXG4gICAgICAgICAgICAnOiAnICsgZXJyb3IgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluaXRpYWxpemVcbiAgICAgICAgdmFyIGluc3RhbmNlID0gbmV3IFdpZGdldENsYXNzKCBlbGVtLCBvcHRpb25zICk7XG4gICAgICAgIC8vIG1ha2UgYXZhaWxhYmxlIHZpYSAkKCkuZGF0YSgnbmFtZXNwYWNlJylcbiAgICAgICAgaWYgKCBqUXVlcnkgKSB7XG4gICAgICAgICAgalF1ZXJ5LmRhdGEoIGVsZW0sIG5hbWVzcGFjZSwgaW5zdGFuY2UgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIFxuICAgIH0pO1xuICB9O1xuICBcbiAgLy8gLS0tLS0gIC0tLS0tIC8vXG4gIFxuICByZXR1cm4gdXRpbHM7XG4gIFxuICB9KSk7XG4gIFxuICAvKipcbiAgICogT3V0bGF5ZXIgSXRlbVxuICAgKi9cbiAgXG4gICggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgICAvKiBqc2hpbnQgc3RyaWN0OiBmYWxzZSAqLyAvKiBnbG9iYWxzIGRlZmluZSwgbW9kdWxlLCByZXF1aXJlICovXG4gICAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAgIC8vIEFNRCAtIFJlcXVpcmVKU1xuICAgICAgZGVmaW5lKCAnb3V0bGF5ZXIvaXRlbScsW1xuICAgICAgICAgICdldi1lbWl0dGVyL2V2LWVtaXR0ZXInLFxuICAgICAgICAgICdnZXQtc2l6ZS9nZXQtc2l6ZSdcbiAgICAgICAgXSxcbiAgICAgICAgZmFjdG9yeVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgICAgLy8gQ29tbW9uSlMgLSBCcm93c2VyaWZ5LCBXZWJwYWNrXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXG4gICAgICAgIHJlcXVpcmUoJ2V2LWVtaXR0ZXInKSxcbiAgICAgICAgcmVxdWlyZSgnZ2V0LXNpemUnKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICAgIHdpbmRvdy5PdXRsYXllciA9IHt9O1xuICAgICAgd2luZG93Lk91dGxheWVyLkl0ZW0gPSBmYWN0b3J5KFxuICAgICAgICB3aW5kb3cuRXZFbWl0dGVyLFxuICAgICAgICB3aW5kb3cuZ2V0U2l6ZVxuICAgICAgKTtcbiAgICB9XG4gIFxuICB9KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIEV2RW1pdHRlciwgZ2V0U2l6ZSApIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICBcbiAgLy8gLS0tLS0gaGVscGVycyAtLS0tLSAvL1xuICBcbiAgZnVuY3Rpb24gaXNFbXB0eU9iaiggb2JqICkge1xuICAgIGZvciAoIHZhciBwcm9wIGluIG9iaiApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcHJvcCA9IG51bGw7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIENTUzMgc3VwcG9ydCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICBcbiAgXG4gIHZhciBkb2NFbGVtU3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG4gIFxuICB2YXIgdHJhbnNpdGlvblByb3BlcnR5ID0gdHlwZW9mIGRvY0VsZW1TdHlsZS50cmFuc2l0aW9uID09ICdzdHJpbmcnID9cbiAgICAndHJhbnNpdGlvbicgOiAnV2Via2l0VHJhbnNpdGlvbic7XG4gIHZhciB0cmFuc2Zvcm1Qcm9wZXJ0eSA9IHR5cGVvZiBkb2NFbGVtU3R5bGUudHJhbnNmb3JtID09ICdzdHJpbmcnID9cbiAgICAndHJhbnNmb3JtJyA6ICdXZWJraXRUcmFuc2Zvcm0nO1xuICBcbiAgdmFyIHRyYW5zaXRpb25FbmRFdmVudCA9IHtcbiAgICBXZWJraXRUcmFuc2l0aW9uOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgdHJhbnNpdGlvbjogJ3RyYW5zaXRpb25lbmQnXG4gIH1bIHRyYW5zaXRpb25Qcm9wZXJ0eSBdO1xuICBcbiAgLy8gY2FjaGUgYWxsIHZlbmRvciBwcm9wZXJ0aWVzIHRoYXQgY291bGQgaGF2ZSB2ZW5kb3IgcHJlZml4XG4gIHZhciB2ZW5kb3JQcm9wZXJ0aWVzID0ge1xuICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtUHJvcGVydHksXG4gICAgdHJhbnNpdGlvbjogdHJhbnNpdGlvblByb3BlcnR5LFxuICAgIHRyYW5zaXRpb25EdXJhdGlvbjogdHJhbnNpdGlvblByb3BlcnR5ICsgJ0R1cmF0aW9uJyxcbiAgICB0cmFuc2l0aW9uUHJvcGVydHk6IHRyYW5zaXRpb25Qcm9wZXJ0eSArICdQcm9wZXJ0eScsXG4gICAgdHJhbnNpdGlvbkRlbGF5OiB0cmFuc2l0aW9uUHJvcGVydHkgKyAnRGVsYXknXG4gIH07XG4gIFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBJdGVtIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG4gIFxuICBmdW5jdGlvbiBJdGVtKCBlbGVtZW50LCBsYXlvdXQgKSB7XG4gICAgaWYgKCAhZWxlbWVudCApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIFxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgLy8gcGFyZW50IGxheW91dCBjbGFzcywgaS5lLiBNYXNvbnJ5LCBJc290b3BlLCBvciBQYWNrZXJ5XG4gICAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgXG4gICAgdGhpcy5fY3JlYXRlKCk7XG4gIH1cbiAgXG4gIC8vIGluaGVyaXQgRXZFbWl0dGVyXG4gIHZhciBwcm90byA9IEl0ZW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZFbWl0dGVyLnByb3RvdHlwZSApO1xuICBwcm90by5jb25zdHJ1Y3RvciA9IEl0ZW07XG4gIFxuICBwcm90by5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gdHJhbnNpdGlvbiBvYmplY3RzXG4gICAgdGhpcy5fdHJhbnNuID0ge1xuICAgICAgaW5nUHJvcGVydGllczoge30sXG4gICAgICBjbGVhbjoge30sXG4gICAgICBvbkVuZDoge31cbiAgICB9O1xuICBcbiAgICB0aGlzLmNzcyh7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgIH0pO1xuICB9O1xuICBcbiAgLy8gdHJpZ2dlciBzcGVjaWZpZWQgaGFuZGxlciBmb3IgZXZlbnQgdHlwZVxuICBwcm90by5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICB2YXIgbWV0aG9kID0gJ29uJyArIGV2ZW50LnR5cGU7XG4gICAgaWYgKCB0aGlzWyBtZXRob2QgXSApIHtcbiAgICAgIHRoaXNbIG1ldGhvZCBdKCBldmVudCApO1xuICAgIH1cbiAgfTtcbiAgXG4gIHByb3RvLmdldFNpemUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNpemUgPSBnZXRTaXplKCB0aGlzLmVsZW1lbnQgKTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBhcHBseSBDU1Mgc3R5bGVzIHRvIGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAqL1xuICBwcm90by5jc3MgPSBmdW5jdGlvbiggc3R5bGUgKSB7XG4gICAgdmFyIGVsZW1TdHlsZSA9IHRoaXMuZWxlbWVudC5zdHlsZTtcbiAgXG4gICAgZm9yICggdmFyIHByb3AgaW4gc3R5bGUgKSB7XG4gICAgICAvLyB1c2UgdmVuZG9yIHByb3BlcnR5IGlmIGF2YWlsYWJsZVxuICAgICAgdmFyIHN1cHBvcnRlZFByb3AgPSB2ZW5kb3JQcm9wZXJ0aWVzWyBwcm9wIF0gfHwgcHJvcDtcbiAgICAgIGVsZW1TdHlsZVsgc3VwcG9ydGVkUHJvcCBdID0gc3R5bGVbIHByb3AgXTtcbiAgICB9XG4gIH07XG4gIFxuICAgLy8gbWVhc3VyZSBwb3NpdGlvbiwgYW5kIHNldHMgaXRcbiAgcHJvdG8uZ2V0UG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKCB0aGlzLmVsZW1lbnQgKTtcbiAgICB2YXIgaXNPcmlnaW5MZWZ0ID0gdGhpcy5sYXlvdXQuX2dldE9wdGlvbignb3JpZ2luTGVmdCcpO1xuICAgIHZhciBpc09yaWdpblRvcCA9IHRoaXMubGF5b3V0Ll9nZXRPcHRpb24oJ29yaWdpblRvcCcpO1xuICAgIHZhciB4VmFsdWUgPSBzdHlsZVsgaXNPcmlnaW5MZWZ0ID8gJ2xlZnQnIDogJ3JpZ2h0JyBdO1xuICAgIHZhciB5VmFsdWUgPSBzdHlsZVsgaXNPcmlnaW5Ub3AgPyAndG9wJyA6ICdib3R0b20nIF07XG4gICAgdmFyIHggPSBwYXJzZUZsb2F0KCB4VmFsdWUgKTtcbiAgICB2YXIgeSA9IHBhcnNlRmxvYXQoIHlWYWx1ZSApO1xuICAgIC8vIGNvbnZlcnQgcGVyY2VudCB0byBwaXhlbHNcbiAgICB2YXIgbGF5b3V0U2l6ZSA9IHRoaXMubGF5b3V0LnNpemU7XG4gICAgaWYgKCB4VmFsdWUuaW5kZXhPZignJScpICE9IC0xICkge1xuICAgICAgeCA9ICggeCAvIDEwMCApICogbGF5b3V0U2l6ZS53aWR0aDtcbiAgICB9XG4gICAgaWYgKCB5VmFsdWUuaW5kZXhPZignJScpICE9IC0xICkge1xuICAgICAgeSA9ICggeSAvIDEwMCApICogbGF5b3V0U2l6ZS5oZWlnaHQ7XG4gICAgfVxuICAgIC8vIGNsZWFuIHVwICdhdXRvJyBvciBvdGhlciBub24taW50ZWdlciB2YWx1ZXNcbiAgICB4ID0gaXNOYU4oIHggKSA/IDAgOiB4O1xuICAgIHkgPSBpc05hTiggeSApID8gMCA6IHk7XG4gICAgLy8gcmVtb3ZlIHBhZGRpbmcgZnJvbSBtZWFzdXJlbWVudFxuICAgIHggLT0gaXNPcmlnaW5MZWZ0ID8gbGF5b3V0U2l6ZS5wYWRkaW5nTGVmdCA6IGxheW91dFNpemUucGFkZGluZ1JpZ2h0O1xuICAgIHkgLT0gaXNPcmlnaW5Ub3AgPyBsYXlvdXRTaXplLnBhZGRpbmdUb3AgOiBsYXlvdXRTaXplLnBhZGRpbmdCb3R0b207XG4gIFxuICAgIHRoaXMucG9zaXRpb24ueCA9IHg7XG4gICAgdGhpcy5wb3NpdGlvbi55ID0geTtcbiAgfTtcbiAgXG4gIC8vIHNldCBzZXR0bGVkIHBvc2l0aW9uLCBhcHBseSBwYWRkaW5nXG4gIHByb3RvLmxheW91dFBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxheW91dFNpemUgPSB0aGlzLmxheW91dC5zaXplO1xuICAgIHZhciBzdHlsZSA9IHt9O1xuICAgIHZhciBpc09yaWdpbkxlZnQgPSB0aGlzLmxheW91dC5fZ2V0T3B0aW9uKCdvcmlnaW5MZWZ0Jyk7XG4gICAgdmFyIGlzT3JpZ2luVG9wID0gdGhpcy5sYXlvdXQuX2dldE9wdGlvbignb3JpZ2luVG9wJyk7XG4gIFxuICAgIC8vIHhcbiAgICB2YXIgeFBhZGRpbmcgPSBpc09yaWdpbkxlZnQgPyAncGFkZGluZ0xlZnQnIDogJ3BhZGRpbmdSaWdodCc7XG4gICAgdmFyIHhQcm9wZXJ0eSA9IGlzT3JpZ2luTGVmdCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgdmFyIHhSZXNldFByb3BlcnR5ID0gaXNPcmlnaW5MZWZ0ID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgXG4gICAgdmFyIHggPSB0aGlzLnBvc2l0aW9uLnggKyBsYXlvdXRTaXplWyB4UGFkZGluZyBdO1xuICAgIC8vIHNldCBpbiBwZXJjZW50YWdlIG9yIHBpeGVsc1xuICAgIHN0eWxlWyB4UHJvcGVydHkgXSA9IHRoaXMuZ2V0WFZhbHVlKCB4ICk7XG4gICAgLy8gcmVzZXQgb3RoZXIgcHJvcGVydHlcbiAgICBzdHlsZVsgeFJlc2V0UHJvcGVydHkgXSA9ICcnO1xuICBcbiAgICAvLyB5XG4gICAgdmFyIHlQYWRkaW5nID0gaXNPcmlnaW5Ub3AgPyAncGFkZGluZ1RvcCcgOiAncGFkZGluZ0JvdHRvbSc7XG4gICAgdmFyIHlQcm9wZXJ0eSA9IGlzT3JpZ2luVG9wID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICB2YXIgeVJlc2V0UHJvcGVydHkgPSBpc09yaWdpblRvcCA/ICdib3R0b20nIDogJ3RvcCc7XG4gIFxuICAgIHZhciB5ID0gdGhpcy5wb3NpdGlvbi55ICsgbGF5b3V0U2l6ZVsgeVBhZGRpbmcgXTtcbiAgICAvLyBzZXQgaW4gcGVyY2VudGFnZSBvciBwaXhlbHNcbiAgICBzdHlsZVsgeVByb3BlcnR5IF0gPSB0aGlzLmdldFlWYWx1ZSggeSApO1xuICAgIC8vIHJlc2V0IG90aGVyIHByb3BlcnR5XG4gICAgc3R5bGVbIHlSZXNldFByb3BlcnR5IF0gPSAnJztcbiAgXG4gICAgdGhpcy5jc3MoIHN0eWxlICk7XG4gICAgdGhpcy5lbWl0RXZlbnQoICdsYXlvdXQnLCBbIHRoaXMgXSApO1xuICB9O1xuICBcbiAgcHJvdG8uZ2V0WFZhbHVlID0gZnVuY3Rpb24oIHggKSB7XG4gICAgdmFyIGlzSG9yaXpvbnRhbCA9IHRoaXMubGF5b3V0Ll9nZXRPcHRpb24oJ2hvcml6b250YWwnKTtcbiAgICByZXR1cm4gdGhpcy5sYXlvdXQub3B0aW9ucy5wZXJjZW50UG9zaXRpb24gJiYgIWlzSG9yaXpvbnRhbCA/XG4gICAgICAoICggeCAvIHRoaXMubGF5b3V0LnNpemUud2lkdGggKSAqIDEwMCApICsgJyUnIDogeCArICdweCc7XG4gIH07XG4gIFxuICBwcm90by5nZXRZVmFsdWUgPSBmdW5jdGlvbiggeSApIHtcbiAgICB2YXIgaXNIb3Jpem9udGFsID0gdGhpcy5sYXlvdXQuX2dldE9wdGlvbignaG9yaXpvbnRhbCcpO1xuICAgIHJldHVybiB0aGlzLmxheW91dC5vcHRpb25zLnBlcmNlbnRQb3NpdGlvbiAmJiBpc0hvcml6b250YWwgP1xuICAgICAgKCAoIHkgLyB0aGlzLmxheW91dC5zaXplLmhlaWdodCApICogMTAwICkgKyAnJScgOiB5ICsgJ3B4JztcbiAgfTtcbiAgXG4gIHByb3RvLl90cmFuc2l0aW9uVG8gPSBmdW5jdGlvbiggeCwgeSApIHtcbiAgICB0aGlzLmdldFBvc2l0aW9uKCk7XG4gICAgLy8gZ2V0IGN1cnJlbnQgeCAmIHkgZnJvbSB0b3AvbGVmdFxuICAgIHZhciBjdXJYID0gdGhpcy5wb3NpdGlvbi54O1xuICAgIHZhciBjdXJZID0gdGhpcy5wb3NpdGlvbi55O1xuICBcbiAgICB2YXIgZGlkTm90TW92ZSA9IHggPT0gdGhpcy5wb3NpdGlvbi54ICYmIHkgPT0gdGhpcy5wb3NpdGlvbi55O1xuICBcbiAgICAvLyBzYXZlIGVuZCBwb3NpdGlvblxuICAgIHRoaXMuc2V0UG9zaXRpb24oIHgsIHkgKTtcbiAgXG4gICAgLy8gaWYgZGlkIG5vdCBtb3ZlIGFuZCBub3QgdHJhbnNpdGlvbmluZywganVzdCBnbyB0byBsYXlvdXRcbiAgICBpZiAoIGRpZE5vdE1vdmUgJiYgIXRoaXMuaXNUcmFuc2l0aW9uaW5nICkge1xuICAgICAgdGhpcy5sYXlvdXRQb3NpdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgXG4gICAgdmFyIHRyYW5zWCA9IHggLSBjdXJYO1xuICAgIHZhciB0cmFuc1kgPSB5IC0gY3VyWTtcbiAgICB2YXIgdHJhbnNpdGlvblN0eWxlID0ge307XG4gICAgdHJhbnNpdGlvblN0eWxlLnRyYW5zZm9ybSA9IHRoaXMuZ2V0VHJhbnNsYXRlKCB0cmFuc1gsIHRyYW5zWSApO1xuICBcbiAgICB0aGlzLnRyYW5zaXRpb24oe1xuICAgICAgdG86IHRyYW5zaXRpb25TdHlsZSxcbiAgICAgIG9uVHJhbnNpdGlvbkVuZDoge1xuICAgICAgICB0cmFuc2Zvcm06IHRoaXMubGF5b3V0UG9zaXRpb25cbiAgICAgIH0sXG4gICAgICBpc0NsZWFuaW5nOiB0cnVlXG4gICAgfSk7XG4gIH07XG4gIFxuICBwcm90by5nZXRUcmFuc2xhdGUgPSBmdW5jdGlvbiggeCwgeSApIHtcbiAgICAvLyBmbGlwIGNvb3JpZGluYXRlcyBpZiBvcmlnaW4gb24gcmlnaHQgb3IgYm90dG9tXG4gICAgdmFyIGlzT3JpZ2luTGVmdCA9IHRoaXMubGF5b3V0Ll9nZXRPcHRpb24oJ29yaWdpbkxlZnQnKTtcbiAgICB2YXIgaXNPcmlnaW5Ub3AgPSB0aGlzLmxheW91dC5fZ2V0T3B0aW9uKCdvcmlnaW5Ub3AnKTtcbiAgICB4ID0gaXNPcmlnaW5MZWZ0ID8geCA6IC14O1xuICAgIHkgPSBpc09yaWdpblRvcCA/IHkgOiAteTtcbiAgICByZXR1cm4gJ3RyYW5zbGF0ZTNkKCcgKyB4ICsgJ3B4LCAnICsgeSArICdweCwgMCknO1xuICB9O1xuICBcbiAgLy8gbm9uIHRyYW5zaXRpb24gKyB0cmFuc2Zvcm0gc3VwcG9ydFxuICBwcm90by5nb1RvID0gZnVuY3Rpb24oIHgsIHkgKSB7XG4gICAgdGhpcy5zZXRQb3NpdGlvbiggeCwgeSApO1xuICAgIHRoaXMubGF5b3V0UG9zaXRpb24oKTtcbiAgfTtcbiAgXG4gIHByb3RvLm1vdmVUbyA9IHByb3RvLl90cmFuc2l0aW9uVG87XG4gIFxuICBwcm90by5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCB4LCB5ICkge1xuICAgIHRoaXMucG9zaXRpb24ueCA9IHBhcnNlRmxvYXQoIHggKTtcbiAgICB0aGlzLnBvc2l0aW9uLnkgPSBwYXJzZUZsb2F0KCB5ICk7XG4gIH07XG4gIFxuICAvLyAtLS0tLSB0cmFuc2l0aW9uIC0tLS0tIC8vXG4gIFxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlIC0gQ1NTXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uVHJhbnNpdGlvbkVuZFxuICAgKi9cbiAgXG4gIC8vIG5vbiB0cmFuc2l0aW9uLCBqdXN0IHRyaWdnZXIgY2FsbGJhY2tcbiAgcHJvdG8uX25vblRyYW5zaXRpb24gPSBmdW5jdGlvbiggYXJncyApIHtcbiAgICB0aGlzLmNzcyggYXJncy50byApO1xuICAgIGlmICggYXJncy5pc0NsZWFuaW5nICkge1xuICAgICAgdGhpcy5fcmVtb3ZlU3R5bGVzKCBhcmdzLnRvICk7XG4gICAgfVxuICAgIGZvciAoIHZhciBwcm9wIGluIGFyZ3Mub25UcmFuc2l0aW9uRW5kICkge1xuICAgICAgYXJncy5vblRyYW5zaXRpb25FbmRbIHByb3AgXS5jYWxsKCB0aGlzICk7XG4gICAgfVxuICB9O1xuICBcbiAgLyoqXG4gICAqIHByb3BlciB0cmFuc2l0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIC0gYXJndW1lbnRzXG4gICAqICAgQHBhcmFtIHtPYmplY3R9IHRvIC0gc3R5bGUgdG8gdHJhbnNpdGlvbiB0b1xuICAgKiAgIEBwYXJhbSB7T2JqZWN0fSBmcm9tIC0gc3R5bGUgdG8gc3RhcnQgdHJhbnNpdGlvbiBmcm9tXG4gICAqICAgQHBhcmFtIHtCb29sZWFufSBpc0NsZWFuaW5nIC0gcmVtb3ZlcyB0cmFuc2l0aW9uIHN0eWxlcyBhZnRlciB0cmFuc2l0aW9uXG4gICAqICAgQHBhcmFtIHtGdW5jdGlvbn0gb25UcmFuc2l0aW9uRW5kIC0gY2FsbGJhY2tcbiAgICovXG4gIHByb3RvLnRyYW5zaXRpb24gPSBmdW5jdGlvbiggYXJncyApIHtcbiAgICAvLyByZWRpcmVjdCB0byBub25UcmFuc2l0aW9uIGlmIG5vIHRyYW5zaXRpb24gZHVyYXRpb25cbiAgICBpZiAoICFwYXJzZUZsb2F0KCB0aGlzLmxheW91dC5vcHRpb25zLnRyYW5zaXRpb25EdXJhdGlvbiApICkge1xuICAgICAgdGhpcy5fbm9uVHJhbnNpdGlvbiggYXJncyApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgXG4gICAgdmFyIF90cmFuc2l0aW9uID0gdGhpcy5fdHJhbnNuO1xuICAgIC8vIGtlZXAgdHJhY2sgb2Ygb25UcmFuc2l0aW9uRW5kIGNhbGxiYWNrIGJ5IGNzcyBwcm9wZXJ0eVxuICAgIGZvciAoIHZhciBwcm9wIGluIGFyZ3Mub25UcmFuc2l0aW9uRW5kICkge1xuICAgICAgX3RyYW5zaXRpb24ub25FbmRbIHByb3AgXSA9IGFyZ3Mub25UcmFuc2l0aW9uRW5kWyBwcm9wIF07XG4gICAgfVxuICAgIC8vIGtlZXAgdHJhY2sgb2YgcHJvcGVydGllcyB0aGF0IGFyZSB0cmFuc2l0aW9uaW5nXG4gICAgZm9yICggcHJvcCBpbiBhcmdzLnRvICkge1xuICAgICAgX3RyYW5zaXRpb24uaW5nUHJvcGVydGllc1sgcHJvcCBdID0gdHJ1ZTtcbiAgICAgIC8vIGtlZXAgdHJhY2sgb2YgcHJvcGVydGllcyB0byBjbGVhbiB1cCB3aGVuIHRyYW5zaXRpb24gaXMgZG9uZVxuICAgICAgaWYgKCBhcmdzLmlzQ2xlYW5pbmcgKSB7XG4gICAgICAgIF90cmFuc2l0aW9uLmNsZWFuWyBwcm9wIF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgXG4gICAgLy8gc2V0IGZyb20gc3R5bGVzXG4gICAgaWYgKCBhcmdzLmZyb20gKSB7XG4gICAgICB0aGlzLmNzcyggYXJncy5mcm9tICk7XG4gICAgICAvLyBmb3JjZSByZWRyYXcuIGh0dHA6Ly9ibG9nLmFsZXhtYWNjYXcuY29tL2Nzcy10cmFuc2l0aW9uc1xuICAgICAgdmFyIGggPSB0aGlzLmVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgLy8gaGFjayBmb3IgSlNIaW50IHRvIGh1c2ggYWJvdXQgdW51c2VkIHZhclxuICAgICAgaCA9IG51bGw7XG4gICAgfVxuICAgIC8vIGVuYWJsZSB0cmFuc2l0aW9uXG4gICAgdGhpcy5lbmFibGVUcmFuc2l0aW9uKCBhcmdzLnRvICk7XG4gICAgLy8gc2V0IHN0eWxlcyB0aGF0IGFyZSB0cmFuc2l0aW9uaW5nXG4gICAgdGhpcy5jc3MoIGFyZ3MudG8gKTtcbiAgXG4gICAgdGhpcy5pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuICBcbiAgfTtcbiAgXG4gIC8vIGRhc2ggYmVmb3JlIGFsbCBjYXAgbGV0dGVycywgaW5jbHVkaW5nIGZpcnN0IGZvclxuICAvLyBXZWJraXRUcmFuc2Zvcm0gPT4gLXdlYmtpdC10cmFuc2Zvcm1cbiAgZnVuY3Rpb24gdG9EYXNoZWRBbGwoIHN0ciApIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoIC8oW0EtWl0pL2csIGZ1bmN0aW9uKCAkMSApIHtcbiAgICAgIHJldHVybiAnLScgKyAkMS50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuICB9XG4gIFxuICB2YXIgdHJhbnNpdGlvblByb3BzID0gJ29wYWNpdHksJyArIHRvRGFzaGVkQWxsKCB0cmFuc2Zvcm1Qcm9wZXJ0eSApO1xuICBcbiAgcHJvdG8uZW5hYmxlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKC8qIHN0eWxlICovKSB7XG4gICAgLy8gSEFDSyBjaGFuZ2luZyB0cmFuc2l0aW9uUHJvcGVydHkgZHVyaW5nIGEgdHJhbnNpdGlvblxuICAgIC8vIHdpbGwgY2F1c2UgdHJhbnNpdGlvbiB0byBqdW1wXG4gICAgaWYgKCB0aGlzLmlzVHJhbnNpdGlvbmluZyApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIFxuICAgIC8vIG1ha2UgYHRyYW5zaXRpb246IGZvbywgYmFyLCBiYXpgIGZyb20gc3R5bGUgb2JqZWN0XG4gICAgLy8gSEFDSyB1bi1jb21tZW50IHRoaXMgd2hlbiBlbmFibGVUcmFuc2l0aW9uIGNhbiB3b3JrXG4gICAgLy8gd2hpbGUgYSB0cmFuc2l0aW9uIGlzIGhhcHBlbmluZ1xuICAgIC8vIHZhciB0cmFuc2l0aW9uVmFsdWVzID0gW107XG4gICAgLy8gZm9yICggdmFyIHByb3AgaW4gc3R5bGUgKSB7XG4gICAgLy8gICAvLyBkYXNoLWlmeSBjYW1lbENhc2VkIHByb3BlcnRpZXMgbGlrZSBXZWJraXRUcmFuc2l0aW9uXG4gICAgLy8gICBwcm9wID0gdmVuZG9yUHJvcGVydGllc1sgcHJvcCBdIHx8IHByb3A7XG4gICAgLy8gICB0cmFuc2l0aW9uVmFsdWVzLnB1c2goIHRvRGFzaGVkQWxsKCBwcm9wICkgKTtcbiAgICAvLyB9XG4gICAgLy8gbXVuZ2UgbnVtYmVyIHRvIG1pbGxpc2Vjb25kLCB0byBtYXRjaCBzdGFnZ2VyXG4gICAgdmFyIGR1cmF0aW9uID0gdGhpcy5sYXlvdXQub3B0aW9ucy50cmFuc2l0aW9uRHVyYXRpb247XG4gICAgZHVyYXRpb24gPSB0eXBlb2YgZHVyYXRpb24gPT0gJ251bWJlcicgPyBkdXJhdGlvbiArICdtcycgOiBkdXJhdGlvbjtcbiAgICAvLyBlbmFibGUgdHJhbnNpdGlvbiBzdHlsZXNcbiAgICB0aGlzLmNzcyh7XG4gICAgICB0cmFuc2l0aW9uUHJvcGVydHk6IHRyYW5zaXRpb25Qcm9wcyxcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICB0cmFuc2l0aW9uRGVsYXk6IHRoaXMuc3RhZ2dlckRlbGF5IHx8IDBcbiAgICB9KTtcbiAgICAvLyBsaXN0ZW4gZm9yIHRyYW5zaXRpb24gZW5kIGV2ZW50XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoIHRyYW5zaXRpb25FbmRFdmVudCwgdGhpcywgZmFsc2UgKTtcbiAgfTtcbiAgXG4gIC8vIC0tLS0tIGV2ZW50cyAtLS0tLSAvL1xuICBcbiAgcHJvdG8ub253ZWJraXRUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICAgIHRoaXMub250cmFuc2l0aW9uZW5kKCBldmVudCApO1xuICB9O1xuICBcbiAgcHJvdG8ub25vdHJhbnNpdGlvbmVuZCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICB0aGlzLm9udHJhbnNpdGlvbmVuZCggZXZlbnQgKTtcbiAgfTtcbiAgXG4gIC8vIHByb3BlcnRpZXMgdGhhdCBJIG11bmdlIHRvIG1ha2UgbXkgbGlmZSBlYXNpZXJcbiAgdmFyIGRhc2hlZFZlbmRvclByb3BlcnRpZXMgPSB7XG4gICAgJy13ZWJraXQtdHJhbnNmb3JtJzogJ3RyYW5zZm9ybSdcbiAgfTtcbiAgXG4gIHByb3RvLm9udHJhbnNpdGlvbmVuZCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAvLyBkaXNyZWdhcmQgYnViYmxlZCBldmVudHMgZnJvbSBjaGlsZHJlblxuICAgIGlmICggZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmVsZW1lbnQgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBfdHJhbnNpdGlvbiA9IHRoaXMuX3RyYW5zbjtcbiAgICAvLyBnZXQgcHJvcGVydHkgbmFtZSBvZiB0cmFuc2l0aW9uZWQgcHJvcGVydHksIGNvbnZlcnQgdG8gcHJlZml4LWZyZWVcbiAgICB2YXIgcHJvcGVydHlOYW1lID0gZGFzaGVkVmVuZG9yUHJvcGVydGllc1sgZXZlbnQucHJvcGVydHlOYW1lIF0gfHwgZXZlbnQucHJvcGVydHlOYW1lO1xuICBcbiAgICAvLyByZW1vdmUgcHJvcGVydHkgdGhhdCBoYXMgY29tcGxldGVkIHRyYW5zaXRpb25pbmdcbiAgICBkZWxldGUgX3RyYW5zaXRpb24uaW5nUHJvcGVydGllc1sgcHJvcGVydHlOYW1lIF07XG4gICAgLy8gY2hlY2sgaWYgYW55IHByb3BlcnRpZXMgYXJlIHN0aWxsIHRyYW5zaXRpb25pbmdcbiAgICBpZiAoIGlzRW1wdHlPYmooIF90cmFuc2l0aW9uLmluZ1Byb3BlcnRpZXMgKSApIHtcbiAgICAgIC8vIGFsbCBwcm9wZXJ0aWVzIGhhdmUgY29tcGxldGVkIHRyYW5zaXRpb25pbmdcbiAgICAgIHRoaXMuZGlzYWJsZVRyYW5zaXRpb24oKTtcbiAgICB9XG4gICAgLy8gY2xlYW4gc3R5bGVcbiAgICBpZiAoIHByb3BlcnR5TmFtZSBpbiBfdHJhbnNpdGlvbi5jbGVhbiApIHtcbiAgICAgIC8vIGNsZWFuIHVwIHN0eWxlXG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGVbIGV2ZW50LnByb3BlcnR5TmFtZSBdID0gJyc7XG4gICAgICBkZWxldGUgX3RyYW5zaXRpb24uY2xlYW5bIHByb3BlcnR5TmFtZSBdO1xuICAgIH1cbiAgICAvLyB0cmlnZ2VyIG9uVHJhbnNpdGlvbkVuZCBjYWxsYmFja1xuICAgIGlmICggcHJvcGVydHlOYW1lIGluIF90cmFuc2l0aW9uLm9uRW5kICkge1xuICAgICAgdmFyIG9uVHJhbnNpdGlvbkVuZCA9IF90cmFuc2l0aW9uLm9uRW5kWyBwcm9wZXJ0eU5hbWUgXTtcbiAgICAgIG9uVHJhbnNpdGlvbkVuZC5jYWxsKCB0aGlzICk7XG4gICAgICBkZWxldGUgX3RyYW5zaXRpb24ub25FbmRbIHByb3BlcnR5TmFtZSBdO1xuICAgIH1cbiAgXG4gICAgdGhpcy5lbWl0RXZlbnQoICd0cmFuc2l0aW9uRW5kJywgWyB0aGlzIF0gKTtcbiAgfTtcbiAgXG4gIHByb3RvLmRpc2FibGVUcmFuc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVUcmFuc2l0aW9uU3R5bGVzKCk7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIHRyYW5zaXRpb25FbmRFdmVudCwgdGhpcywgZmFsc2UgKTtcbiAgICB0aGlzLmlzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIHJlbW92ZXMgc3R5bGUgcHJvcGVydHkgZnJvbSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICAqKi9cbiAgcHJvdG8uX3JlbW92ZVN0eWxlcyA9IGZ1bmN0aW9uKCBzdHlsZSApIHtcbiAgICAvLyBjbGVhbiB1cCB0cmFuc2l0aW9uIHN0eWxlc1xuICAgIHZhciBjbGVhblN0eWxlID0ge307XG4gICAgZm9yICggdmFyIHByb3AgaW4gc3R5bGUgKSB7XG4gICAgICBjbGVhblN0eWxlWyBwcm9wIF0gPSAnJztcbiAgICB9XG4gICAgdGhpcy5jc3MoIGNsZWFuU3R5bGUgKTtcbiAgfTtcbiAgXG4gIHZhciBjbGVhblRyYW5zaXRpb25TdHlsZSA9IHtcbiAgICB0cmFuc2l0aW9uUHJvcGVydHk6ICcnLFxuICAgIHRyYW5zaXRpb25EdXJhdGlvbjogJycsXG4gICAgdHJhbnNpdGlvbkRlbGF5OiAnJ1xuICB9O1xuICBcbiAgcHJvdG8ucmVtb3ZlVHJhbnNpdGlvblN0eWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHJlbW92ZSB0cmFuc2l0aW9uXG4gICAgdGhpcy5jc3MoIGNsZWFuVHJhbnNpdGlvblN0eWxlICk7XG4gIH07XG4gIFxuICAvLyAtLS0tLSBzdGFnZ2VyIC0tLS0tIC8vXG4gIFxuICBwcm90by5zdGFnZ2VyID0gZnVuY3Rpb24oIGRlbGF5ICkge1xuICAgIGRlbGF5ID0gaXNOYU4oIGRlbGF5ICkgPyAwIDogZGVsYXk7XG4gICAgdGhpcy5zdGFnZ2VyRGVsYXkgPSBkZWxheSArICdtcyc7XG4gIH07XG4gIFxuICAvLyAtLS0tLSBzaG93L2hpZGUvcmVtb3ZlIC0tLS0tIC8vXG4gIFxuICAvLyByZW1vdmUgZWxlbWVudCBmcm9tIERPTVxuICBwcm90by5yZW1vdmVFbGVtID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRoaXMuZWxlbWVudCApO1xuICAgIC8vIHJlbW92ZSBkaXNwbGF5OiBub25lXG4gICAgdGhpcy5jc3MoeyBkaXNwbGF5OiAnJyB9KTtcbiAgICB0aGlzLmVtaXRFdmVudCggJ3JlbW92ZScsIFsgdGhpcyBdICk7XG4gIH07XG4gIFxuICBwcm90by5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBqdXN0IHJlbW92ZSBlbGVtZW50IGlmIG5vIHRyYW5zaXRpb24gc3VwcG9ydCBvciBubyB0cmFuc2l0aW9uXG4gICAgaWYgKCAhdHJhbnNpdGlvblByb3BlcnR5IHx8ICFwYXJzZUZsb2F0KCB0aGlzLmxheW91dC5vcHRpb25zLnRyYW5zaXRpb25EdXJhdGlvbiApICkge1xuICAgICAgdGhpcy5yZW1vdmVFbGVtKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICBcbiAgICAvLyBzdGFydCB0cmFuc2l0aW9uXG4gICAgdGhpcy5vbmNlKCAndHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yZW1vdmVFbGVtKCk7XG4gICAgfSk7XG4gICAgdGhpcy5oaWRlKCk7XG4gIH07XG4gIFxuICBwcm90by5yZXZlYWwgPSBmdW5jdGlvbigpIHtcbiAgICBkZWxldGUgdGhpcy5pc0hpZGRlbjtcbiAgICAvLyByZW1vdmUgZGlzcGxheTogbm9uZVxuICAgIHRoaXMuY3NzKHsgZGlzcGxheTogJycgfSk7XG4gIFxuICAgIHZhciBvcHRpb25zID0gdGhpcy5sYXlvdXQub3B0aW9ucztcbiAgXG4gICAgdmFyIG9uVHJhbnNpdGlvbkVuZCA9IHt9O1xuICAgIHZhciB0cmFuc2l0aW9uRW5kUHJvcGVydHkgPSB0aGlzLmdldEhpZGVSZXZlYWxUcmFuc2l0aW9uRW5kUHJvcGVydHkoJ3Zpc2libGVTdHlsZScpO1xuICAgIG9uVHJhbnNpdGlvbkVuZFsgdHJhbnNpdGlvbkVuZFByb3BlcnR5IF0gPSB0aGlzLm9uUmV2ZWFsVHJhbnNpdGlvbkVuZDtcbiAgXG4gICAgdGhpcy50cmFuc2l0aW9uKHtcbiAgICAgIGZyb206IG9wdGlvbnMuaGlkZGVuU3R5bGUsXG4gICAgICB0bzogb3B0aW9ucy52aXNpYmxlU3R5bGUsXG4gICAgICBpc0NsZWFuaW5nOiB0cnVlLFxuICAgICAgb25UcmFuc2l0aW9uRW5kOiBvblRyYW5zaXRpb25FbmRcbiAgICB9KTtcbiAgfTtcbiAgXG4gIHByb3RvLm9uUmV2ZWFsVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGNoZWNrIGlmIHN0aWxsIHZpc2libGVcbiAgICAvLyBkdXJpbmcgdHJhbnNpdGlvbiwgaXRlbSBtYXkgaGF2ZSBiZWVuIGhpZGRlblxuICAgIGlmICggIXRoaXMuaXNIaWRkZW4gKSB7XG4gICAgICB0aGlzLmVtaXRFdmVudCgncmV2ZWFsJyk7XG4gICAgfVxuICB9O1xuICBcbiAgLyoqXG4gICAqIGdldCBzdHlsZSBwcm9wZXJ0eSB1c2UgZm9yIGhpZGUvcmV2ZWFsIHRyYW5zaXRpb24gZW5kXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHlsZVByb3BlcnR5IC0gaGlkZGVuU3R5bGUvdmlzaWJsZVN0eWxlXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICBwcm90by5nZXRIaWRlUmV2ZWFsVHJhbnNpdGlvbkVuZFByb3BlcnR5ID0gZnVuY3Rpb24oIHN0eWxlUHJvcGVydHkgKSB7XG4gICAgdmFyIG9wdGlvblN0eWxlID0gdGhpcy5sYXlvdXQub3B0aW9uc1sgc3R5bGVQcm9wZXJ0eSBdO1xuICAgIC8vIHVzZSBvcGFjaXR5XG4gICAgaWYgKCBvcHRpb25TdHlsZS5vcGFjaXR5ICkge1xuICAgICAgcmV0dXJuICdvcGFjaXR5JztcbiAgICB9XG4gICAgLy8gZ2V0IGZpcnN0IHByb3BlcnR5XG4gICAgZm9yICggdmFyIHByb3AgaW4gb3B0aW9uU3R5bGUgKSB7XG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9XG4gIH07XG4gIFxuICBwcm90by5oaWRlID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gc2V0IGZsYWdcbiAgICB0aGlzLmlzSGlkZGVuID0gdHJ1ZTtcbiAgICAvLyByZW1vdmUgZGlzcGxheTogbm9uZVxuICAgIHRoaXMuY3NzKHsgZGlzcGxheTogJycgfSk7XG4gIFxuICAgIHZhciBvcHRpb25zID0gdGhpcy5sYXlvdXQub3B0aW9ucztcbiAgXG4gICAgdmFyIG9uVHJhbnNpdGlvbkVuZCA9IHt9O1xuICAgIHZhciB0cmFuc2l0aW9uRW5kUHJvcGVydHkgPSB0aGlzLmdldEhpZGVSZXZlYWxUcmFuc2l0aW9uRW5kUHJvcGVydHkoJ2hpZGRlblN0eWxlJyk7XG4gICAgb25UcmFuc2l0aW9uRW5kWyB0cmFuc2l0aW9uRW5kUHJvcGVydHkgXSA9IHRoaXMub25IaWRlVHJhbnNpdGlvbkVuZDtcbiAgXG4gICAgdGhpcy50cmFuc2l0aW9uKHtcbiAgICAgIGZyb206IG9wdGlvbnMudmlzaWJsZVN0eWxlLFxuICAgICAgdG86IG9wdGlvbnMuaGlkZGVuU3R5bGUsXG4gICAgICAvLyBrZWVwIGhpZGRlbiBzdHVmZiBoaWRkZW5cbiAgICAgIGlzQ2xlYW5pbmc6IHRydWUsXG4gICAgICBvblRyYW5zaXRpb25FbmQ6IG9uVHJhbnNpdGlvbkVuZFxuICAgIH0pO1xuICB9O1xuICBcbiAgcHJvdG8ub25IaWRlVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGNoZWNrIGlmIHN0aWxsIGhpZGRlblxuICAgIC8vIGR1cmluZyB0cmFuc2l0aW9uLCBpdGVtIG1heSBoYXZlIGJlZW4gdW4taGlkZGVuXG4gICAgaWYgKCB0aGlzLmlzSGlkZGVuICkge1xuICAgICAgdGhpcy5jc3MoeyBkaXNwbGF5OiAnbm9uZScgfSk7XG4gICAgICB0aGlzLmVtaXRFdmVudCgnaGlkZScpO1xuICAgIH1cbiAgfTtcbiAgXG4gIHByb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNzcyh7XG4gICAgICBwb3NpdGlvbjogJycsXG4gICAgICBsZWZ0OiAnJyxcbiAgICAgIHJpZ2h0OiAnJyxcbiAgICAgIHRvcDogJycsXG4gICAgICBib3R0b206ICcnLFxuICAgICAgdHJhbnNpdGlvbjogJycsXG4gICAgICB0cmFuc2Zvcm06ICcnXG4gICAgfSk7XG4gIH07XG4gIFxuICByZXR1cm4gSXRlbTtcbiAgXG4gIH0pKTtcbiAgXG4gIC8qIVxuICAgKiBPdXRsYXllciB2Mi4xLjFcbiAgICogdGhlIGJyYWlucyBhbmQgZ3V0cyBvZiBhIGxheW91dCBsaWJyYXJ5XG4gICAqIE1JVCBsaWNlbnNlXG4gICAqL1xuICBcbiAgKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgICAvKiBqc2hpbnQgc3RyaWN0OiBmYWxzZSAqLyAvKiBnbG9iYWxzIGRlZmluZSwgbW9kdWxlLCByZXF1aXJlICovXG4gICAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAgIC8vIEFNRCAtIFJlcXVpcmVKU1xuICAgICAgZGVmaW5lKCAnb3V0bGF5ZXIvb3V0bGF5ZXInLFtcbiAgICAgICAgICAnZXYtZW1pdHRlci9ldi1lbWl0dGVyJyxcbiAgICAgICAgICAnZ2V0LXNpemUvZ2V0LXNpemUnLFxuICAgICAgICAgICdmaXp6eS11aS11dGlscy91dGlscycsXG4gICAgICAgICAgJy4vaXRlbSdcbiAgICAgICAgXSxcbiAgICAgICAgZnVuY3Rpb24oIEV2RW1pdHRlciwgZ2V0U2l6ZSwgdXRpbHMsIEl0ZW0gKSB7XG4gICAgICAgICAgcmV0dXJuIGZhY3RvcnkoIHdpbmRvdywgRXZFbWl0dGVyLCBnZXRTaXplLCB1dGlscywgSXRlbSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAgIC8vIENvbW1vbkpTIC0gQnJvd3NlcmlmeSwgV2VicGFja1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICAgICAgICB3aW5kb3csXG4gICAgICAgIHJlcXVpcmUoJ2V2LWVtaXR0ZXInKSxcbiAgICAgICAgcmVxdWlyZSgnZ2V0LXNpemUnKSxcbiAgICAgICAgcmVxdWlyZSgnZml6enktdWktdXRpbHMnKSxcbiAgICAgICAgcmVxdWlyZSgnLi9pdGVtJylcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgICB3aW5kb3cuT3V0bGF5ZXIgPSBmYWN0b3J5KFxuICAgICAgICB3aW5kb3csXG4gICAgICAgIHdpbmRvdy5FdkVtaXR0ZXIsXG4gICAgICAgIHdpbmRvdy5nZXRTaXplLFxuICAgICAgICB3aW5kb3cuZml6enlVSVV0aWxzLFxuICAgICAgICB3aW5kb3cuT3V0bGF5ZXIuSXRlbVxuICAgICAgKTtcbiAgICB9XG4gIFxuICB9KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgRXZFbWl0dGVyLCBnZXRTaXplLCB1dGlscywgSXRlbSApIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICBcbiAgLy8gLS0tLS0gdmFycyAtLS0tLSAvL1xuICBcbiAgdmFyIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZTtcbiAgdmFyIGpRdWVyeSA9IHdpbmRvdy5qUXVlcnk7XG4gIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcbiAgXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIE91dGxheWVyIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG4gIFxuICAvLyBnbG9iYWxseSB1bmlxdWUgaWRlbnRpZmllcnNcbiAgdmFyIEdVSUQgPSAwO1xuICAvLyBpbnRlcm5hbCBzdG9yZSBvZiBhbGwgT3V0bGF5ZXIgaW50YW5jZXNcbiAgdmFyIGluc3RhbmNlcyA9IHt9O1xuICBcbiAgXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnQsIFN0cmluZ30gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIE91dGxheWVyKCBlbGVtZW50LCBvcHRpb25zICkge1xuICAgIHZhciBxdWVyeUVsZW1lbnQgPSB1dGlscy5nZXRRdWVyeUVsZW1lbnQoIGVsZW1lbnQgKTtcbiAgICBpZiAoICFxdWVyeUVsZW1lbnQgKSB7XG4gICAgICBpZiAoIGNvbnNvbGUgKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdCYWQgZWxlbWVudCBmb3IgJyArIHRoaXMuY29uc3RydWN0b3IubmFtZXNwYWNlICtcbiAgICAgICAgICAnOiAnICsgKCBxdWVyeUVsZW1lbnQgfHwgZWxlbWVudCApICk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudCA9IHF1ZXJ5RWxlbWVudDtcbiAgICAvLyBhZGQgalF1ZXJ5XG4gICAgaWYgKCBqUXVlcnkgKSB7XG4gICAgICB0aGlzLiRlbGVtZW50ID0galF1ZXJ5KCB0aGlzLmVsZW1lbnQgKTtcbiAgICB9XG4gIFxuICAgIC8vIG9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMgPSB1dGlscy5leHRlbmQoIHt9LCB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRzICk7XG4gICAgdGhpcy5vcHRpb24oIG9wdGlvbnMgKTtcbiAgXG4gICAgLy8gYWRkIGlkIGZvciBPdXRsYXllci5nZXRGcm9tRWxlbWVudFxuICAgIHZhciBpZCA9ICsrR1VJRDtcbiAgICB0aGlzLmVsZW1lbnQub3V0bGF5ZXJHVUlEID0gaWQ7IC8vIGV4cGFuZG9cbiAgICBpbnN0YW5jZXNbIGlkIF0gPSB0aGlzOyAvLyBhc3NvY2lhdGUgdmlhIGlkXG4gIFxuICAgIC8vIGtpY2sgaXQgb2ZmXG4gICAgdGhpcy5fY3JlYXRlKCk7XG4gIFxuICAgIHZhciBpc0luaXRMYXlvdXQgPSB0aGlzLl9nZXRPcHRpb24oJ2luaXRMYXlvdXQnKTtcbiAgICBpZiAoIGlzSW5pdExheW91dCApIHtcbiAgICAgIHRoaXMubGF5b3V0KCk7XG4gICAgfVxuICB9XG4gIFxuICAvLyBzZXR0aW5ncyBhcmUgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gIE91dGxheWVyLm5hbWVzcGFjZSA9ICdvdXRsYXllcic7XG4gIE91dGxheWVyLkl0ZW0gPSBJdGVtO1xuICBcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIE91dGxheWVyLmRlZmF1bHRzID0ge1xuICAgIGNvbnRhaW5lclN0eWxlOiB7XG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgIH0sXG4gICAgaW5pdExheW91dDogdHJ1ZSxcbiAgICBvcmlnaW5MZWZ0OiB0cnVlLFxuICAgIG9yaWdpblRvcDogdHJ1ZSxcbiAgICByZXNpemU6IHRydWUsXG4gICAgcmVzaXplQ29udGFpbmVyOiB0cnVlLFxuICAgIC8vIGl0ZW0gb3B0aW9uc1xuICAgIHRyYW5zaXRpb25EdXJhdGlvbjogJzAuNHMnLFxuICAgIGhpZGRlblN0eWxlOiB7XG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMC4wMDEpJ1xuICAgIH0sXG4gICAgdmlzaWJsZVN0eWxlOiB7XG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMSknXG4gICAgfVxuICB9O1xuICBcbiAgdmFyIHByb3RvID0gT3V0bGF5ZXIucHJvdG90eXBlO1xuICAvLyBpbmhlcml0IEV2RW1pdHRlclxuICB1dGlscy5leHRlbmQoIHByb3RvLCBFdkVtaXR0ZXIucHJvdG90eXBlICk7XG4gIFxuICAvKipcbiAgICogc2V0IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICovXG4gIHByb3RvLm9wdGlvbiA9IGZ1bmN0aW9uKCBvcHRzICkge1xuICAgIHV0aWxzLmV4dGVuZCggdGhpcy5vcHRpb25zLCBvcHRzICk7XG4gIH07XG4gIFxuICAvKipcbiAgICogZ2V0IGJhY2t3YXJkcyBjb21wYXRpYmxlIG9wdGlvbiB2YWx1ZSwgY2hlY2sgb2xkIG5hbWVcbiAgICovXG4gIHByb3RvLl9nZXRPcHRpb24gPSBmdW5jdGlvbiggb3B0aW9uICkge1xuICAgIHZhciBvbGRPcHRpb24gPSB0aGlzLmNvbnN0cnVjdG9yLmNvbXBhdE9wdGlvbnNbIG9wdGlvbiBdO1xuICAgIHJldHVybiBvbGRPcHRpb24gJiYgdGhpcy5vcHRpb25zWyBvbGRPcHRpb24gXSAhPT0gdW5kZWZpbmVkID9cbiAgICAgIHRoaXMub3B0aW9uc1sgb2xkT3B0aW9uIF0gOiB0aGlzLm9wdGlvbnNbIG9wdGlvbiBdO1xuICB9O1xuICBcbiAgT3V0bGF5ZXIuY29tcGF0T3B0aW9ucyA9IHtcbiAgICAvLyBjdXJyZW50TmFtZTogb2xkTmFtZVxuICAgIGluaXRMYXlvdXQ6ICdpc0luaXRMYXlvdXQnLFxuICAgIGhvcml6b250YWw6ICdpc0hvcml6b250YWwnLFxuICAgIGxheW91dEluc3RhbnQ6ICdpc0xheW91dEluc3RhbnQnLFxuICAgIG9yaWdpbkxlZnQ6ICdpc09yaWdpbkxlZnQnLFxuICAgIG9yaWdpblRvcDogJ2lzT3JpZ2luVG9wJyxcbiAgICByZXNpemU6ICdpc1Jlc2l6ZUJvdW5kJyxcbiAgICByZXNpemVDb250YWluZXI6ICdpc1Jlc2l6aW5nQ29udGFpbmVyJ1xuICB9O1xuICBcbiAgcHJvdG8uX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGdldCBpdGVtcyBmcm9tIGNoaWxkcmVuXG4gICAgdGhpcy5yZWxvYWRJdGVtcygpO1xuICAgIC8vIGVsZW1lbnRzIHRoYXQgYWZmZWN0IGxheW91dCwgYnV0IGFyZSBub3QgbGFpZCBvdXRcbiAgICB0aGlzLnN0YW1wcyA9IFtdO1xuICAgIHRoaXMuc3RhbXAoIHRoaXMub3B0aW9ucy5zdGFtcCApO1xuICAgIC8vIHNldCBjb250YWluZXIgc3R5bGVcbiAgICB1dGlscy5leHRlbmQoIHRoaXMuZWxlbWVudC5zdHlsZSwgdGhpcy5vcHRpb25zLmNvbnRhaW5lclN0eWxlICk7XG4gIFxuICAgIC8vIGJpbmQgcmVzaXplIG1ldGhvZFxuICAgIHZhciBjYW5CaW5kUmVzaXplID0gdGhpcy5fZ2V0T3B0aW9uKCdyZXNpemUnKTtcbiAgICBpZiAoIGNhbkJpbmRSZXNpemUgKSB7XG4gICAgICB0aGlzLmJpbmRSZXNpemUoKTtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBnb2VzIHRocm91Z2ggYWxsIGNoaWxkcmVuIGFnYWluIGFuZCBnZXRzIGJyaWNrcyBpbiBwcm9wZXIgb3JkZXJcbiAgcHJvdG8ucmVsb2FkSXRlbXMgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBjb2xsZWN0aW9uIG9mIGl0ZW0gZWxlbWVudHNcbiAgICB0aGlzLml0ZW1zID0gdGhpcy5faXRlbWl6ZSggdGhpcy5lbGVtZW50LmNoaWxkcmVuICk7XG4gIH07XG4gIFxuICBcbiAgLyoqXG4gICAqIHR1cm4gZWxlbWVudHMgaW50byBPdXRsYXllci5JdGVtcyB0byBiZSB1c2VkIGluIGxheW91dFxuICAgKiBAcGFyYW0ge0FycmF5IG9yIE5vZGVMaXN0IG9yIEhUTUxFbGVtZW50fSBlbGVtc1xuICAgKiBAcmV0dXJucyB7QXJyYXl9IGl0ZW1zIC0gY29sbGVjdGlvbiBvZiBuZXcgT3V0bGF5ZXIgSXRlbXNcbiAgICovXG4gIHByb3RvLl9pdGVtaXplID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICBcbiAgICB2YXIgaXRlbUVsZW1zID0gdGhpcy5fZmlsdGVyRmluZEl0ZW1FbGVtZW50cyggZWxlbXMgKTtcbiAgICB2YXIgSXRlbSA9IHRoaXMuY29uc3RydWN0b3IuSXRlbTtcbiAgXG4gICAgLy8gY3JlYXRlIG5ldyBPdXRsYXllciBJdGVtcyBmb3IgY29sbGVjdGlvblxuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIGZvciAoIHZhciBpPTA7IGkgPCBpdGVtRWxlbXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICB2YXIgZWxlbSA9IGl0ZW1FbGVtc1tpXTtcbiAgICAgIHZhciBpdGVtID0gbmV3IEl0ZW0oIGVsZW0sIHRoaXMgKTtcbiAgICAgIGl0ZW1zLnB1c2goIGl0ZW0gKTtcbiAgICB9XG4gIFxuICAgIHJldHVybiBpdGVtcztcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBnZXQgaXRlbSBlbGVtZW50cyB0byBiZSB1c2VkIGluIGxheW91dFxuICAgKiBAcGFyYW0ge0FycmF5IG9yIE5vZGVMaXN0IG9yIEhUTUxFbGVtZW50fSBlbGVtc1xuICAgKiBAcmV0dXJucyB7QXJyYXl9IGl0ZW1zIC0gaXRlbSBlbGVtZW50c1xuICAgKi9cbiAgcHJvdG8uX2ZpbHRlckZpbmRJdGVtRWxlbWVudHMgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gICAgcmV0dXJuIHV0aWxzLmZpbHRlckZpbmRFbGVtZW50cyggZWxlbXMsIHRoaXMub3B0aW9ucy5pdGVtU2VsZWN0b3IgKTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBnZXR0ZXIgbWV0aG9kIGZvciBnZXR0aW5nIGl0ZW0gZWxlbWVudHNcbiAgICogQHJldHVybnMge0FycmF5fSBlbGVtcyAtIGNvbGxlY3Rpb24gb2YgaXRlbSBlbGVtZW50c1xuICAgKi9cbiAgcHJvdG8uZ2V0SXRlbUVsZW1lbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMubWFwKCBmdW5jdGlvbiggaXRlbSApIHtcbiAgICAgIHJldHVybiBpdGVtLmVsZW1lbnQ7XG4gICAgfSk7XG4gIH07XG4gIFxuICAvLyAtLS0tLSBpbml0ICYgbGF5b3V0IC0tLS0tIC8vXG4gIFxuICAvKipcbiAgICogbGF5cyBvdXQgYWxsIGl0ZW1zXG4gICAqL1xuICBwcm90by5sYXlvdXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9yZXNldExheW91dCgpO1xuICAgIHRoaXMuX21hbmFnZVN0YW1wcygpO1xuICBcbiAgICAvLyBkb24ndCBhbmltYXRlIGZpcnN0IGxheW91dFxuICAgIHZhciBsYXlvdXRJbnN0YW50ID0gdGhpcy5fZ2V0T3B0aW9uKCdsYXlvdXRJbnN0YW50Jyk7XG4gICAgdmFyIGlzSW5zdGFudCA9IGxheW91dEluc3RhbnQgIT09IHVuZGVmaW5lZCA/XG4gICAgICBsYXlvdXRJbnN0YW50IDogIXRoaXMuX2lzTGF5b3V0SW5pdGVkO1xuICAgIHRoaXMubGF5b3V0SXRlbXMoIHRoaXMuaXRlbXMsIGlzSW5zdGFudCApO1xuICBcbiAgICAvLyBmbGFnIGZvciBpbml0YWxpemVkXG4gICAgdGhpcy5faXNMYXlvdXRJbml0ZWQgPSB0cnVlO1xuICB9O1xuICBcbiAgLy8gX2luaXQgaXMgYWxpYXMgZm9yIGxheW91dFxuICBwcm90by5faW5pdCA9IHByb3RvLmxheW91dDtcbiAgXG4gIC8qKlxuICAgKiBsb2dpYyBiZWZvcmUgYW55IG5ldyBsYXlvdXRcbiAgICovXG4gIHByb3RvLl9yZXNldExheW91dCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZ2V0U2l6ZSgpO1xuICB9O1xuICBcbiAgXG4gIHByb3RvLmdldFNpemUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNpemUgPSBnZXRTaXplKCB0aGlzLmVsZW1lbnQgKTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBnZXQgbWVhc3VyZW1lbnQgZnJvbSBvcHRpb24sIGZvciBjb2x1bW5XaWR0aCwgcm93SGVpZ2h0LCBndXR0ZXJcbiAgICogaWYgb3B0aW9uIGlzIFN0cmluZyAtPiBnZXQgZWxlbWVudCBmcm9tIHNlbGVjdG9yIHN0cmluZywgJiBnZXQgc2l6ZSBvZiBlbGVtZW50XG4gICAqIGlmIG9wdGlvbiBpcyBFbGVtZW50IC0+IGdldCBzaXplIG9mIGVsZW1lbnRcbiAgICogZWxzZSB1c2Ugb3B0aW9uIGFzIGEgbnVtYmVyXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZWFzdXJlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2l6ZSAtIHdpZHRoIG9yIGhlaWdodFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdG8uX2dldE1lYXN1cmVtZW50ID0gZnVuY3Rpb24oIG1lYXN1cmVtZW50LCBzaXplICkge1xuICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbnNbIG1lYXN1cmVtZW50IF07XG4gICAgdmFyIGVsZW07XG4gICAgaWYgKCAhb3B0aW9uICkge1xuICAgICAgLy8gZGVmYXVsdCB0byAwXG4gICAgICB0aGlzWyBtZWFzdXJlbWVudCBdID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXNlIG9wdGlvbiBhcyBhbiBlbGVtZW50XG4gICAgICBpZiAoIHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycgKSB7XG4gICAgICAgIGVsZW0gPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3Rvciggb3B0aW9uICk7XG4gICAgICB9IGVsc2UgaWYgKCBvcHRpb24gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCApIHtcbiAgICAgICAgZWxlbSA9IG9wdGlvbjtcbiAgICAgIH1cbiAgICAgIC8vIHVzZSBzaXplIG9mIGVsZW1lbnQsIGlmIGVsZW1lbnRcbiAgICAgIHRoaXNbIG1lYXN1cmVtZW50IF0gPSBlbGVtID8gZ2V0U2l6ZSggZWxlbSApWyBzaXplIF0gOiBvcHRpb247XG4gICAgfVxuICB9O1xuICBcbiAgLyoqXG4gICAqIGxheW91dCBhIGNvbGxlY3Rpb24gb2YgaXRlbSBlbGVtZW50c1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgcHJvdG8ubGF5b3V0SXRlbXMgPSBmdW5jdGlvbiggaXRlbXMsIGlzSW5zdGFudCApIHtcbiAgICBpdGVtcyA9IHRoaXMuX2dldEl0ZW1zRm9yTGF5b3V0KCBpdGVtcyApO1xuICBcbiAgICB0aGlzLl9sYXlvdXRJdGVtcyggaXRlbXMsIGlzSW5zdGFudCApO1xuICBcbiAgICB0aGlzLl9wb3N0TGF5b3V0KCk7XG4gIH07XG4gIFxuICAvKipcbiAgICogZ2V0IHRoZSBpdGVtcyB0byBiZSBsYWlkIG91dFxuICAgKiB5b3UgbWF5IHdhbnQgdG8gc2tpcCBvdmVyIHNvbWUgaXRlbXNcbiAgICogQHBhcmFtIHtBcnJheX0gaXRlbXNcbiAgICogQHJldHVybnMge0FycmF5fSBpdGVtc1xuICAgKi9cbiAgcHJvdG8uX2dldEl0ZW1zRm9yTGF5b3V0ID0gZnVuY3Rpb24oIGl0ZW1zICkge1xuICAgIHJldHVybiBpdGVtcy5maWx0ZXIoIGZ1bmN0aW9uKCBpdGVtICkge1xuICAgICAgcmV0dXJuICFpdGVtLmlzSWdub3JlZDtcbiAgICB9KTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBsYXlvdXQgaXRlbXNcbiAgICogQHBhcmFtIHtBcnJheX0gaXRlbXNcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc0luc3RhbnRcbiAgICovXG4gIHByb3RvLl9sYXlvdXRJdGVtcyA9IGZ1bmN0aW9uKCBpdGVtcywgaXNJbnN0YW50ICkge1xuICAgIHRoaXMuX2VtaXRDb21wbGV0ZU9uSXRlbXMoICdsYXlvdXQnLCBpdGVtcyApO1xuICBcbiAgICBpZiAoICFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoICkge1xuICAgICAgLy8gbm8gaXRlbXMsIGVtaXQgZXZlbnQgd2l0aCBlbXB0eSBhcnJheVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgXG4gICAgdmFyIHF1ZXVlID0gW107XG4gIFxuICAgIGl0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtICkge1xuICAgICAgLy8gZ2V0IHgveSBvYmplY3QgZnJvbSBtZXRob2RcbiAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX2dldEl0ZW1MYXlvdXRQb3NpdGlvbiggaXRlbSApO1xuICAgICAgLy8gZW5xdWV1ZVxuICAgICAgcG9zaXRpb24uaXRlbSA9IGl0ZW07XG4gICAgICBwb3NpdGlvbi5pc0luc3RhbnQgPSBpc0luc3RhbnQgfHwgaXRlbS5pc0xheW91dEluc3RhbnQ7XG4gICAgICBxdWV1ZS5wdXNoKCBwb3NpdGlvbiApO1xuICAgIH0sIHRoaXMgKTtcbiAgXG4gICAgdGhpcy5fcHJvY2Vzc0xheW91dFF1ZXVlKCBxdWV1ZSApO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIGdldCBpdGVtIGxheW91dCBwb3NpdGlvblxuICAgKiBAcGFyYW0ge091dGxheWVyLkl0ZW19IGl0ZW1cbiAgICogQHJldHVybnMge09iamVjdH0geCBhbmQgeSBwb3NpdGlvblxuICAgKi9cbiAgcHJvdG8uX2dldEl0ZW1MYXlvdXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCAvKiBpdGVtICovICkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gIH07XG4gIFxuICAvKipcbiAgICogaXRlcmF0ZSBvdmVyIGFycmF5IGFuZCBwb3NpdGlvbiBlYWNoIGl0ZW1cbiAgICogUmVhc29uIGJlaW5nIC0gc2VwYXJhdGluZyB0aGlzIGxvZ2ljIHByZXZlbnRzICdsYXlvdXQgaW52YWxpZGF0aW9uJ1xuICAgKiB0aHggQHBhdWxfaXJpc2hcbiAgICogQHBhcmFtIHtBcnJheX0gcXVldWVcbiAgICovXG4gIHByb3RvLl9wcm9jZXNzTGF5b3V0UXVldWUgPSBmdW5jdGlvbiggcXVldWUgKSB7XG4gICAgdGhpcy51cGRhdGVTdGFnZ2VyKCk7XG4gICAgcXVldWUuZm9yRWFjaCggZnVuY3Rpb24oIG9iaiwgaSApIHtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uSXRlbSggb2JqLml0ZW0sIG9iai54LCBvYmoueSwgb2JqLmlzSW5zdGFudCwgaSApO1xuICAgIH0sIHRoaXMgKTtcbiAgfTtcbiAgXG4gIC8vIHNldCBzdGFnZ2VyIGZyb20gb3B0aW9uIGluIG1pbGxpc2Vjb25kcyBudW1iZXJcbiAgcHJvdG8udXBkYXRlU3RhZ2dlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFnZ2VyID0gdGhpcy5vcHRpb25zLnN0YWdnZXI7XG4gICAgaWYgKCBzdGFnZ2VyID09PSBudWxsIHx8IHN0YWdnZXIgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgIHRoaXMuc3RhZ2dlciA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3RhZ2dlciA9IGdldE1pbGxpc2Vjb25kcyggc3RhZ2dlciApO1xuICAgIHJldHVybiB0aGlzLnN0YWdnZXI7XG4gIH07XG4gIFxuICAvKipcbiAgICogU2V0cyBwb3NpdGlvbiBvZiBpdGVtIGluIERPTVxuICAgKiBAcGFyYW0ge091dGxheWVyLkl0ZW19IGl0ZW1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHggLSBob3Jpem9udGFsIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5IC0gdmVydGljYWwgcG9zaXRpb25cbiAgICogQHBhcmFtIHtCb29sZWFufSBpc0luc3RhbnQgLSBkaXNhYmxlcyB0cmFuc2l0aW9uc1xuICAgKi9cbiAgcHJvdG8uX3Bvc2l0aW9uSXRlbSA9IGZ1bmN0aW9uKCBpdGVtLCB4LCB5LCBpc0luc3RhbnQsIGkgKSB7XG4gICAgaWYgKCBpc0luc3RhbnQgKSB7XG4gICAgICAvLyBpZiBub3QgdHJhbnNpdGlvbiwganVzdCBzZXQgQ1NTXG4gICAgICBpdGVtLmdvVG8oIHgsIHkgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlbS5zdGFnZ2VyKCBpICogdGhpcy5zdGFnZ2VyICk7XG4gICAgICBpdGVtLm1vdmVUbyggeCwgeSApO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBBbnkgbG9naWMgeW91IHdhbnQgdG8gZG8gYWZ0ZXIgZWFjaCBsYXlvdXQsXG4gICAqIGkuZS4gc2l6ZSB0aGUgY29udGFpbmVyXG4gICAqL1xuICBwcm90by5fcG9zdExheW91dCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVzaXplQ29udGFpbmVyKCk7XG4gIH07XG4gIFxuICBwcm90by5yZXNpemVDb250YWluZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXNSZXNpemluZ0NvbnRhaW5lciA9IHRoaXMuX2dldE9wdGlvbigncmVzaXplQ29udGFpbmVyJyk7XG4gICAgaWYgKCAhaXNSZXNpemluZ0NvbnRhaW5lciApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHNpemUgPSB0aGlzLl9nZXRDb250YWluZXJTaXplKCk7XG4gICAgaWYgKCBzaXplICkge1xuICAgICAgdGhpcy5fc2V0Q29udGFpbmVyTWVhc3VyZSggc2l6ZS53aWR0aCwgdHJ1ZSApO1xuICAgICAgdGhpcy5fc2V0Q29udGFpbmVyTWVhc3VyZSggc2l6ZS5oZWlnaHQsIGZhbHNlICk7XG4gICAgfVxuICB9O1xuICBcbiAgLyoqXG4gICAqIFNldHMgd2lkdGggb3IgaGVpZ2h0IG9mIGNvbnRhaW5lciBpZiByZXR1cm5lZFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBzaXplXG4gICAqICAgQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAqICAgQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgKi9cbiAgcHJvdG8uX2dldENvbnRhaW5lclNpemUgPSBub29wO1xuICBcbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtZWFzdXJlIC0gc2l6ZSBvZiB3aWR0aCBvciBoZWlnaHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1dpZHRoXG4gICAqL1xuICBwcm90by5fc2V0Q29udGFpbmVyTWVhc3VyZSA9IGZ1bmN0aW9uKCBtZWFzdXJlLCBpc1dpZHRoICkge1xuICAgIGlmICggbWVhc3VyZSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgXG4gICAgdmFyIGVsZW1TaXplID0gdGhpcy5zaXplO1xuICAgIC8vIGFkZCBwYWRkaW5nIGFuZCBib3JkZXIgd2lkdGggaWYgYm9yZGVyIGJveFxuICAgIGlmICggZWxlbVNpemUuaXNCb3JkZXJCb3ggKSB7XG4gICAgICBtZWFzdXJlICs9IGlzV2lkdGggPyBlbGVtU2l6ZS5wYWRkaW5nTGVmdCArIGVsZW1TaXplLnBhZGRpbmdSaWdodCArXG4gICAgICAgIGVsZW1TaXplLmJvcmRlckxlZnRXaWR0aCArIGVsZW1TaXplLmJvcmRlclJpZ2h0V2lkdGggOlxuICAgICAgICBlbGVtU2l6ZS5wYWRkaW5nQm90dG9tICsgZWxlbVNpemUucGFkZGluZ1RvcCArXG4gICAgICAgIGVsZW1TaXplLmJvcmRlclRvcFdpZHRoICsgZWxlbVNpemUuYm9yZGVyQm90dG9tV2lkdGg7XG4gICAgfVxuICBcbiAgICBtZWFzdXJlID0gTWF0aC5tYXgoIG1lYXN1cmUsIDAgKTtcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGVbIGlzV2lkdGggPyAnd2lkdGgnIDogJ2hlaWdodCcgXSA9IG1lYXN1cmUgKyAncHgnO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIGVtaXQgZXZlbnRDb21wbGV0ZSBvbiBhIGNvbGxlY3Rpb24gb2YgaXRlbXMgZXZlbnRzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtBcnJheX0gaXRlbXMgLSBPdXRsYXllci5JdGVtc1xuICAgKi9cbiAgcHJvdG8uX2VtaXRDb21wbGV0ZU9uSXRlbXMgPSBmdW5jdGlvbiggZXZlbnROYW1lLCBpdGVtcyApIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KCBldmVudE5hbWUgKyAnQ29tcGxldGUnLCBudWxsLCBbIGl0ZW1zIF0gKTtcbiAgICB9XG4gIFxuICAgIHZhciBjb3VudCA9IGl0ZW1zLmxlbmd0aDtcbiAgICBpZiAoICFpdGVtcyB8fCAhY291bnQgKSB7XG4gICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICBcbiAgICB2YXIgZG9uZUNvdW50ID0gMDtcbiAgICBmdW5jdGlvbiB0aWNrKCkge1xuICAgICAgZG9uZUNvdW50Kys7XG4gICAgICBpZiAoIGRvbmVDb3VudCA9PSBjb3VudCApIHtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgXG4gICAgLy8gYmluZCBjYWxsYmFja1xuICAgIGl0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtICkge1xuICAgICAgaXRlbS5vbmNlKCBldmVudE5hbWUsIHRpY2sgKTtcbiAgICB9KTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBlbWl0cyBldmVudHMgdmlhIEV2RW1pdHRlciBhbmQgalF1ZXJ5IGV2ZW50c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIG5hbWUgb2YgZXZlbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBvcmlnaW5hbCBldmVudFxuICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIC0gZXh0cmEgYXJndW1lbnRzXG4gICAqL1xuICBwcm90by5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oIHR5cGUsIGV2ZW50LCBhcmdzICkge1xuICAgIC8vIGFkZCBvcmlnaW5hbCBldmVudCB0byBhcmd1bWVudHNcbiAgICB2YXIgZW1pdEFyZ3MgPSBldmVudCA/IFsgZXZlbnQgXS5jb25jYXQoIGFyZ3MgKSA6IGFyZ3M7XG4gICAgdGhpcy5lbWl0RXZlbnQoIHR5cGUsIGVtaXRBcmdzICk7XG4gIFxuICAgIGlmICggalF1ZXJ5ICkge1xuICAgICAgLy8gc2V0IHRoaXMuJGVsZW1lbnRcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSB0aGlzLiRlbGVtZW50IHx8IGpRdWVyeSggdGhpcy5lbGVtZW50ICk7XG4gICAgICBpZiAoIGV2ZW50ICkge1xuICAgICAgICAvLyBjcmVhdGUgalF1ZXJ5IGV2ZW50XG4gICAgICAgIHZhciAkZXZlbnQgPSBqUXVlcnkuRXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICRldmVudC50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCAkZXZlbnQsIGFyZ3MgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGp1c3QgdHJpZ2dlciB3aXRoIHR5cGUgaWYgbm8gZXZlbnQgYXZhaWxhYmxlXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlciggdHlwZSwgYXJncyApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGlnbm9yZSAmIHN0YW1wcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICBcbiAgXG4gIC8qKlxuICAgKiBrZWVwIGl0ZW0gaW4gY29sbGVjdGlvbiwgYnV0IGRvIG5vdCBsYXkgaXQgb3V0XG4gICAqIGlnbm9yZWQgaXRlbXMgZG8gbm90IGdldCBza2lwcGVkIGluIGxheW91dFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1cbiAgICovXG4gIHByb3RvLmlnbm9yZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgIHZhciBpdGVtID0gdGhpcy5nZXRJdGVtKCBlbGVtICk7XG4gICAgaWYgKCBpdGVtICkge1xuICAgICAgaXRlbS5pc0lnbm9yZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8qKlxuICAgKiByZXR1cm4gaXRlbSB0byBsYXlvdXQgY29sbGVjdGlvblxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1cbiAgICovXG4gIHByb3RvLnVuaWdub3JlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgdmFyIGl0ZW0gPSB0aGlzLmdldEl0ZW0oIGVsZW0gKTtcbiAgICBpZiAoIGl0ZW0gKSB7XG4gICAgICBkZWxldGUgaXRlbS5pc0lnbm9yZWQ7XG4gICAgfVxuICB9O1xuICBcbiAgLyoqXG4gICAqIGFkZHMgZWxlbWVudHMgdG8gc3RhbXBzXG4gICAqIEBwYXJhbSB7Tm9kZUxpc3QsIEFycmF5LCBFbGVtZW50LCBvciBTdHJpbmd9IGVsZW1zXG4gICAqL1xuICBwcm90by5zdGFtcCA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgICBlbGVtcyA9IHRoaXMuX2ZpbmQoIGVsZW1zICk7XG4gICAgaWYgKCAhZWxlbXMgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICBcbiAgICB0aGlzLnN0YW1wcyA9IHRoaXMuc3RhbXBzLmNvbmNhdCggZWxlbXMgKTtcbiAgICAvLyBpZ25vcmVcbiAgICBlbGVtcy5mb3JFYWNoKCB0aGlzLmlnbm9yZSwgdGhpcyApO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIHJlbW92ZXMgZWxlbWVudHMgdG8gc3RhbXBzXG4gICAqIEBwYXJhbSB7Tm9kZUxpc3QsIEFycmF5LCBvciBFbGVtZW50fSBlbGVtc1xuICAgKi9cbiAgcHJvdG8udW5zdGFtcCA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgICBlbGVtcyA9IHRoaXMuX2ZpbmQoIGVsZW1zICk7XG4gICAgaWYgKCAhZWxlbXMgKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIFxuICAgIGVsZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgLy8gZmlsdGVyIG91dCByZW1vdmVkIHN0YW1wIGVsZW1lbnRzXG4gICAgICB1dGlscy5yZW1vdmVGcm9tKCB0aGlzLnN0YW1wcywgZWxlbSApO1xuICAgICAgdGhpcy51bmlnbm9yZSggZWxlbSApO1xuICAgIH0sIHRoaXMgKTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBmaW5kcyBjaGlsZCBlbGVtZW50c1xuICAgKiBAcGFyYW0ge05vZGVMaXN0LCBBcnJheSwgRWxlbWVudCwgb3IgU3RyaW5nfSBlbGVtc1xuICAgKiBAcmV0dXJucyB7QXJyYXl9IGVsZW1zXG4gICAqL1xuICBwcm90by5fZmluZCA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgICBpZiAoICFlbGVtcyApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gaWYgc3RyaW5nLCB1c2UgYXJndW1lbnQgYXMgc2VsZWN0b3Igc3RyaW5nXG4gICAgaWYgKCB0eXBlb2YgZWxlbXMgPT0gJ3N0cmluZycgKSB7XG4gICAgICBlbGVtcyA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCBlbGVtcyApO1xuICAgIH1cbiAgICBlbGVtcyA9IHV0aWxzLm1ha2VBcnJheSggZWxlbXMgKTtcbiAgICByZXR1cm4gZWxlbXM7XG4gIH07XG4gIFxuICBwcm90by5fbWFuYWdlU3RhbXBzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCAhdGhpcy5zdGFtcHMgfHwgIXRoaXMuc3RhbXBzLmxlbmd0aCApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIFxuICAgIHRoaXMuX2dldEJvdW5kaW5nUmVjdCgpO1xuICBcbiAgICB0aGlzLnN0YW1wcy5mb3JFYWNoKCB0aGlzLl9tYW5hZ2VTdGFtcCwgdGhpcyApO1xuICB9O1xuICBcbiAgLy8gdXBkYXRlIGJvdW5kaW5nTGVmdCAvIFRvcFxuICBwcm90by5fZ2V0Qm91bmRpbmdSZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gZ2V0IGJvdW5kaW5nIHJlY3QgZm9yIGNvbnRhaW5lciBlbGVtZW50XG4gICAgdmFyIGJvdW5kaW5nUmVjdCA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICB0aGlzLl9ib3VuZGluZ1JlY3QgPSB7XG4gICAgICBsZWZ0OiBib3VuZGluZ1JlY3QubGVmdCArIHNpemUucGFkZGluZ0xlZnQgKyBzaXplLmJvcmRlckxlZnRXaWR0aCxcbiAgICAgIHRvcDogYm91bmRpbmdSZWN0LnRvcCArIHNpemUucGFkZGluZ1RvcCArIHNpemUuYm9yZGVyVG9wV2lkdGgsXG4gICAgICByaWdodDogYm91bmRpbmdSZWN0LnJpZ2h0IC0gKCBzaXplLnBhZGRpbmdSaWdodCArIHNpemUuYm9yZGVyUmlnaHRXaWR0aCApLFxuICAgICAgYm90dG9tOiBib3VuZGluZ1JlY3QuYm90dG9tIC0gKCBzaXplLnBhZGRpbmdCb3R0b20gKyBzaXplLmJvcmRlckJvdHRvbVdpZHRoIClcbiAgICB9O1xuICB9O1xuICBcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gc3RhbXBcbiAgKiovXG4gIHByb3RvLl9tYW5hZ2VTdGFtcCA9IG5vb3A7XG4gIFxuICAvKipcbiAgICogZ2V0IHgveSBwb3NpdGlvbiBvZiBlbGVtZW50IHJlbGF0aXZlIHRvIGNvbnRhaW5lciBlbGVtZW50XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBvZmZzZXQgLSBoYXMgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tXG4gICAqL1xuICBwcm90by5fZ2V0RWxlbWVudE9mZnNldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgIHZhciBib3VuZGluZ1JlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciB0aGlzUmVjdCA9IHRoaXMuX2JvdW5kaW5nUmVjdDtcbiAgICB2YXIgc2l6ZSA9IGdldFNpemUoIGVsZW0gKTtcbiAgICB2YXIgb2Zmc2V0ID0ge1xuICAgICAgbGVmdDogYm91bmRpbmdSZWN0LmxlZnQgLSB0aGlzUmVjdC5sZWZ0IC0gc2l6ZS5tYXJnaW5MZWZ0LFxuICAgICAgdG9wOiBib3VuZGluZ1JlY3QudG9wIC0gdGhpc1JlY3QudG9wIC0gc2l6ZS5tYXJnaW5Ub3AsXG4gICAgICByaWdodDogdGhpc1JlY3QucmlnaHQgLSBib3VuZGluZ1JlY3QucmlnaHQgLSBzaXplLm1hcmdpblJpZ2h0LFxuICAgICAgYm90dG9tOiB0aGlzUmVjdC5ib3R0b20gLSBib3VuZGluZ1JlY3QuYm90dG9tIC0gc2l6ZS5tYXJnaW5Cb3R0b21cbiAgICB9O1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH07XG4gIFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSByZXNpemUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cbiAgXG4gIC8vIGVuYWJsZSBldmVudCBoYW5kbGVycyBmb3IgbGlzdGVuZXJzXG4gIC8vIGkuZS4gcmVzaXplIC0+IG9ucmVzaXplXG4gIHByb3RvLmhhbmRsZUV2ZW50ID0gdXRpbHMuaGFuZGxlRXZlbnQ7XG4gIFxuICAvKipcbiAgICogQmluZCBsYXlvdXQgdG8gd2luZG93IHJlc2l6aW5nXG4gICAqL1xuICBwcm90by5iaW5kUmVzaXplID0gZnVuY3Rpb24oKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdyZXNpemUnLCB0aGlzICk7XG4gICAgdGhpcy5pc1Jlc2l6ZUJvdW5kID0gdHJ1ZTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBVbmJpbmQgbGF5b3V0IHRvIHdpbmRvdyByZXNpemluZ1xuICAgKi9cbiAgcHJvdG8udW5iaW5kUmVzaXplID0gZnVuY3Rpb24oKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdyZXNpemUnLCB0aGlzICk7XG4gICAgdGhpcy5pc1Jlc2l6ZUJvdW5kID0gZmFsc2U7XG4gIH07XG4gIFxuICBwcm90by5vbnJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVzaXplKCk7XG4gIH07XG4gIFxuICB1dGlscy5kZWJvdW5jZU1ldGhvZCggT3V0bGF5ZXIsICdvbnJlc2l6ZScsIDEwMCApO1xuICBcbiAgcHJvdG8ucmVzaXplID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gZG9uJ3QgdHJpZ2dlciBpZiBzaXplIGRpZCBub3QgY2hhbmdlXG4gICAgLy8gb3IgaWYgcmVzaXplIHdhcyB1bmJvdW5kLiBTZWUgIzlcbiAgICBpZiAoICF0aGlzLmlzUmVzaXplQm91bmQgfHwgIXRoaXMubmVlZHNSZXNpemVMYXlvdXQoKSApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIFxuICAgIHRoaXMubGF5b3V0KCk7XG4gIH07XG4gIFxuICAvKipcbiAgICogY2hlY2sgaWYgbGF5b3V0IGlzIG5lZWRlZCBwb3N0IGxheW91dFxuICAgKiBAcmV0dXJucyBCb29sZWFuXG4gICAqL1xuICBwcm90by5uZWVkc1Jlc2l6ZUxheW91dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzaXplID0gZ2V0U2l6ZSggdGhpcy5lbGVtZW50ICk7XG4gICAgLy8gY2hlY2sgdGhhdCB0aGlzLnNpemUgYW5kIHNpemUgYXJlIHRoZXJlXG4gICAgLy8gSUU4IHRyaWdnZXJzIHJlc2l6ZSBvbiBib2R5IHNpemUgY2hhbmdlLCBzbyB0aGV5IG1pZ2h0IG5vdCBiZVxuICAgIHZhciBoYXNTaXplcyA9IHRoaXMuc2l6ZSAmJiBzaXplO1xuICAgIHJldHVybiBoYXNTaXplcyAmJiBzaXplLmlubmVyV2lkdGggIT09IHRoaXMuc2l6ZS5pbm5lcldpZHRoO1xuICB9O1xuICBcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gbWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICBcbiAgLyoqXG4gICAqIGFkZCBpdGVtcyB0byBPdXRsYXllciBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0FycmF5IG9yIE5vZGVMaXN0IG9yIEVsZW1lbnR9IGVsZW1zXG4gICAqIEByZXR1cm5zIHtBcnJheX0gaXRlbXMgLSBPdXRsYXllci5JdGVtc1xuICAqKi9cbiAgcHJvdG8uYWRkSXRlbXMgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gICAgdmFyIGl0ZW1zID0gdGhpcy5faXRlbWl6ZSggZWxlbXMgKTtcbiAgICAvLyBhZGQgaXRlbXMgdG8gY29sbGVjdGlvblxuICAgIGlmICggaXRlbXMubGVuZ3RoICkge1xuICAgICAgdGhpcy5pdGVtcyA9IHRoaXMuaXRlbXMuY29uY2F0KCBpdGVtcyApO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbXM7XG4gIH07XG4gIFxuICAvKipcbiAgICogTGF5b3V0IG5ld2x5LWFwcGVuZGVkIGl0ZW0gZWxlbWVudHNcbiAgICogQHBhcmFtIHtBcnJheSBvciBOb2RlTGlzdCBvciBFbGVtZW50fSBlbGVtc1xuICAgKi9cbiAgcHJvdG8uYXBwZW5kZWQgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gICAgdmFyIGl0ZW1zID0gdGhpcy5hZGRJdGVtcyggZWxlbXMgKTtcbiAgICBpZiAoICFpdGVtcy5sZW5ndGggKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGxheW91dCBhbmQgcmV2ZWFsIGp1c3QgdGhlIG5ldyBpdGVtc1xuICAgIHRoaXMubGF5b3V0SXRlbXMoIGl0ZW1zLCB0cnVlICk7XG4gICAgdGhpcy5yZXZlYWwoIGl0ZW1zICk7XG4gIH07XG4gIFxuICAvKipcbiAgICogTGF5b3V0IHByZXBlbmRlZCBlbGVtZW50c1xuICAgKiBAcGFyYW0ge0FycmF5IG9yIE5vZGVMaXN0IG9yIEVsZW1lbnR9IGVsZW1zXG4gICAqL1xuICBwcm90by5wcmVwZW5kZWQgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gICAgdmFyIGl0ZW1zID0gdGhpcy5faXRlbWl6ZSggZWxlbXMgKTtcbiAgICBpZiAoICFpdGVtcy5sZW5ndGggKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGFkZCBpdGVtcyB0byBiZWdpbm5pbmcgb2YgY29sbGVjdGlvblxuICAgIHZhciBwcmV2aW91c0l0ZW1zID0gdGhpcy5pdGVtcy5zbGljZSgwKTtcbiAgICB0aGlzLml0ZW1zID0gaXRlbXMuY29uY2F0KCBwcmV2aW91c0l0ZW1zICk7XG4gICAgLy8gc3RhcnQgbmV3IGxheW91dFxuICAgIHRoaXMuX3Jlc2V0TGF5b3V0KCk7XG4gICAgdGhpcy5fbWFuYWdlU3RhbXBzKCk7XG4gICAgLy8gbGF5b3V0IG5ldyBzdHVmZiB3aXRob3V0IHRyYW5zaXRpb25cbiAgICB0aGlzLmxheW91dEl0ZW1zKCBpdGVtcywgdHJ1ZSApO1xuICAgIHRoaXMucmV2ZWFsKCBpdGVtcyApO1xuICAgIC8vIGxheW91dCBwcmV2aW91cyBpdGVtc1xuICAgIHRoaXMubGF5b3V0SXRlbXMoIHByZXZpb3VzSXRlbXMgKTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiByZXZlYWwgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zXG4gICAqIEBwYXJhbSB7QXJyYXkgb2YgT3V0bGF5ZXIuSXRlbXN9IGl0ZW1zXG4gICAqL1xuICBwcm90by5yZXZlYWwgPSBmdW5jdGlvbiggaXRlbXMgKSB7XG4gICAgdGhpcy5fZW1pdENvbXBsZXRlT25JdGVtcyggJ3JldmVhbCcsIGl0ZW1zICk7XG4gICAgaWYgKCAhaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHN0YWdnZXIgPSB0aGlzLnVwZGF0ZVN0YWdnZXIoKTtcbiAgICBpdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSwgaSApIHtcbiAgICAgIGl0ZW0uc3RhZ2dlciggaSAqIHN0YWdnZXIgKTtcbiAgICAgIGl0ZW0ucmV2ZWFsKCk7XG4gICAgfSk7XG4gIH07XG4gIFxuICAvKipcbiAgICogaGlkZSBhIGNvbGxlY3Rpb24gb2YgaXRlbXNcbiAgICogQHBhcmFtIHtBcnJheSBvZiBPdXRsYXllci5JdGVtc30gaXRlbXNcbiAgICovXG4gIHByb3RvLmhpZGUgPSBmdW5jdGlvbiggaXRlbXMgKSB7XG4gICAgdGhpcy5fZW1pdENvbXBsZXRlT25JdGVtcyggJ2hpZGUnLCBpdGVtcyApO1xuICAgIGlmICggIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGggKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzdGFnZ2VyID0gdGhpcy51cGRhdGVTdGFnZ2VyKCk7XG4gICAgaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0sIGkgKSB7XG4gICAgICBpdGVtLnN0YWdnZXIoIGkgKiBzdGFnZ2VyICk7XG4gICAgICBpdGVtLmhpZGUoKTtcbiAgICB9KTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiByZXZlYWwgaXRlbSBlbGVtZW50c1xuICAgKiBAcGFyYW0ge0FycmF5fSwge0VsZW1lbnR9LCB7Tm9kZUxpc3R9IGl0ZW1zXG4gICAqL1xuICBwcm90by5yZXZlYWxJdGVtRWxlbWVudHMgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gICAgdmFyIGl0ZW1zID0gdGhpcy5nZXRJdGVtcyggZWxlbXMgKTtcbiAgICB0aGlzLnJldmVhbCggaXRlbXMgKTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBoaWRlIGl0ZW0gZWxlbWVudHNcbiAgICogQHBhcmFtIHtBcnJheX0sIHtFbGVtZW50fSwge05vZGVMaXN0fSBpdGVtc1xuICAgKi9cbiAgcHJvdG8uaGlkZUl0ZW1FbGVtZW50cyA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgICB2YXIgaXRlbXMgPSB0aGlzLmdldEl0ZW1zKCBlbGVtcyApO1xuICAgIHRoaXMuaGlkZSggaXRlbXMgKTtcbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBnZXQgT3V0bGF5ZXIuSXRlbSwgZ2l2ZW4gYW4gRWxlbWVudFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge091dGxheWVyLkl0ZW19IGl0ZW1cbiAgICovXG4gIHByb3RvLmdldEl0ZW0gPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAvLyBsb29wIHRocm91Z2ggaXRlbXMgdG8gZ2V0IHRoZSBvbmUgdGhhdCBtYXRjaGVzXG4gICAgZm9yICggdmFyIGk9MDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICB2YXIgaXRlbSA9IHRoaXMuaXRlbXNbaV07XG4gICAgICBpZiAoIGl0ZW0uZWxlbWVudCA9PSBlbGVtICkge1xuICAgICAgICAvLyByZXR1cm4gaXRlbVxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFxuICAvKipcbiAgICogZ2V0IGNvbGxlY3Rpb24gb2YgT3V0bGF5ZXIuSXRlbXMsIGdpdmVuIEVsZW1lbnRzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGVsZW1zXG4gICAqIEByZXR1cm5zIHtBcnJheX0gaXRlbXMgLSBPdXRsYXllci5JdGVtc1xuICAgKi9cbiAgcHJvdG8uZ2V0SXRlbXMgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gICAgZWxlbXMgPSB1dGlscy5tYWtlQXJyYXkoIGVsZW1zICk7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgZWxlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbSggZWxlbSApO1xuICAgICAgaWYgKCBpdGVtICkge1xuICAgICAgICBpdGVtcy5wdXNoKCBpdGVtICk7XG4gICAgICB9XG4gICAgfSwgdGhpcyApO1xuICBcbiAgICByZXR1cm4gaXRlbXM7XG4gIH07XG4gIFxuICAvKipcbiAgICogcmVtb3ZlIGVsZW1lbnQocykgZnJvbSBpbnN0YW5jZSBhbmQgRE9NXG4gICAqIEBwYXJhbSB7QXJyYXkgb3IgTm9kZUxpc3Qgb3IgRWxlbWVudH0gZWxlbXNcbiAgICovXG4gIHByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgICB2YXIgcmVtb3ZlSXRlbXMgPSB0aGlzLmdldEl0ZW1zKCBlbGVtcyApO1xuICBcbiAgICB0aGlzLl9lbWl0Q29tcGxldGVPbkl0ZW1zKCAncmVtb3ZlJywgcmVtb3ZlSXRlbXMgKTtcbiAgXG4gICAgLy8gYmFpbCBpZiBubyBpdGVtcyB0byByZW1vdmVcbiAgICBpZiAoICFyZW1vdmVJdGVtcyB8fCAhcmVtb3ZlSXRlbXMubGVuZ3RoICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgXG4gICAgcmVtb3ZlSXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0gKSB7XG4gICAgICBpdGVtLnJlbW92ZSgpO1xuICAgICAgLy8gcmVtb3ZlIGl0ZW0gZnJvbSBjb2xsZWN0aW9uXG4gICAgICB1dGlscy5yZW1vdmVGcm9tKCB0aGlzLml0ZW1zLCBpdGVtICk7XG4gICAgfSwgdGhpcyApO1xuICB9O1xuICBcbiAgLy8gLS0tLS0gZGVzdHJveSAtLS0tLSAvL1xuICBcbiAgLy8gcmVtb3ZlIGFuZCBkaXNhYmxlIE91dGxheWVyIGluc3RhbmNlXG4gIHByb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBjbGVhbiB1cCBkeW5hbWljIHN0eWxlc1xuICAgIHZhciBzdHlsZSA9IHRoaXMuZWxlbWVudC5zdHlsZTtcbiAgICBzdHlsZS5oZWlnaHQgPSAnJztcbiAgICBzdHlsZS5wb3NpdGlvbiA9ICcnO1xuICAgIHN0eWxlLndpZHRoID0gJyc7XG4gICAgLy8gZGVzdHJveSBpdGVtc1xuICAgIHRoaXMuaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0gKSB7XG4gICAgICBpdGVtLmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgXG4gICAgdGhpcy51bmJpbmRSZXNpemUoKTtcbiAgXG4gICAgdmFyIGlkID0gdGhpcy5lbGVtZW50Lm91dGxheWVyR1VJRDtcbiAgICBkZWxldGUgaW5zdGFuY2VzWyBpZCBdOyAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIGluc3RhbmNlIGJ5IGlkXG4gICAgZGVsZXRlIHRoaXMuZWxlbWVudC5vdXRsYXllckdVSUQ7XG4gICAgLy8gcmVtb3ZlIGRhdGEgZm9yIGpRdWVyeVxuICAgIGlmICggalF1ZXJ5ICkge1xuICAgICAgalF1ZXJ5LnJlbW92ZURhdGEoIHRoaXMuZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lc3BhY2UgKTtcbiAgICB9XG4gIFxuICB9O1xuICBcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZGF0YSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICBcbiAgLyoqXG4gICAqIGdldCBPdXRsYXllciBpbnN0YW5jZSBmcm9tIGVsZW1lbnRcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gICAqIEByZXR1cm5zIHtPdXRsYXllcn1cbiAgICovXG4gIE91dGxheWVyLmRhdGEgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgICBlbGVtID0gdXRpbHMuZ2V0UXVlcnlFbGVtZW50KCBlbGVtICk7XG4gICAgdmFyIGlkID0gZWxlbSAmJiBlbGVtLm91dGxheWVyR1VJRDtcbiAgICByZXR1cm4gaWQgJiYgaW5zdGFuY2VzWyBpZCBdO1xuICB9O1xuICBcbiAgXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGNyZWF0ZSBPdXRsYXllciBjbGFzcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICBcbiAgLyoqXG4gICAqIGNyZWF0ZSBhIGxheW91dCBjbGFzc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gICAqL1xuICBPdXRsYXllci5jcmVhdGUgPSBmdW5jdGlvbiggbmFtZXNwYWNlLCBvcHRpb25zICkge1xuICAgIC8vIHN1Yi1jbGFzcyBPdXRsYXllclxuICAgIHZhciBMYXlvdXQgPSBzdWJjbGFzcyggT3V0bGF5ZXIgKTtcbiAgICAvLyBhcHBseSBuZXcgb3B0aW9ucyBhbmQgY29tcGF0T3B0aW9uc1xuICAgIExheW91dC5kZWZhdWx0cyA9IHV0aWxzLmV4dGVuZCgge30sIE91dGxheWVyLmRlZmF1bHRzICk7XG4gICAgdXRpbHMuZXh0ZW5kKCBMYXlvdXQuZGVmYXVsdHMsIG9wdGlvbnMgKTtcbiAgICBMYXlvdXQuY29tcGF0T3B0aW9ucyA9IHV0aWxzLmV4dGVuZCgge30sIE91dGxheWVyLmNvbXBhdE9wdGlvbnMgICk7XG4gIFxuICAgIExheW91dC5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIFxuICAgIExheW91dC5kYXRhID0gT3V0bGF5ZXIuZGF0YTtcbiAgXG4gICAgLy8gc3ViLWNsYXNzIEl0ZW1cbiAgICBMYXlvdXQuSXRlbSA9IHN1YmNsYXNzKCBJdGVtICk7XG4gIFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGRlY2xhcmF0aXZlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG4gIFxuICAgIHV0aWxzLmh0bWxJbml0KCBMYXlvdXQsIG5hbWVzcGFjZSApO1xuICBcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBqUXVlcnkgYnJpZGdlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG4gIFxuICAgIC8vIG1ha2UgaW50byBqUXVlcnkgcGx1Z2luXG4gICAgaWYgKCBqUXVlcnkgJiYgalF1ZXJ5LmJyaWRnZXQgKSB7XG4gICAgICBqUXVlcnkuYnJpZGdldCggbmFtZXNwYWNlLCBMYXlvdXQgKTtcbiAgICB9XG4gIFxuICAgIHJldHVybiBMYXlvdXQ7XG4gIH07XG4gIFxuICBmdW5jdGlvbiBzdWJjbGFzcyggUGFyZW50ICkge1xuICAgIGZ1bmN0aW9uIFN1YkNsYXNzKCkge1xuICAgICAgUGFyZW50LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICB9XG4gIFxuICAgIFN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBhcmVudC5wcm90b3R5cGUgKTtcbiAgICBTdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWJDbGFzcztcbiAgXG4gICAgcmV0dXJuIFN1YkNsYXNzO1xuICB9XG4gIFxuICAvLyAtLS0tLSBoZWxwZXJzIC0tLS0tIC8vXG4gIFxuICAvLyBob3cgbWFueSBtaWxsaXNlY29uZHMgYXJlIGluIGVhY2ggdW5pdFxuICB2YXIgbXNVbml0cyA9IHtcbiAgICBtczogMSxcbiAgICBzOiAxMDAwXG4gIH07XG4gIFxuICAvLyBtdW5nZSB0aW1lLWxpa2UgcGFyYW1ldGVyIGludG8gbWlsbGlzZWNvbmQgbnVtYmVyXG4gIC8vICcwLjRzJyAtPiA0MFxuICBmdW5jdGlvbiBnZXRNaWxsaXNlY29uZHMoIHRpbWUgKSB7XG4gICAgaWYgKCB0eXBlb2YgdGltZSA9PSAnbnVtYmVyJyApIHtcbiAgICAgIHJldHVybiB0aW1lO1xuICAgIH1cbiAgICB2YXIgbWF0Y2hlcyA9IHRpbWUubWF0Y2goIC8oXlxcZCpcXC4/XFxkKikoXFx3KikvICk7XG4gICAgdmFyIG51bSA9IG1hdGNoZXMgJiYgbWF0Y2hlc1sxXTtcbiAgICB2YXIgdW5pdCA9IG1hdGNoZXMgJiYgbWF0Y2hlc1syXTtcbiAgICBpZiAoICFudW0ubGVuZ3RoICkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIG51bSA9IHBhcnNlRmxvYXQoIG51bSApO1xuICAgIHZhciBtdWx0ID0gbXNVbml0c1sgdW5pdCBdIHx8IDE7XG4gICAgcmV0dXJuIG51bSAqIG11bHQ7XG4gIH1cbiAgXG4gIC8vIC0tLS0tIGZpbiAtLS0tLSAvL1xuICBcbiAgLy8gYmFjayBpbiBnbG9iYWxcbiAgT3V0bGF5ZXIuSXRlbSA9IEl0ZW07XG4gIFxuICByZXR1cm4gT3V0bGF5ZXI7XG4gIFxuICB9KSk7XG4gIFxuICAvKipcbiAgICogSXNvdG9wZSBJdGVtXG4gICoqL1xuICBcbiAgKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAgIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICAgIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSAqL1xuICAgIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgICAvLyBBTURcbiAgICAgIGRlZmluZSggJ2lzb3RvcGUtbGF5b3V0L2pzL2l0ZW0nLFtcbiAgICAgICAgICAnb3V0bGF5ZXIvb3V0bGF5ZXInXG4gICAgICAgIF0sXG4gICAgICAgIGZhY3RvcnkgKTtcbiAgICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgICAgLy8gQ29tbW9uSlNcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgICAgcmVxdWlyZSgnb3V0bGF5ZXInKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICAgIHdpbmRvdy5Jc290b3BlID0gd2luZG93Lklzb3RvcGUgfHwge307XG4gICAgICB3aW5kb3cuSXNvdG9wZS5JdGVtID0gZmFjdG9yeShcbiAgICAgICAgd2luZG93Lk91dGxheWVyXG4gICAgICApO1xuICAgIH1cbiAgXG4gIH0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSggT3V0bGF5ZXIgKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEl0ZW0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cbiAgXG4gIC8vIHN1Yi1jbGFzcyBPdXRsYXllciBJdGVtXG4gIGZ1bmN0aW9uIEl0ZW0oKSB7XG4gICAgT3V0bGF5ZXIuSXRlbS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gIH1cbiAgXG4gIHZhciBwcm90byA9IEl0ZW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggT3V0bGF5ZXIuSXRlbS5wcm90b3R5cGUgKTtcbiAgXG4gIHZhciBfY3JlYXRlID0gcHJvdG8uX2NyZWF0ZTtcbiAgcHJvdG8uX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGFzc2lnbiBpZCwgdXNlZCBmb3Igb3JpZ2luYWwtb3JkZXIgc29ydGluZ1xuICAgIHRoaXMuaWQgPSB0aGlzLmxheW91dC5pdGVtR1VJRCsrO1xuICAgIF9jcmVhdGUuY2FsbCggdGhpcyApO1xuICAgIHRoaXMuc29ydERhdGEgPSB7fTtcbiAgfTtcbiAgXG4gIHByb3RvLnVwZGF0ZVNvcnREYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCB0aGlzLmlzSWdub3JlZCApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gZGVmYXVsdCBzb3J0ZXJzXG4gICAgdGhpcy5zb3J0RGF0YS5pZCA9IHRoaXMuaWQ7XG4gICAgLy8gZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICB0aGlzLnNvcnREYXRhWydvcmlnaW5hbC1vcmRlciddID0gdGhpcy5pZDtcbiAgICB0aGlzLnNvcnREYXRhLnJhbmRvbSA9IE1hdGgucmFuZG9tKCk7XG4gICAgLy8gZ28gdGhydSBnZXRTb3J0RGF0YSBvYmogYW5kIGFwcGx5IHRoZSBzb3J0ZXJzXG4gICAgdmFyIGdldFNvcnREYXRhID0gdGhpcy5sYXlvdXQub3B0aW9ucy5nZXRTb3J0RGF0YTtcbiAgICB2YXIgc29ydGVycyA9IHRoaXMubGF5b3V0Ll9zb3J0ZXJzO1xuICAgIGZvciAoIHZhciBrZXkgaW4gZ2V0U29ydERhdGEgKSB7XG4gICAgICB2YXIgc29ydGVyID0gc29ydGVyc1sga2V5IF07XG4gICAgICB0aGlzLnNvcnREYXRhWyBrZXkgXSA9IHNvcnRlciggdGhpcy5lbGVtZW50LCB0aGlzICk7XG4gICAgfVxuICB9O1xuICBcbiAgdmFyIF9kZXN0cm95ID0gcHJvdG8uZGVzdHJveTtcbiAgcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGNhbGwgc3VwZXJcbiAgICBfZGVzdHJveS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgLy8gcmVzZXQgZGlzcGxheSwgIzc0MVxuICAgIHRoaXMuY3NzKHtcbiAgICAgIGRpc3BsYXk6ICcnXG4gICAgfSk7XG4gIH07XG4gIFxuICByZXR1cm4gSXRlbTtcbiAgXG4gIH0pKTtcbiAgXG4gIC8qKlxuICAgKiBJc290b3BlIExheW91dE1vZGVcbiAgICovXG4gIFxuICAoIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gICAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gICAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi8gLypnbG9iYWxzIGRlZmluZSwgbW9kdWxlLCByZXF1aXJlICovXG4gICAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAgIC8vIEFNRFxuICAgICAgZGVmaW5lKCAnaXNvdG9wZS1sYXlvdXQvanMvbGF5b3V0LW1vZGUnLFtcbiAgICAgICAgICAnZ2V0LXNpemUvZ2V0LXNpemUnLFxuICAgICAgICAgICdvdXRsYXllci9vdXRsYXllcidcbiAgICAgICAgXSxcbiAgICAgICAgZmFjdG9yeSApO1xuICAgIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgICAvLyBDb21tb25KU1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICAgICAgICByZXF1aXJlKCdnZXQtc2l6ZScpLFxuICAgICAgICByZXF1aXJlKCdvdXRsYXllcicpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgICAgd2luZG93Lklzb3RvcGUgPSB3aW5kb3cuSXNvdG9wZSB8fCB7fTtcbiAgICAgIHdpbmRvdy5Jc290b3BlLkxheW91dE1vZGUgPSBmYWN0b3J5KFxuICAgICAgICB3aW5kb3cuZ2V0U2l6ZSxcbiAgICAgICAgd2luZG93Lk91dGxheWVyXG4gICAgICApO1xuICAgIH1cbiAgXG4gIH0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSggZ2V0U2l6ZSwgT3V0bGF5ZXIgKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICBcbiAgICAvLyBsYXlvdXQgbW9kZSBjbGFzc1xuICAgIGZ1bmN0aW9uIExheW91dE1vZGUoIGlzb3RvcGUgKSB7XG4gICAgICB0aGlzLmlzb3RvcGUgPSBpc290b3BlO1xuICAgICAgLy8gbGluayBwcm9wZXJ0aWVzXG4gICAgICBpZiAoIGlzb3RvcGUgKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGlzb3RvcGUub3B0aW9uc1sgdGhpcy5uYW1lc3BhY2UgXTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gaXNvdG9wZS5lbGVtZW50O1xuICAgICAgICB0aGlzLml0ZW1zID0gaXNvdG9wZS5maWx0ZXJlZEl0ZW1zO1xuICAgICAgICB0aGlzLnNpemUgPSBpc290b3BlLnNpemU7XG4gICAgICB9XG4gICAgfVxuICBcbiAgICB2YXIgcHJvdG8gPSBMYXlvdXRNb2RlLnByb3RvdHlwZTtcbiAgXG4gICAgLyoqXG4gICAgICogc29tZSBtZXRob2RzIHNob3VsZCBqdXN0IGRlZmVyIHRvIGRlZmF1bHQgT3V0bGF5ZXIgbWV0aG9kXG4gICAgICogYW5kIHJlZmVyZW5jZSB0aGUgSXNvdG9wZSBpbnN0YW5jZSBhcyBgdGhpc2BcbiAgICAqKi9cbiAgICB2YXIgZmFjYWRlTWV0aG9kcyA9IFtcbiAgICAgICdfcmVzZXRMYXlvdXQnLFxuICAgICAgJ19nZXRJdGVtTGF5b3V0UG9zaXRpb24nLFxuICAgICAgJ19tYW5hZ2VTdGFtcCcsXG4gICAgICAnX2dldENvbnRhaW5lclNpemUnLFxuICAgICAgJ19nZXRFbGVtZW50T2Zmc2V0JyxcbiAgICAgICduZWVkc1Jlc2l6ZUxheW91dCcsXG4gICAgICAnX2dldE9wdGlvbidcbiAgICBdO1xuICBcbiAgICBmYWNhZGVNZXRob2RzLmZvckVhY2goIGZ1bmN0aW9uKCBtZXRob2ROYW1lICkge1xuICAgICAgcHJvdG9bIG1ldGhvZE5hbWUgXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gT3V0bGF5ZXIucHJvdG90eXBlWyBtZXRob2ROYW1lIF0uYXBwbHkoIHRoaXMuaXNvdG9wZSwgYXJndW1lbnRzICk7XG4gICAgICB9O1xuICAgIH0pO1xuICBcbiAgICAvLyAtLS0tLSAgLS0tLS0gLy9cbiAgXG4gICAgLy8gZm9yIGhvcml6b250YWwgbGF5b3V0IG1vZGVzLCBjaGVjayB2ZXJ0aWNhbCBzaXplXG4gICAgcHJvdG8ubmVlZHNWZXJ0aWNhbFJlc2l6ZUxheW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gZG9uJ3QgdHJpZ2dlciBpZiBzaXplIGRpZCBub3QgY2hhbmdlXG4gICAgICB2YXIgc2l6ZSA9IGdldFNpemUoIHRoaXMuaXNvdG9wZS5lbGVtZW50ICk7XG4gICAgICAvLyBjaGVjayB0aGF0IHRoaXMuc2l6ZSBhbmQgc2l6ZSBhcmUgdGhlcmVcbiAgICAgIC8vIElFOCB0cmlnZ2VycyByZXNpemUgb24gYm9keSBzaXplIGNoYW5nZSwgc28gdGhleSBtaWdodCBub3QgYmVcbiAgICAgIHZhciBoYXNTaXplcyA9IHRoaXMuaXNvdG9wZS5zaXplICYmIHNpemU7XG4gICAgICByZXR1cm4gaGFzU2l6ZXMgJiYgc2l6ZS5pbm5lckhlaWdodCAhPSB0aGlzLmlzb3RvcGUuc2l6ZS5pbm5lckhlaWdodDtcbiAgICB9O1xuICBcbiAgICAvLyAtLS0tLSBtZWFzdXJlbWVudHMgLS0tLS0gLy9cbiAgXG4gICAgcHJvdG8uX2dldE1lYXN1cmVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzb3RvcGUuX2dldE1lYXN1cmVtZW50LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICB9O1xuICBcbiAgICBwcm90by5nZXRDb2x1bW5XaWR0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5nZXRTZWdtZW50U2l6ZSggJ2NvbHVtbicsICdXaWR0aCcgKTtcbiAgICB9O1xuICBcbiAgICBwcm90by5nZXRSb3dIZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZ2V0U2VnbWVudFNpemUoICdyb3cnLCAnSGVpZ2h0JyApO1xuICAgIH07XG4gIFxuICAgIC8qKlxuICAgICAqIGdldCBjb2x1bW5XaWR0aCBvciByb3dIZWlnaHRcbiAgICAgKiBzZWdtZW50OiAnY29sdW1uJyBvciAncm93J1xuICAgICAqIHNpemUgJ1dpZHRoJyBvciAnSGVpZ2h0J1xuICAgICoqL1xuICAgIHByb3RvLmdldFNlZ21lbnRTaXplID0gZnVuY3Rpb24oIHNlZ21lbnQsIHNpemUgKSB7XG4gICAgICB2YXIgc2VnbWVudE5hbWUgPSBzZWdtZW50ICsgc2l6ZTtcbiAgICAgIHZhciBvdXRlclNpemUgPSAnb3V0ZXInICsgc2l6ZTtcbiAgICAgIC8vIGNvbHVtbldpZHRoIC8gb3V0ZXJXaWR0aCAvLyByb3dIZWlnaHQgLyBvdXRlckhlaWdodFxuICAgICAgdGhpcy5fZ2V0TWVhc3VyZW1lbnQoIHNlZ21lbnROYW1lLCBvdXRlclNpemUgKTtcbiAgICAgIC8vIGdvdCByb3dIZWlnaHQgb3IgY29sdW1uV2lkdGgsIHdlIGNhbiBjaGlsbFxuICAgICAgaWYgKCB0aGlzWyBzZWdtZW50TmFtZSBdICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBmYWxsIGJhY2sgdG8gaXRlbSBvZiBmaXJzdCBlbGVtZW50XG4gICAgICB2YXIgZmlyc3RJdGVtU2l6ZSA9IHRoaXMuZ2V0Rmlyc3RJdGVtU2l6ZSgpO1xuICAgICAgdGhpc1sgc2VnbWVudE5hbWUgXSA9IGZpcnN0SXRlbVNpemUgJiYgZmlyc3RJdGVtU2l6ZVsgb3V0ZXJTaXplIF0gfHxcbiAgICAgICAgLy8gb3Igc2l6ZSBvZiBjb250YWluZXJcbiAgICAgICAgdGhpcy5pc290b3BlLnNpemVbICdpbm5lcicgKyBzaXplIF07XG4gICAgfTtcbiAgXG4gICAgcHJvdG8uZ2V0Rmlyc3RJdGVtU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGZpcnN0SXRlbSA9IHRoaXMuaXNvdG9wZS5maWx0ZXJlZEl0ZW1zWzBdO1xuICAgICAgcmV0dXJuIGZpcnN0SXRlbSAmJiBmaXJzdEl0ZW0uZWxlbWVudCAmJiBnZXRTaXplKCBmaXJzdEl0ZW0uZWxlbWVudCApO1xuICAgIH07XG4gIFxuICAgIC8vIC0tLS0tIG1ldGhvZHMgdGhhdCBzaG91bGQgcmVmZXJlbmNlIGlzb3RvcGUgLS0tLS0gLy9cbiAgXG4gICAgcHJvdG8ubGF5b3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzb3RvcGUubGF5b3V0LmFwcGx5KCB0aGlzLmlzb3RvcGUsIGFyZ3VtZW50cyApO1xuICAgIH07XG4gIFxuICAgIHByb3RvLmdldFNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaXNvdG9wZS5nZXRTaXplKCk7XG4gICAgICB0aGlzLnNpemUgPSB0aGlzLmlzb3RvcGUuc2l6ZTtcbiAgICB9O1xuICBcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBjcmVhdGUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cbiAgXG4gICAgTGF5b3V0TW9kZS5tb2RlcyA9IHt9O1xuICBcbiAgICBMYXlvdXRNb2RlLmNyZWF0ZSA9IGZ1bmN0aW9uKCBuYW1lc3BhY2UsIG9wdGlvbnMgKSB7XG4gIFxuICAgICAgZnVuY3Rpb24gTW9kZSgpIHtcbiAgICAgICAgTGF5b3V0TW9kZS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICB9XG4gIFxuICAgICAgTW9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBwcm90byApO1xuICAgICAgTW9kZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNb2RlO1xuICBcbiAgICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgaWYgKCBvcHRpb25zICkge1xuICAgICAgICBNb2RlLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgfVxuICBcbiAgICAgIE1vZGUucHJvdG90eXBlLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICAgIC8vIHJlZ2lzdGVyIGluIElzb3RvcGVcbiAgICAgIExheW91dE1vZGUubW9kZXNbIG5hbWVzcGFjZSBdID0gTW9kZTtcbiAgXG4gICAgICByZXR1cm4gTW9kZTtcbiAgICB9O1xuICBcbiAgICByZXR1cm4gTGF5b3V0TW9kZTtcbiAgXG4gIH0pKTtcbiAgXG4gIC8qIVxuICAgKiBNYXNvbnJ5IHY0LjIuMVxuICAgKiBDYXNjYWRpbmcgZ3JpZCBsYXlvdXQgbGlicmFyeVxuICAgKiBodHRwczovL21hc29ucnkuZGVzYW5kcm8uY29tXG4gICAqIE1JVCBMaWNlbnNlXG4gICAqIGJ5IERhdmlkIERlU2FuZHJvXG4gICAqL1xuICBcbiAgKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAgIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICAgIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSAqL1xuICAgIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgICAvLyBBTURcbiAgICAgIGRlZmluZSggJ21hc29ucnktbGF5b3V0L21hc29ucnknLFtcbiAgICAgICAgICAnb3V0bGF5ZXIvb3V0bGF5ZXInLFxuICAgICAgICAgICdnZXQtc2l6ZS9nZXQtc2l6ZSdcbiAgICAgICAgXSxcbiAgICAgICAgZmFjdG9yeSApO1xuICAgIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgICAvLyBDb21tb25KU1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICAgICAgICByZXF1aXJlKCdvdXRsYXllcicpLFxuICAgICAgICByZXF1aXJlKCdnZXQtc2l6ZScpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgICAgd2luZG93Lk1hc29ucnkgPSBmYWN0b3J5KFxuICAgICAgICB3aW5kb3cuT3V0bGF5ZXIsXG4gICAgICAgIHdpbmRvdy5nZXRTaXplXG4gICAgICApO1xuICAgIH1cbiAgXG4gIH0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSggT3V0bGF5ZXIsIGdldFNpemUgKSB7XG4gIFxuICBcbiAgXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIG1hc29ucnlEZWZpbml0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG4gIFxuICAgIC8vIGNyZWF0ZSBhbiBPdXRsYXllciBsYXlvdXQgY2xhc3NcbiAgICB2YXIgTWFzb25yeSA9IE91dGxheWVyLmNyZWF0ZSgnbWFzb25yeScpO1xuICAgIC8vIGlzRml0V2lkdGggLT4gZml0V2lkdGhcbiAgICBNYXNvbnJ5LmNvbXBhdE9wdGlvbnMuZml0V2lkdGggPSAnaXNGaXRXaWR0aCc7XG4gIFxuICAgIHZhciBwcm90byA9IE1hc29ucnkucHJvdG90eXBlO1xuICBcbiAgICBwcm90by5fcmVzZXRMYXlvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZ2V0U2l6ZSgpO1xuICAgICAgdGhpcy5fZ2V0TWVhc3VyZW1lbnQoICdjb2x1bW5XaWR0aCcsICdvdXRlcldpZHRoJyApO1xuICAgICAgdGhpcy5fZ2V0TWVhc3VyZW1lbnQoICdndXR0ZXInLCAnb3V0ZXJXaWR0aCcgKTtcbiAgICAgIHRoaXMubWVhc3VyZUNvbHVtbnMoKTtcbiAgXG4gICAgICAvLyByZXNldCBjb2x1bW4gWVxuICAgICAgdGhpcy5jb2xZcyA9IFtdO1xuICAgICAgZm9yICggdmFyIGk9MDsgaSA8IHRoaXMuY29sczsgaSsrICkge1xuICAgICAgICB0aGlzLmNvbFlzLnB1c2goIDAgKTtcbiAgICAgIH1cbiAgXG4gICAgICB0aGlzLm1heFkgPSAwO1xuICAgICAgdGhpcy5ob3Jpem9udGFsQ29sSW5kZXggPSAwO1xuICAgIH07XG4gIFxuICAgIHByb3RvLm1lYXN1cmVDb2x1bW5zID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmdldENvbnRhaW5lcldpZHRoKCk7XG4gICAgICAvLyBpZiBjb2x1bW5XaWR0aCBpcyAwLCBkZWZhdWx0IHRvIG91dGVyV2lkdGggb2YgZmlyc3QgaXRlbVxuICAgICAgaWYgKCAhdGhpcy5jb2x1bW5XaWR0aCApIHtcbiAgICAgICAgdmFyIGZpcnN0SXRlbSA9IHRoaXMuaXRlbXNbMF07XG4gICAgICAgIHZhciBmaXJzdEl0ZW1FbGVtID0gZmlyc3RJdGVtICYmIGZpcnN0SXRlbS5lbGVtZW50O1xuICAgICAgICAvLyBjb2x1bW5XaWR0aCBmYWxsIGJhY2sgdG8gaXRlbSBvZiBmaXJzdCBlbGVtZW50XG4gICAgICAgIHRoaXMuY29sdW1uV2lkdGggPSBmaXJzdEl0ZW1FbGVtICYmIGdldFNpemUoIGZpcnN0SXRlbUVsZW0gKS5vdXRlcldpZHRoIHx8XG4gICAgICAgICAgLy8gaWYgZmlyc3QgZWxlbSBoYXMgbm8gd2lkdGgsIGRlZmF1bHQgdG8gc2l6ZSBvZiBjb250YWluZXJcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lcldpZHRoO1xuICAgICAgfVxuICBcbiAgICAgIHZhciBjb2x1bW5XaWR0aCA9IHRoaXMuY29sdW1uV2lkdGggKz0gdGhpcy5ndXR0ZXI7XG4gIFxuICAgICAgLy8gY2FsY3VsYXRlIGNvbHVtbnNcbiAgICAgIHZhciBjb250YWluZXJXaWR0aCA9IHRoaXMuY29udGFpbmVyV2lkdGggKyB0aGlzLmd1dHRlcjtcbiAgICAgIHZhciBjb2xzID0gY29udGFpbmVyV2lkdGggLyBjb2x1bW5XaWR0aDtcbiAgICAgIC8vIGZpeCByb3VuZGluZyBlcnJvcnMsIHR5cGljYWxseSB3aXRoIGd1dHRlcnNcbiAgICAgIHZhciBleGNlc3MgPSBjb2x1bW5XaWR0aCAtIGNvbnRhaW5lcldpZHRoICUgY29sdW1uV2lkdGg7XG4gICAgICAvLyBpZiBvdmVyc2hvb3QgaXMgbGVzcyB0aGFuIGEgcGl4ZWwsIHJvdW5kIHVwLCBvdGhlcndpc2UgZmxvb3IgaXRcbiAgICAgIHZhciBtYXRoTWV0aG9kID0gZXhjZXNzICYmIGV4Y2VzcyA8IDEgPyAncm91bmQnIDogJ2Zsb29yJztcbiAgICAgIGNvbHMgPSBNYXRoWyBtYXRoTWV0aG9kIF0oIGNvbHMgKTtcbiAgICAgIHRoaXMuY29scyA9IE1hdGgubWF4KCBjb2xzLCAxICk7XG4gICAgfTtcbiAgXG4gICAgcHJvdG8uZ2V0Q29udGFpbmVyV2lkdGggPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGNvbnRhaW5lciBpcyBwYXJlbnQgaWYgZml0IHdpZHRoXG4gICAgICB2YXIgaXNGaXRXaWR0aCA9IHRoaXMuX2dldE9wdGlvbignZml0V2lkdGgnKTtcbiAgICAgIHZhciBjb250YWluZXIgPSBpc0ZpdFdpZHRoID8gdGhpcy5lbGVtZW50LnBhcmVudE5vZGUgOiB0aGlzLmVsZW1lbnQ7XG4gICAgICAvLyBjaGVjayB0aGF0IHRoaXMuc2l6ZSBhbmQgc2l6ZSBhcmUgdGhlcmVcbiAgICAgIC8vIElFOCB0cmlnZ2VycyByZXNpemUgb24gYm9keSBzaXplIGNoYW5nZSwgc28gdGhleSBtaWdodCBub3QgYmVcbiAgICAgIHZhciBzaXplID0gZ2V0U2l6ZSggY29udGFpbmVyICk7XG4gICAgICB0aGlzLmNvbnRhaW5lcldpZHRoID0gc2l6ZSAmJiBzaXplLmlubmVyV2lkdGg7XG4gICAgfTtcbiAgXG4gICAgcHJvdG8uX2dldEl0ZW1MYXlvdXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCBpdGVtICkge1xuICAgICAgaXRlbS5nZXRTaXplKCk7XG4gICAgICAvLyBob3cgbWFueSBjb2x1bW5zIGRvZXMgdGhpcyBicmljayBzcGFuXG4gICAgICB2YXIgcmVtYWluZGVyID0gaXRlbS5zaXplLm91dGVyV2lkdGggJSB0aGlzLmNvbHVtbldpZHRoO1xuICAgICAgdmFyIG1hdGhNZXRob2QgPSByZW1haW5kZXIgJiYgcmVtYWluZGVyIDwgMSA/ICdyb3VuZCcgOiAnY2VpbCc7XG4gICAgICAvLyByb3VuZCBpZiBvZmYgYnkgMSBwaXhlbCwgb3RoZXJ3aXNlIHVzZSBjZWlsXG4gICAgICB2YXIgY29sU3BhbiA9IE1hdGhbIG1hdGhNZXRob2QgXSggaXRlbS5zaXplLm91dGVyV2lkdGggLyB0aGlzLmNvbHVtbldpZHRoICk7XG4gICAgICBjb2xTcGFuID0gTWF0aC5taW4oIGNvbFNwYW4sIHRoaXMuY29scyApO1xuICAgICAgLy8gdXNlIGhvcml6b250YWwgb3IgdG9wIGNvbHVtbiBwb3NpdGlvblxuICAgICAgdmFyIGNvbFBvc01ldGhvZCA9IHRoaXMub3B0aW9ucy5ob3Jpem9udGFsT3JkZXIgP1xuICAgICAgICAnX2dldEhvcml6b250YWxDb2xQb3NpdGlvbicgOiAnX2dldFRvcENvbFBvc2l0aW9uJztcbiAgICAgIHZhciBjb2xQb3NpdGlvbiA9IHRoaXNbIGNvbFBvc01ldGhvZCBdKCBjb2xTcGFuLCBpdGVtICk7XG4gICAgICAvLyBwb3NpdGlvbiB0aGUgYnJpY2tcbiAgICAgIHZhciBwb3NpdGlvbiA9IHtcbiAgICAgICAgeDogdGhpcy5jb2x1bW5XaWR0aCAqIGNvbFBvc2l0aW9uLmNvbCxcbiAgICAgICAgeTogY29sUG9zaXRpb24ueVxuICAgICAgfTtcbiAgICAgIC8vIGFwcGx5IHNldEhlaWdodCB0byBuZWNlc3NhcnkgY29sdW1uc1xuICAgICAgdmFyIHNldEhlaWdodCA9IGNvbFBvc2l0aW9uLnkgKyBpdGVtLnNpemUub3V0ZXJIZWlnaHQ7XG4gICAgICB2YXIgc2V0TWF4ID0gY29sU3BhbiArIGNvbFBvc2l0aW9uLmNvbDtcbiAgICAgIGZvciAoIHZhciBpID0gY29sUG9zaXRpb24uY29sOyBpIDwgc2V0TWF4OyBpKysgKSB7XG4gICAgICAgIHRoaXMuY29sWXNbaV0gPSBzZXRIZWlnaHQ7XG4gICAgICB9XG4gIFxuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH07XG4gIFxuICAgIHByb3RvLl9nZXRUb3BDb2xQb3NpdGlvbiA9IGZ1bmN0aW9uKCBjb2xTcGFuICkge1xuICAgICAgdmFyIGNvbEdyb3VwID0gdGhpcy5fZ2V0VG9wQ29sR3JvdXAoIGNvbFNwYW4gKTtcbiAgICAgIC8vIGdldCB0aGUgbWluaW11bSBZIHZhbHVlIGZyb20gdGhlIGNvbHVtbnNcbiAgICAgIHZhciBtaW5pbXVtWSA9IE1hdGgubWluLmFwcGx5KCBNYXRoLCBjb2xHcm91cCApO1xuICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbDogY29sR3JvdXAuaW5kZXhPZiggbWluaW11bVkgKSxcbiAgICAgICAgeTogbWluaW11bVksXG4gICAgICB9O1xuICAgIH07XG4gIFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb2xTcGFuIC0gbnVtYmVyIG9mIGNvbHVtbnMgdGhlIGVsZW1lbnQgc3BhbnNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGNvbEdyb3VwXG4gICAgICovXG4gICAgcHJvdG8uX2dldFRvcENvbEdyb3VwID0gZnVuY3Rpb24oIGNvbFNwYW4gKSB7XG4gICAgICBpZiAoIGNvbFNwYW4gPCAyICkge1xuICAgICAgICAvLyBpZiBicmljayBzcGFucyBvbmx5IG9uZSBjb2x1bW4sIHVzZSBhbGwgdGhlIGNvbHVtbiBZc1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xZcztcbiAgICAgIH1cbiAgXG4gICAgICB2YXIgY29sR3JvdXAgPSBbXTtcbiAgICAgIC8vIGhvdyBtYW55IGRpZmZlcmVudCBwbGFjZXMgY291bGQgdGhpcyBicmljayBmaXQgaG9yaXpvbnRhbGx5XG4gICAgICB2YXIgZ3JvdXBDb3VudCA9IHRoaXMuY29scyArIDEgLSBjb2xTcGFuO1xuICAgICAgLy8gZm9yIGVhY2ggZ3JvdXAgcG90ZW50aWFsIGhvcml6b250YWwgcG9zaXRpb25cbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGdyb3VwQ291bnQ7IGkrKyApIHtcbiAgICAgICAgY29sR3JvdXBbaV0gPSB0aGlzLl9nZXRDb2xHcm91cFkoIGksIGNvbFNwYW4gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2xHcm91cDtcbiAgICB9O1xuICBcbiAgICBwcm90by5fZ2V0Q29sR3JvdXBZID0gZnVuY3Rpb24oIGNvbCwgY29sU3BhbiApIHtcbiAgICAgIGlmICggY29sU3BhbiA8IDIgKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbFlzWyBjb2wgXTtcbiAgICAgIH1cbiAgICAgIC8vIG1ha2UgYW4gYXJyYXkgb2YgY29sWSB2YWx1ZXMgZm9yIHRoYXQgb25lIGdyb3VwXG4gICAgICB2YXIgZ3JvdXBDb2xZcyA9IHRoaXMuY29sWXMuc2xpY2UoIGNvbCwgY29sICsgY29sU3BhbiApO1xuICAgICAgLy8gYW5kIGdldCB0aGUgbWF4IHZhbHVlIG9mIHRoZSBhcnJheVxuICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KCBNYXRoLCBncm91cENvbFlzICk7XG4gICAgfTtcbiAgXG4gICAgLy8gZ2V0IGNvbHVtbiBwb3NpdGlvbiBiYXNlZCBvbiBob3Jpem9udGFsIGluZGV4LiAjODczXG4gICAgcHJvdG8uX2dldEhvcml6b250YWxDb2xQb3NpdGlvbiA9IGZ1bmN0aW9uKCBjb2xTcGFuLCBpdGVtICkge1xuICAgICAgdmFyIGNvbCA9IHRoaXMuaG9yaXpvbnRhbENvbEluZGV4ICUgdGhpcy5jb2xzO1xuICAgICAgdmFyIGlzT3ZlciA9IGNvbFNwYW4gPiAxICYmIGNvbCArIGNvbFNwYW4gPiB0aGlzLmNvbHM7XG4gICAgICAvLyBzaGlmdCB0byBuZXh0IHJvdyBpZiBpdGVtIGNhbid0IGZpdCBvbiBjdXJyZW50IHJvd1xuICAgICAgY29sID0gaXNPdmVyID8gMCA6IGNvbDtcbiAgICAgIC8vIGRvbid0IGxldCB6ZXJvLXNpemUgaXRlbXMgdGFrZSB1cCBzcGFjZVxuICAgICAgdmFyIGhhc1NpemUgPSBpdGVtLnNpemUub3V0ZXJXaWR0aCAmJiBpdGVtLnNpemUub3V0ZXJIZWlnaHQ7XG4gICAgICB0aGlzLmhvcml6b250YWxDb2xJbmRleCA9IGhhc1NpemUgPyBjb2wgKyBjb2xTcGFuIDogdGhpcy5ob3Jpem9udGFsQ29sSW5kZXg7XG4gIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29sOiBjb2wsXG4gICAgICAgIHk6IHRoaXMuX2dldENvbEdyb3VwWSggY29sLCBjb2xTcGFuICksXG4gICAgICB9O1xuICAgIH07XG4gIFxuICAgIHByb3RvLl9tYW5hZ2VTdGFtcCA9IGZ1bmN0aW9uKCBzdGFtcCApIHtcbiAgICAgIHZhciBzdGFtcFNpemUgPSBnZXRTaXplKCBzdGFtcCApO1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX2dldEVsZW1lbnRPZmZzZXQoIHN0YW1wICk7XG4gICAgICAvLyBnZXQgdGhlIGNvbHVtbnMgdGhhdCB0aGlzIHN0YW1wIGFmZmVjdHNcbiAgICAgIHZhciBpc09yaWdpbkxlZnQgPSB0aGlzLl9nZXRPcHRpb24oJ29yaWdpbkxlZnQnKTtcbiAgICAgIHZhciBmaXJzdFggPSBpc09yaWdpbkxlZnQgPyBvZmZzZXQubGVmdCA6IG9mZnNldC5yaWdodDtcbiAgICAgIHZhciBsYXN0WCA9IGZpcnN0WCArIHN0YW1wU2l6ZS5vdXRlcldpZHRoO1xuICAgICAgdmFyIGZpcnN0Q29sID0gTWF0aC5mbG9vciggZmlyc3RYIC8gdGhpcy5jb2x1bW5XaWR0aCApO1xuICAgICAgZmlyc3RDb2wgPSBNYXRoLm1heCggMCwgZmlyc3RDb2wgKTtcbiAgICAgIHZhciBsYXN0Q29sID0gTWF0aC5mbG9vciggbGFzdFggLyB0aGlzLmNvbHVtbldpZHRoICk7XG4gICAgICAvLyBsYXN0Q29sIHNob3VsZCBub3QgZ28gb3ZlciBpZiBtdWx0aXBsZSBvZiBjb2x1bW5XaWR0aCAjNDI1XG4gICAgICBsYXN0Q29sIC09IGxhc3RYICUgdGhpcy5jb2x1bW5XaWR0aCA/IDAgOiAxO1xuICAgICAgbGFzdENvbCA9IE1hdGgubWluKCB0aGlzLmNvbHMgLSAxLCBsYXN0Q29sICk7XG4gICAgICAvLyBzZXQgY29sWXMgdG8gYm90dG9tIG9mIHRoZSBzdGFtcFxuICBcbiAgICAgIHZhciBpc09yaWdpblRvcCA9IHRoaXMuX2dldE9wdGlvbignb3JpZ2luVG9wJyk7XG4gICAgICB2YXIgc3RhbXBNYXhZID0gKCBpc09yaWdpblRvcCA/IG9mZnNldC50b3AgOiBvZmZzZXQuYm90dG9tICkgK1xuICAgICAgICBzdGFtcFNpemUub3V0ZXJIZWlnaHQ7XG4gICAgICBmb3IgKCB2YXIgaSA9IGZpcnN0Q29sOyBpIDw9IGxhc3RDb2w7IGkrKyApIHtcbiAgICAgICAgdGhpcy5jb2xZc1tpXSA9IE1hdGgubWF4KCBzdGFtcE1heFksIHRoaXMuY29sWXNbaV0gKTtcbiAgICAgIH1cbiAgICB9O1xuICBcbiAgICBwcm90by5fZ2V0Q29udGFpbmVyU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5tYXhZID0gTWF0aC5tYXguYXBwbHkoIE1hdGgsIHRoaXMuY29sWXMgKTtcbiAgICAgIHZhciBzaXplID0ge1xuICAgICAgICBoZWlnaHQ6IHRoaXMubWF4WVxuICAgICAgfTtcbiAgXG4gICAgICBpZiAoIHRoaXMuX2dldE9wdGlvbignZml0V2lkdGgnKSApIHtcbiAgICAgICAgc2l6ZS53aWR0aCA9IHRoaXMuX2dldENvbnRhaW5lckZpdFdpZHRoKCk7XG4gICAgICB9XG4gIFxuICAgICAgcmV0dXJuIHNpemU7XG4gICAgfTtcbiAgXG4gICAgcHJvdG8uX2dldENvbnRhaW5lckZpdFdpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdW51c2VkQ29scyA9IDA7XG4gICAgICAvLyBjb3VudCB1bnVzZWQgY29sdW1uc1xuICAgICAgdmFyIGkgPSB0aGlzLmNvbHM7XG4gICAgICB3aGlsZSAoIC0taSApIHtcbiAgICAgICAgaWYgKCB0aGlzLmNvbFlzW2ldICE9PSAwICkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHVudXNlZENvbHMrKztcbiAgICAgIH1cbiAgICAgIC8vIGZpdCBjb250YWluZXIgdG8gY29sdW1ucyB0aGF0IGhhdmUgYmVlbiB1c2VkXG4gICAgICByZXR1cm4gKCB0aGlzLmNvbHMgLSB1bnVzZWRDb2xzICkgKiB0aGlzLmNvbHVtbldpZHRoIC0gdGhpcy5ndXR0ZXI7XG4gICAgfTtcbiAgXG4gICAgcHJvdG8ubmVlZHNSZXNpemVMYXlvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwcmV2aW91c1dpZHRoID0gdGhpcy5jb250YWluZXJXaWR0aDtcbiAgICAgIHRoaXMuZ2V0Q29udGFpbmVyV2lkdGgoKTtcbiAgICAgIHJldHVybiBwcmV2aW91c1dpZHRoICE9IHRoaXMuY29udGFpbmVyV2lkdGg7XG4gICAgfTtcbiAgXG4gICAgcmV0dXJuIE1hc29ucnk7XG4gIFxuICB9KSk7XG4gIFxuICAvKiFcbiAgICogTWFzb25yeSBsYXlvdXQgbW9kZVxuICAgKiBzdWItY2xhc3NlcyBNYXNvbnJ5XG4gICAqIGh0dHBzOi8vbWFzb25yeS5kZXNhbmRyby5jb21cbiAgICovXG4gIFxuICAoIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gICAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gICAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi8gLypnbG9iYWxzIGRlZmluZSwgbW9kdWxlLCByZXF1aXJlICovXG4gICAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAgIC8vIEFNRFxuICAgICAgZGVmaW5lKCAnaXNvdG9wZS1sYXlvdXQvanMvbGF5b3V0LW1vZGVzL21hc29ucnknLFtcbiAgICAgICAgICAnLi4vbGF5b3V0LW1vZGUnLFxuICAgICAgICAgICdtYXNvbnJ5LWxheW91dC9tYXNvbnJ5J1xuICAgICAgICBdLFxuICAgICAgICBmYWN0b3J5ICk7XG4gICAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAgIC8vIENvbW1vbkpTXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXG4gICAgICAgIHJlcXVpcmUoJy4uL2xheW91dC1tb2RlJyksXG4gICAgICAgIHJlcXVpcmUoJ21hc29ucnktbGF5b3V0JylcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgICBmYWN0b3J5KFxuICAgICAgICB3aW5kb3cuSXNvdG9wZS5MYXlvdXRNb2RlLFxuICAgICAgICB3aW5kb3cuTWFzb25yeVxuICAgICAgKTtcbiAgICB9XG4gIFxuICB9KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIExheW91dE1vZGUsIE1hc29ucnkgKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIG1hc29ucnlEZWZpbml0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG4gIFxuICAgIC8vIGNyZWF0ZSBhbiBPdXRsYXllciBsYXlvdXQgY2xhc3NcbiAgICB2YXIgTWFzb25yeU1vZGUgPSBMYXlvdXRNb2RlLmNyZWF0ZSgnbWFzb25yeScpO1xuICBcbiAgICB2YXIgcHJvdG8gPSBNYXNvbnJ5TW9kZS5wcm90b3R5cGU7XG4gIFxuICAgIHZhciBrZWVwTW9kZU1ldGhvZHMgPSB7XG4gICAgICBfZ2V0RWxlbWVudE9mZnNldDogdHJ1ZSxcbiAgICAgIGxheW91dDogdHJ1ZSxcbiAgICAgIF9nZXRNZWFzdXJlbWVudDogdHJ1ZVxuICAgIH07XG4gIFxuICAgIC8vIGluaGVyaXQgTWFzb25yeSBwcm90b3R5cGVcbiAgICBmb3IgKCB2YXIgbWV0aG9kIGluIE1hc29ucnkucHJvdG90eXBlICkge1xuICAgICAgLy8gZG8gbm90IGluaGVyaXQgbW9kZSBtZXRob2RzXG4gICAgICBpZiAoICFrZWVwTW9kZU1ldGhvZHNbIG1ldGhvZCBdICkge1xuICAgICAgICBwcm90b1sgbWV0aG9kIF0gPSBNYXNvbnJ5LnByb3RvdHlwZVsgbWV0aG9kIF07XG4gICAgICB9XG4gICAgfVxuICBcbiAgICB2YXIgbWVhc3VyZUNvbHVtbnMgPSBwcm90by5tZWFzdXJlQ29sdW1ucztcbiAgICBwcm90by5tZWFzdXJlQ29sdW1ucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gc2V0IGl0ZW1zLCB1c2VkIGlmIG1lYXN1cmluZyBmaXJzdCBpdGVtXG4gICAgICB0aGlzLml0ZW1zID0gdGhpcy5pc290b3BlLmZpbHRlcmVkSXRlbXM7XG4gICAgICBtZWFzdXJlQ29sdW1ucy5jYWxsKCB0aGlzICk7XG4gICAgfTtcbiAgXG4gICAgLy8gcG9pbnQgdG8gbW9kZSBvcHRpb25zIGZvciBmaXRXaWR0aFxuICAgIHZhciBfZ2V0T3B0aW9uID0gcHJvdG8uX2dldE9wdGlvbjtcbiAgICBwcm90by5fZ2V0T3B0aW9uID0gZnVuY3Rpb24oIG9wdGlvbiApIHtcbiAgICAgIGlmICggb3B0aW9uID09ICdmaXRXaWR0aCcgKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaXNGaXRXaWR0aCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICB0aGlzLm9wdGlvbnMuaXNGaXRXaWR0aCA6IHRoaXMub3B0aW9ucy5maXRXaWR0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfZ2V0T3B0aW9uLmFwcGx5KCB0aGlzLmlzb3RvcGUsIGFyZ3VtZW50cyApO1xuICAgIH07XG4gIFxuICAgIHJldHVybiBNYXNvbnJ5TW9kZTtcbiAgXG4gIH0pKTtcbiAgXG4gIC8qKlxuICAgKiBmaXRSb3dzIGxheW91dCBtb2RlXG4gICAqL1xuICBcbiAgKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAgIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICAgIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSAqL1xuICAgIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgICAvLyBBTURcbiAgICAgIGRlZmluZSggJ2lzb3RvcGUtbGF5b3V0L2pzL2xheW91dC1tb2Rlcy9maXQtcm93cycsW1xuICAgICAgICAgICcuLi9sYXlvdXQtbW9kZSdcbiAgICAgICAgXSxcbiAgICAgICAgZmFjdG9yeSApO1xuICAgIH0gZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICkge1xuICAgICAgLy8gQ29tbW9uSlNcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgICAgcmVxdWlyZSgnLi4vbGF5b3V0LW1vZGUnKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICAgIGZhY3RvcnkoXG4gICAgICAgIHdpbmRvdy5Jc290b3BlLkxheW91dE1vZGVcbiAgICAgICk7XG4gICAgfVxuICBcbiAgfSggd2luZG93LCBmdW5jdGlvbiBmYWN0b3J5KCBMYXlvdXRNb2RlICkge1xuICAndXNlIHN0cmljdCc7XG4gIFxuICB2YXIgRml0Um93cyA9IExheW91dE1vZGUuY3JlYXRlKCdmaXRSb3dzJyk7XG4gIFxuICB2YXIgcHJvdG8gPSBGaXRSb3dzLnByb3RvdHlwZTtcbiAgXG4gIHByb3RvLl9yZXNldExheW91dCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLm1heFkgPSAwO1xuICAgIHRoaXMuX2dldE1lYXN1cmVtZW50KCAnZ3V0dGVyJywgJ291dGVyV2lkdGgnICk7XG4gIH07XG4gIFxuICBwcm90by5fZ2V0SXRlbUxheW91dFBvc2l0aW9uID0gZnVuY3Rpb24oIGl0ZW0gKSB7XG4gICAgaXRlbS5nZXRTaXplKCk7XG4gIFxuICAgIHZhciBpdGVtV2lkdGggPSBpdGVtLnNpemUub3V0ZXJXaWR0aCArIHRoaXMuZ3V0dGVyO1xuICAgIC8vIGlmIHRoaXMgZWxlbWVudCBjYW5ub3QgZml0IGluIHRoZSBjdXJyZW50IHJvd1xuICAgIHZhciBjb250YWluZXJXaWR0aCA9IHRoaXMuaXNvdG9wZS5zaXplLmlubmVyV2lkdGggKyB0aGlzLmd1dHRlcjtcbiAgICBpZiAoIHRoaXMueCAhPT0gMCAmJiBpdGVtV2lkdGggKyB0aGlzLnggPiBjb250YWluZXJXaWR0aCApIHtcbiAgICAgIHRoaXMueCA9IDA7XG4gICAgICB0aGlzLnkgPSB0aGlzLm1heFk7XG4gICAgfVxuICBcbiAgICB2YXIgcG9zaXRpb24gPSB7XG4gICAgICB4OiB0aGlzLngsXG4gICAgICB5OiB0aGlzLnlcbiAgICB9O1xuICBcbiAgICB0aGlzLm1heFkgPSBNYXRoLm1heCggdGhpcy5tYXhZLCB0aGlzLnkgKyBpdGVtLnNpemUub3V0ZXJIZWlnaHQgKTtcbiAgICB0aGlzLnggKz0gaXRlbVdpZHRoO1xuICBcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH07XG4gIFxuICBwcm90by5fZ2V0Q29udGFpbmVyU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7IGhlaWdodDogdGhpcy5tYXhZIH07XG4gIH07XG4gIFxuICByZXR1cm4gRml0Um93cztcbiAgXG4gIH0pKTtcbiAgXG4gIC8qKlxuICAgKiB2ZXJ0aWNhbCBsYXlvdXQgbW9kZVxuICAgKi9cbiAgXG4gICggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgICAvKiBqc2hpbnQgc3RyaWN0OiBmYWxzZSAqLyAvKmdsb2JhbHMgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cbiAgICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgICAgLy8gQU1EXG4gICAgICBkZWZpbmUoICdpc290b3BlLWxheW91dC9qcy9sYXlvdXQtbW9kZXMvdmVydGljYWwnLFtcbiAgICAgICAgICAnLi4vbGF5b3V0LW1vZGUnXG4gICAgICAgIF0sXG4gICAgICAgIGZhY3RvcnkgKTtcbiAgICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgICAgLy8gQ29tbW9uSlNcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgICAgcmVxdWlyZSgnLi4vbGF5b3V0LW1vZGUnKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICAgIGZhY3RvcnkoXG4gICAgICAgIHdpbmRvdy5Jc290b3BlLkxheW91dE1vZGVcbiAgICAgICk7XG4gICAgfVxuICBcbiAgfSggd2luZG93LCBmdW5jdGlvbiBmYWN0b3J5KCBMYXlvdXRNb2RlICkge1xuICAndXNlIHN0cmljdCc7XG4gIFxuICB2YXIgVmVydGljYWwgPSBMYXlvdXRNb2RlLmNyZWF0ZSggJ3ZlcnRpY2FsJywge1xuICAgIGhvcml6b250YWxBbGlnbm1lbnQ6IDBcbiAgfSk7XG4gIFxuICB2YXIgcHJvdG8gPSBWZXJ0aWNhbC5wcm90b3R5cGU7XG4gIFxuICBwcm90by5fcmVzZXRMYXlvdXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnkgPSAwO1xuICB9O1xuICBcbiAgcHJvdG8uX2dldEl0ZW1MYXlvdXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCBpdGVtICkge1xuICAgIGl0ZW0uZ2V0U2l6ZSgpO1xuICAgIHZhciB4ID0gKCB0aGlzLmlzb3RvcGUuc2l6ZS5pbm5lcldpZHRoIC0gaXRlbS5zaXplLm91dGVyV2lkdGggKSAqXG4gICAgICB0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbEFsaWdubWVudDtcbiAgICB2YXIgeSA9IHRoaXMueTtcbiAgICB0aGlzLnkgKz0gaXRlbS5zaXplLm91dGVySGVpZ2h0O1xuICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbiAgfTtcbiAgXG4gIHByb3RvLl9nZXRDb250YWluZXJTaXplID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHsgaGVpZ2h0OiB0aGlzLnkgfTtcbiAgfTtcbiAgXG4gIHJldHVybiBWZXJ0aWNhbDtcbiAgXG4gIH0pKTtcbiAgXG4gIC8qIVxuICAgKiBJc290b3BlIHYzLjAuNlxuICAgKlxuICAgKiBMaWNlbnNlZCBHUEx2MyBmb3Igb3BlbiBzb3VyY2UgdXNlXG4gICAqIG9yIElzb3RvcGUgQ29tbWVyY2lhbCBMaWNlbnNlIGZvciBjb21tZXJjaWFsIHVzZVxuICAgKlxuICAgKiBodHRwczovL2lzb3RvcGUubWV0YWZpenp5LmNvXG4gICAqIENvcHlyaWdodCAyMDEwLTIwMTggTWV0YWZpenp5XG4gICAqL1xuICBcbiAgKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAgIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICAgIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSAqL1xuICAgIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgICAvLyBBTURcbiAgICAgIGRlZmluZSggW1xuICAgICAgICAgICdvdXRsYXllci9vdXRsYXllcicsXG4gICAgICAgICAgJ2dldC1zaXplL2dldC1zaXplJyxcbiAgICAgICAgICAnZGVzYW5kcm8tbWF0Y2hlcy1zZWxlY3Rvci9tYXRjaGVzLXNlbGVjdG9yJyxcbiAgICAgICAgICAnZml6enktdWktdXRpbHMvdXRpbHMnLFxuICAgICAgICAgICdpc290b3BlLWxheW91dC9qcy9pdGVtJyxcbiAgICAgICAgICAnaXNvdG9wZS1sYXlvdXQvanMvbGF5b3V0LW1vZGUnLFxuICAgICAgICAgIC8vIGluY2x1ZGUgZGVmYXVsdCBsYXlvdXQgbW9kZXNcbiAgICAgICAgICAnaXNvdG9wZS1sYXlvdXQvanMvbGF5b3V0LW1vZGVzL21hc29ucnknLFxuICAgICAgICAgICdpc290b3BlLWxheW91dC9qcy9sYXlvdXQtbW9kZXMvZml0LXJvd3MnLFxuICAgICAgICAgICdpc290b3BlLWxheW91dC9qcy9sYXlvdXQtbW9kZXMvdmVydGljYWwnXG4gICAgICAgIF0sXG4gICAgICAgIGZ1bmN0aW9uKCBPdXRsYXllciwgZ2V0U2l6ZSwgbWF0Y2hlc1NlbGVjdG9yLCB1dGlscywgSXRlbSwgTGF5b3V0TW9kZSApIHtcbiAgICAgICAgICByZXR1cm4gZmFjdG9yeSggd2luZG93LCBPdXRsYXllciwgZ2V0U2l6ZSwgbWF0Y2hlc1NlbGVjdG9yLCB1dGlscywgSXRlbSwgTGF5b3V0TW9kZSApO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgICAgLy8gQ29tbW9uSlNcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgICAgd2luZG93LFxuICAgICAgICByZXF1aXJlKCdvdXRsYXllcicpLFxuICAgICAgICByZXF1aXJlKCdnZXQtc2l6ZScpLFxuICAgICAgICByZXF1aXJlKCdkZXNhbmRyby1tYXRjaGVzLXNlbGVjdG9yJyksXG4gICAgICAgIHJlcXVpcmUoJ2Zpenp5LXVpLXV0aWxzJyksXG4gICAgICAgIHJlcXVpcmUoJ2lzb3RvcGUtbGF5b3V0L2pzL2l0ZW0nKSxcbiAgICAgICAgcmVxdWlyZSgnaXNvdG9wZS1sYXlvdXQvanMvbGF5b3V0LW1vZGUnKSxcbiAgICAgICAgLy8gaW5jbHVkZSBkZWZhdWx0IGxheW91dCBtb2Rlc1xuICAgICAgICByZXF1aXJlKCdpc290b3BlLWxheW91dC9qcy9sYXlvdXQtbW9kZXMvbWFzb25yeScpLFxuICAgICAgICByZXF1aXJlKCdpc290b3BlLWxheW91dC9qcy9sYXlvdXQtbW9kZXMvZml0LXJvd3MnKSxcbiAgICAgICAgcmVxdWlyZSgnaXNvdG9wZS1sYXlvdXQvanMvbGF5b3V0LW1vZGVzL3ZlcnRpY2FsJylcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgICB3aW5kb3cuSXNvdG9wZSA9IGZhY3RvcnkoXG4gICAgICAgIHdpbmRvdyxcbiAgICAgICAgd2luZG93Lk91dGxheWVyLFxuICAgICAgICB3aW5kb3cuZ2V0U2l6ZSxcbiAgICAgICAgd2luZG93Lm1hdGNoZXNTZWxlY3RvcixcbiAgICAgICAgd2luZG93LmZpenp5VUlVdGlscyxcbiAgICAgICAgd2luZG93Lklzb3RvcGUuSXRlbSxcbiAgICAgICAgd2luZG93Lklzb3RvcGUuTGF5b3V0TW9kZVxuICAgICAgKTtcbiAgICB9XG4gIFxuICB9KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgT3V0bGF5ZXIsIGdldFNpemUsIG1hdGNoZXNTZWxlY3RvciwgdXRpbHMsXG4gICAgSXRlbSwgTGF5b3V0TW9kZSApIHtcbiAgXG4gIFxuICBcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gdmFycyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICBcbiAgdmFyIGpRdWVyeSA9IHdpbmRvdy5qUXVlcnk7XG4gIFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBoZWxwZXJzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG4gIFxuICB2YXIgdHJpbSA9IFN0cmluZy5wcm90b3R5cGUudHJpbSA/XG4gICAgZnVuY3Rpb24oIHN0ciApIHtcbiAgICAgIHJldHVybiBzdHIudHJpbSgpO1xuICAgIH0gOlxuICAgIGZ1bmN0aW9uKCBzdHIgKSB7XG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoIC9eXFxzK3xcXHMrJC9nLCAnJyApO1xuICAgIH07XG4gIFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBpc290b3BlRGVmaW5pdGlvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICBcbiAgICAvLyBjcmVhdGUgYW4gT3V0bGF5ZXIgbGF5b3V0IGNsYXNzXG4gICAgdmFyIElzb3RvcGUgPSBPdXRsYXllci5jcmVhdGUoICdpc290b3BlJywge1xuICAgICAgbGF5b3V0TW9kZTogJ21hc29ucnknLFxuICAgICAgaXNKUXVlcnlGaWx0ZXJpbmc6IHRydWUsXG4gICAgICBzb3J0QXNjZW5kaW5nOiB0cnVlXG4gICAgfSk7XG4gIFxuICAgIElzb3RvcGUuSXRlbSA9IEl0ZW07XG4gICAgSXNvdG9wZS5MYXlvdXRNb2RlID0gTGF5b3V0TW9kZTtcbiAgXG4gICAgdmFyIHByb3RvID0gSXNvdG9wZS5wcm90b3R5cGU7XG4gIFxuICAgIHByb3RvLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaXRlbUdVSUQgPSAwO1xuICAgICAgLy8gZnVuY3Rpb25zIHRoYXQgc29ydCBpdGVtc1xuICAgICAgdGhpcy5fc29ydGVycyA9IHt9O1xuICAgICAgdGhpcy5fZ2V0U29ydGVycygpO1xuICAgICAgLy8gY2FsbCBzdXBlclxuICAgICAgT3V0bGF5ZXIucHJvdG90eXBlLl9jcmVhdGUuY2FsbCggdGhpcyApO1xuICBcbiAgICAgIC8vIGNyZWF0ZSBsYXlvdXQgbW9kZXNcbiAgICAgIHRoaXMubW9kZXMgPSB7fTtcbiAgICAgIC8vIHN0YXJ0IGZpbHRlcmVkSXRlbXMgd2l0aCBhbGwgaXRlbXNcbiAgICAgIHRoaXMuZmlsdGVyZWRJdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgICAvLyBrZWVwIG9mIHRyYWNrIG9mIHNvcnRCeXNcbiAgICAgIHRoaXMuc29ydEhpc3RvcnkgPSBbICdvcmlnaW5hbC1vcmRlcicgXTtcbiAgICAgIC8vIGNyZWF0ZSBmcm9tIHJlZ2lzdGVyZWQgbGF5b3V0IG1vZGVzXG4gICAgICBmb3IgKCB2YXIgbmFtZSBpbiBMYXlvdXRNb2RlLm1vZGVzICkge1xuICAgICAgICB0aGlzLl9pbml0TGF5b3V0TW9kZSggbmFtZSApO1xuICAgICAgfVxuICAgIH07XG4gIFxuICAgIHByb3RvLnJlbG9hZEl0ZW1zID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyByZXNldCBpdGVtIElEIGNvdW50ZXJcbiAgICAgIHRoaXMuaXRlbUdVSUQgPSAwO1xuICAgICAgLy8gY2FsbCBzdXBlclxuICAgICAgT3V0bGF5ZXIucHJvdG90eXBlLnJlbG9hZEl0ZW1zLmNhbGwoIHRoaXMgKTtcbiAgICB9O1xuICBcbiAgICBwcm90by5faXRlbWl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGl0ZW1zID0gT3V0bGF5ZXIucHJvdG90eXBlLl9pdGVtaXplLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICAgIC8vIGFzc2lnbiBJRCBmb3Igb3JpZ2luYWwtb3JkZXJcbiAgICAgIGZvciAoIHZhciBpPTA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaXRlbS5pZCA9IHRoaXMuaXRlbUdVSUQrKztcbiAgICAgIH1cbiAgICAgIHRoaXMuX3VwZGF0ZUl0ZW1zU29ydERhdGEoIGl0ZW1zICk7XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfTtcbiAgXG4gIFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGxheW91dCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICBcbiAgICBwcm90by5faW5pdExheW91dE1vZGUgPSBmdW5jdGlvbiggbmFtZSApIHtcbiAgICAgIHZhciBNb2RlID0gTGF5b3V0TW9kZS5tb2Rlc1sgbmFtZSBdO1xuICAgICAgLy8gc2V0IG1vZGUgb3B0aW9uc1xuICAgICAgLy8gSEFDSyBleHRlbmQgaW5pdGlhbCBvcHRpb25zLCBiYWNrLWZpbGwgaW4gZGVmYXVsdCBvcHRpb25zXG4gICAgICB2YXIgaW5pdGlhbE9wdHMgPSB0aGlzLm9wdGlvbnNbIG5hbWUgXSB8fCB7fTtcbiAgICAgIHRoaXMub3B0aW9uc1sgbmFtZSBdID0gTW9kZS5vcHRpb25zID9cbiAgICAgICAgdXRpbHMuZXh0ZW5kKCBNb2RlLm9wdGlvbnMsIGluaXRpYWxPcHRzICkgOiBpbml0aWFsT3B0cztcbiAgICAgIC8vIGluaXQgbGF5b3V0IG1vZGUgaW5zdGFuY2VcbiAgICAgIHRoaXMubW9kZXNbIG5hbWUgXSA9IG5ldyBNb2RlKCB0aGlzICk7XG4gICAgfTtcbiAgXG4gIFxuICAgIHByb3RvLmxheW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaWYgZmlyc3QgdGltZSBkb2luZyBsYXlvdXQsIGRvIGFsbCBtYWdpY1xuICAgICAgaWYgKCAhdGhpcy5faXNMYXlvdXRJbml0ZWQgJiYgdGhpcy5fZ2V0T3B0aW9uKCdpbml0TGF5b3V0JykgKSB7XG4gICAgICAgIHRoaXMuYXJyYW5nZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9sYXlvdXQoKTtcbiAgICB9O1xuICBcbiAgICAvLyBwcml2YXRlIG1ldGhvZCB0byBiZSB1c2VkIGluIGxheW91dCgpICYgbWFnaWMoKVxuICAgIHByb3RvLl9sYXlvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGRvbid0IGFuaW1hdGUgZmlyc3QgbGF5b3V0XG4gICAgICB2YXIgaXNJbnN0YW50ID0gdGhpcy5fZ2V0SXNJbnN0YW50KCk7XG4gICAgICAvLyBsYXlvdXQgZmxvd1xuICAgICAgdGhpcy5fcmVzZXRMYXlvdXQoKTtcbiAgICAgIHRoaXMuX21hbmFnZVN0YW1wcygpO1xuICAgICAgdGhpcy5sYXlvdXRJdGVtcyggdGhpcy5maWx0ZXJlZEl0ZW1zLCBpc0luc3RhbnQgKTtcbiAgXG4gICAgICAvLyBmbGFnIGZvciBpbml0YWxpemVkXG4gICAgICB0aGlzLl9pc0xheW91dEluaXRlZCA9IHRydWU7XG4gICAgfTtcbiAgXG4gICAgLy8gZmlsdGVyICsgc29ydCArIGxheW91dFxuICAgIHByb3RvLmFycmFuZ2UgPSBmdW5jdGlvbiggb3B0cyApIHtcbiAgICAgIC8vIHNldCBhbnkgb3B0aW9ucyBwYXNzXG4gICAgICB0aGlzLm9wdGlvbiggb3B0cyApO1xuICAgICAgdGhpcy5fZ2V0SXNJbnN0YW50KCk7XG4gICAgICAvLyBmaWx0ZXIsIHNvcnQsIGFuZCBsYXlvdXRcbiAgXG4gICAgICAvLyBmaWx0ZXJcbiAgICAgIHZhciBmaWx0ZXJlZCA9IHRoaXMuX2ZpbHRlciggdGhpcy5pdGVtcyApO1xuICAgICAgdGhpcy5maWx0ZXJlZEl0ZW1zID0gZmlsdGVyZWQubWF0Y2hlcztcbiAgXG4gICAgICB0aGlzLl9iaW5kQXJyYW5nZUNvbXBsZXRlKCk7XG4gIFxuICAgICAgaWYgKCB0aGlzLl9pc0luc3RhbnQgKSB7XG4gICAgICAgIHRoaXMuX25vVHJhbnNpdGlvbiggdGhpcy5faGlkZVJldmVhbCwgWyBmaWx0ZXJlZCBdICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9oaWRlUmV2ZWFsKCBmaWx0ZXJlZCApO1xuICAgICAgfVxuICBcbiAgICAgIHRoaXMuX3NvcnQoKTtcbiAgICAgIHRoaXMuX2xheW91dCgpO1xuICAgIH07XG4gICAgLy8gYWxpYXMgdG8gX2luaXQgZm9yIG1haW4gcGx1Z2luIG1ldGhvZFxuICAgIHByb3RvLl9pbml0ID0gcHJvdG8uYXJyYW5nZTtcbiAgXG4gICAgcHJvdG8uX2hpZGVSZXZlYWwgPSBmdW5jdGlvbiggZmlsdGVyZWQgKSB7XG4gICAgICB0aGlzLnJldmVhbCggZmlsdGVyZWQubmVlZFJldmVhbCApO1xuICAgICAgdGhpcy5oaWRlKCBmaWx0ZXJlZC5uZWVkSGlkZSApO1xuICAgIH07XG4gIFxuICAgIC8vIEhBQ0tcbiAgICAvLyBEb24ndCBhbmltYXRlL3RyYW5zaXRpb24gZmlyc3QgbGF5b3V0XG4gICAgLy8gT3IgZG9uJ3QgYW5pbWF0ZS90cmFuc2l0aW9uIG90aGVyIGxheW91dHNcbiAgICBwcm90by5fZ2V0SXNJbnN0YW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXNMYXlvdXRJbnN0YW50ID0gdGhpcy5fZ2V0T3B0aW9uKCdsYXlvdXRJbnN0YW50Jyk7XG4gICAgICB2YXIgaXNJbnN0YW50ID0gaXNMYXlvdXRJbnN0YW50ICE9PSB1bmRlZmluZWQgPyBpc0xheW91dEluc3RhbnQgOlxuICAgICAgICAhdGhpcy5faXNMYXlvdXRJbml0ZWQ7XG4gICAgICB0aGlzLl9pc0luc3RhbnQgPSBpc0luc3RhbnQ7XG4gICAgICByZXR1cm4gaXNJbnN0YW50O1xuICAgIH07XG4gIFxuICAgIC8vIGxpc3RlbiBmb3IgbGF5b3V0Q29tcGxldGUsIGhpZGVDb21wbGV0ZSBhbmQgcmV2ZWFsQ29tcGxldGVcbiAgICAvLyB0byB0cmlnZ2VyIGFycmFuZ2VDb21wbGV0ZVxuICAgIHByb3RvLl9iaW5kQXJyYW5nZUNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBsaXN0ZW4gZm9yIDMgZXZlbnRzIHRvIHRyaWdnZXIgYXJyYW5nZUNvbXBsZXRlXG4gICAgICB2YXIgaXNMYXlvdXRDb21wbGV0ZSwgaXNIaWRlQ29tcGxldGUsIGlzUmV2ZWFsQ29tcGxldGU7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gYXJyYW5nZVBhcmFsbGVsQ2FsbGJhY2soKSB7XG4gICAgICAgIGlmICggaXNMYXlvdXRDb21wbGV0ZSAmJiBpc0hpZGVDb21wbGV0ZSAmJiBpc1JldmVhbENvbXBsZXRlICkge1xuICAgICAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoICdhcnJhbmdlQ29tcGxldGUnLCBudWxsLCBbIF90aGlzLmZpbHRlcmVkSXRlbXMgXSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm9uY2UoICdsYXlvdXRDb21wbGV0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpc0xheW91dENvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgYXJyYW5nZVBhcmFsbGVsQ2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbmNlKCAnaGlkZUNvbXBsZXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlzSGlkZUNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgYXJyYW5nZVBhcmFsbGVsQ2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbmNlKCAncmV2ZWFsQ29tcGxldGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXNSZXZlYWxDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIGFycmFuZ2VQYXJhbGxlbENhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICB9O1xuICBcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBmaWx0ZXIgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cbiAgXG4gICAgcHJvdG8uX2ZpbHRlciA9IGZ1bmN0aW9uKCBpdGVtcyApIHtcbiAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLm9wdGlvbnMuZmlsdGVyO1xuICAgICAgZmlsdGVyID0gZmlsdGVyIHx8ICcqJztcbiAgICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgICB2YXIgaGlkZGVuTWF0Y2hlZCA9IFtdO1xuICAgICAgdmFyIHZpc2libGVVbm1hdGNoZWQgPSBbXTtcbiAgXG4gICAgICB2YXIgdGVzdCA9IHRoaXMuX2dldEZpbHRlclRlc3QoIGZpbHRlciApO1xuICBcbiAgICAgIC8vIHRlc3QgZWFjaCBpdGVtXG4gICAgICBmb3IgKCB2YXIgaT0wOyBpIDwgaXRlbXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmICggaXRlbS5pc0lnbm9yZWQgKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGl0ZW0gdG8gZWl0aGVyIG1hdGNoZWQgb3IgdW5tYXRjaGVkIGdyb3VwXG4gICAgICAgIHZhciBpc01hdGNoZWQgPSB0ZXN0KCBpdGVtICk7XG4gICAgICAgIC8vIGl0ZW0uaXNGaWx0ZXJNYXRjaGVkID0gaXNNYXRjaGVkO1xuICAgICAgICAvLyBhZGQgdG8gbWF0Y2hlcyBpZiBpdHMgYSBtYXRjaFxuICAgICAgICBpZiAoIGlzTWF0Y2hlZCApIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goIGl0ZW0gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgdG8gYWRkaXRpb25hbCBncm91cCBpZiBpdGVtIG5lZWRzIHRvIGJlIGhpZGRlbiBvciByZXZlYWxlZFxuICAgICAgICBpZiAoIGlzTWF0Y2hlZCAmJiBpdGVtLmlzSGlkZGVuICkge1xuICAgICAgICAgIGhpZGRlbk1hdGNoZWQucHVzaCggaXRlbSApO1xuICAgICAgICB9IGVsc2UgaWYgKCAhaXNNYXRjaGVkICYmICFpdGVtLmlzSGlkZGVuICkge1xuICAgICAgICAgIHZpc2libGVVbm1hdGNoZWQucHVzaCggaXRlbSApO1xuICAgICAgICB9XG4gICAgICB9XG4gIFxuICAgICAgLy8gcmV0dXJuIGNvbGxlY3Rpb25zIG9mIGl0ZW1zIHRvIGJlIG1hbmlwdWxhdGVkXG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzOiBtYXRjaGVzLFxuICAgICAgICBuZWVkUmV2ZWFsOiBoaWRkZW5NYXRjaGVkLFxuICAgICAgICBuZWVkSGlkZTogdmlzaWJsZVVubWF0Y2hlZFxuICAgICAgfTtcbiAgICB9O1xuICBcbiAgICAvLyBnZXQgYSBqUXVlcnksIGZ1bmN0aW9uLCBvciBhIG1hdGNoZXNTZWxlY3RvciB0ZXN0IGdpdmVuIHRoZSBmaWx0ZXJcbiAgICBwcm90by5fZ2V0RmlsdGVyVGVzdCA9IGZ1bmN0aW9uKCBmaWx0ZXIgKSB7XG4gICAgICBpZiAoIGpRdWVyeSAmJiB0aGlzLm9wdGlvbnMuaXNKUXVlcnlGaWx0ZXJpbmcgKSB7XG4gICAgICAgIC8vIHVzZSBqUXVlcnlcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBpdGVtICkge1xuICAgICAgICAgIHJldHVybiBqUXVlcnkoIGl0ZW0uZWxlbWVudCApLmlzKCBmaWx0ZXIgKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICggdHlwZW9mIGZpbHRlciA9PSAnZnVuY3Rpb24nICkge1xuICAgICAgICAvLyB1c2UgZmlsdGVyIGFzIGZ1bmN0aW9uXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggaXRlbSApIHtcbiAgICAgICAgICByZXR1cm4gZmlsdGVyKCBpdGVtLmVsZW1lbnQgKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8vIGRlZmF1bHQsIHVzZSBmaWx0ZXIgYXMgc2VsZWN0b3Igc3RyaW5nXG4gICAgICByZXR1cm4gZnVuY3Rpb24oIGl0ZW0gKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzU2VsZWN0b3IoIGl0ZW0uZWxlbWVudCwgZmlsdGVyICk7XG4gICAgICB9O1xuICAgIH07XG4gIFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHNvcnRpbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cbiAgXG4gICAgLyoqXG4gICAgICogQHBhcmFtcyB7QXJyYXl9IGVsZW1zXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHByb3RvLnVwZGF0ZVNvcnREYXRhID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICAgICAgLy8gZ2V0IGl0ZW1zXG4gICAgICB2YXIgaXRlbXM7XG4gICAgICBpZiAoIGVsZW1zICkge1xuICAgICAgICBlbGVtcyA9IHV0aWxzLm1ha2VBcnJheSggZWxlbXMgKTtcbiAgICAgICAgaXRlbXMgPSB0aGlzLmdldEl0ZW1zKCBlbGVtcyApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXBkYXRlIGFsbCBpdGVtcyBpZiBubyBlbGVtcyBwcm92aWRlZFxuICAgICAgICBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgICB9XG4gIFxuICAgICAgdGhpcy5fZ2V0U29ydGVycygpO1xuICAgICAgdGhpcy5fdXBkYXRlSXRlbXNTb3J0RGF0YSggaXRlbXMgKTtcbiAgICB9O1xuICBcbiAgICBwcm90by5fZ2V0U29ydGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGdldFNvcnREYXRhID0gdGhpcy5vcHRpb25zLmdldFNvcnREYXRhO1xuICAgICAgZm9yICggdmFyIGtleSBpbiBnZXRTb3J0RGF0YSApIHtcbiAgICAgICAgdmFyIHNvcnRlciA9IGdldFNvcnREYXRhWyBrZXkgXTtcbiAgICAgICAgdGhpcy5fc29ydGVyc1sga2V5IF0gPSBtdW5nZVNvcnRlciggc29ydGVyICk7XG4gICAgICB9XG4gICAgfTtcbiAgXG4gICAgLyoqXG4gICAgICogQHBhcmFtcyB7QXJyYXl9IGl0ZW1zIC0gb2YgSXNvdG9wZS5JdGVtc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHJvdG8uX3VwZGF0ZUl0ZW1zU29ydERhdGEgPSBmdW5jdGlvbiggaXRlbXMgKSB7XG4gICAgICAvLyBkbyBub3QgdXBkYXRlIGlmIG5vIGl0ZW1zXG4gICAgICB2YXIgbGVuID0gaXRlbXMgJiYgaXRlbXMubGVuZ3RoO1xuICBcbiAgICAgIGZvciAoIHZhciBpPTA7IGxlbiAmJiBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGl0ZW0udXBkYXRlU29ydERhdGEoKTtcbiAgICAgIH1cbiAgICB9O1xuICBcbiAgICAvLyAtLS0tLSBtdW5nZSBzb3J0ZXIgLS0tLS0gLy9cbiAgXG4gICAgLy8gZW5jYXBzdWxhdGUgdGhpcywgYXMgd2UganVzdCBuZWVkIG11bmdlU29ydGVyXG4gICAgLy8gb3RoZXIgZnVuY3Rpb25zIGluIGhlcmUgYXJlIGp1c3QgZm9yIG11bmdpbmdcbiAgICB2YXIgbXVuZ2VTb3J0ZXIgPSAoIGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYWRkIGEgbWFnaWMgbGF5ZXIgdG8gc29ydGVycyBmb3IgY29udmllbmVudCBzaG9ydGhhbmRzXG4gICAgICAvLyBgLmZvby1iYXJgIHdpbGwgdXNlIHRoZSB0ZXh0IG9mIC5mb28tYmFyIHF1ZXJ5U2VsZWN0b3JcbiAgICAgIC8vIGBbZm9vLWJhcl1gIHdpbGwgdXNlIGF0dHJpYnV0ZVxuICAgICAgLy8geW91IGNhbiBhbHNvIGFkZCBwYXJzZXJcbiAgICAgIC8vIGAuZm9vLWJhciBwYXJzZUludGAgd2lsbCBwYXJzZSB0aGF0IGFzIGEgbnVtYmVyXG4gICAgICBmdW5jdGlvbiBtdW5nZVNvcnRlciggc29ydGVyICkge1xuICAgICAgICAvLyBpZiBub3QgYSBzdHJpbmcsIHJldHVybiBmdW5jdGlvbiBvciB3aGF0ZXZlciBpdCBpc1xuICAgICAgICBpZiAoIHR5cGVvZiBzb3J0ZXIgIT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgcmV0dXJuIHNvcnRlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYXJzZSB0aGUgc29ydGVyIHN0cmluZ1xuICAgICAgICB2YXIgYXJncyA9IHRyaW0oIHNvcnRlciApLnNwbGl0KCcgJyk7XG4gICAgICAgIHZhciBxdWVyeSA9IGFyZ3NbMF07XG4gICAgICAgIC8vIGNoZWNrIGlmIHF1ZXJ5IGxvb2tzIGxpa2UgW2FuLWF0dHJpYnV0ZV1cbiAgICAgICAgdmFyIGF0dHJNYXRjaCA9IHF1ZXJ5Lm1hdGNoKCAvXlxcWyguKylcXF0kLyApO1xuICAgICAgICB2YXIgYXR0ciA9IGF0dHJNYXRjaCAmJiBhdHRyTWF0Y2hbMV07XG4gICAgICAgIHZhciBnZXRWYWx1ZSA9IGdldFZhbHVlR2V0dGVyKCBhdHRyLCBxdWVyeSApO1xuICAgICAgICAvLyB1c2Ugc2Vjb25kIGFyZ3VtZW50IGFzIGEgcGFyc2VyXG4gICAgICAgIHZhciBwYXJzZXIgPSBJc290b3BlLnNvcnREYXRhUGFyc2Vyc1sgYXJnc1sxXSBdO1xuICAgICAgICAvLyBwYXJzZSB0aGUgdmFsdWUsIGlmIHRoZXJlIHdhcyBhIHBhcnNlclxuICAgICAgICBzb3J0ZXIgPSBwYXJzZXIgPyBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICByZXR1cm4gZWxlbSAmJiBwYXJzZXIoIGdldFZhbHVlKCBlbGVtICkgKTtcbiAgICAgICAgfSA6XG4gICAgICAgIC8vIG90aGVyd2lzZSBqdXN0IHJldHVybiB2YWx1ZVxuICAgICAgICBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICByZXR1cm4gZWxlbSAmJiBnZXRWYWx1ZSggZWxlbSApO1xuICAgICAgICB9O1xuICBcbiAgICAgICAgcmV0dXJuIHNvcnRlcjtcbiAgICAgIH1cbiAgXG4gICAgICAvLyBnZXQgYW4gYXR0cmlidXRlIGdldHRlciwgb3IgZ2V0IHRleHQgb2YgdGhlIHF1ZXJ5U2VsZWN0b3JcbiAgICAgIGZ1bmN0aW9uIGdldFZhbHVlR2V0dGVyKCBhdHRyLCBxdWVyeSApIHtcbiAgICAgICAgLy8gaWYgcXVlcnkgbG9va3MgbGlrZSBbZm9vLWJhcl0sIGdldCBhdHRyaWJ1dGVcbiAgICAgICAgaWYgKCBhdHRyICkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBnZXRBdHRyaWJ1dGUoIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIGF0dHIgKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gIFxuICAgICAgICAvLyBvdGhlcndpc2UsIGFzc3VtZSBpdHMgYSBxdWVyeVNlbGVjdG9yLCBhbmQgZ2V0IGl0cyB0ZXh0XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBnZXRDaGlsZFRleHQoIGVsZW0gKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gZWxlbS5xdWVyeVNlbGVjdG9yKCBxdWVyeSApO1xuICAgICAgICAgIHJldHVybiBjaGlsZCAmJiBjaGlsZC50ZXh0Q29udGVudDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gbXVuZ2VTb3J0ZXI7XG4gICAgfSkoKTtcbiAgXG4gICAgLy8gcGFyc2VycyB1c2VkIGluIGdldFNvcnREYXRhIHNob3J0Y3V0IHN0cmluZ3NcbiAgICBJc290b3BlLnNvcnREYXRhUGFyc2VycyA9IHtcbiAgICAgICdwYXJzZUludCc6IGZ1bmN0aW9uKCB2YWwgKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCggdmFsLCAxMCApO1xuICAgICAgfSxcbiAgICAgICdwYXJzZUZsb2F0JzogZnVuY3Rpb24oIHZhbCApIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoIHZhbCApO1xuICAgICAgfVxuICAgIH07XG4gIFxuICAgIC8vIC0tLS0tIHNvcnQgbWV0aG9kIC0tLS0tIC8vXG4gIFxuICAgIC8vIHNvcnQgZmlsdGVyZWRJdGVtIG9yZGVyXG4gICAgcHJvdG8uX3NvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICggIXRoaXMub3B0aW9ucy5zb3J0QnkgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGtlZXAgdHJhY2sgb2Ygc29ydEJ5IEhpc3RvcnlcbiAgICAgIHZhciBzb3J0QnlzID0gdXRpbHMubWFrZUFycmF5KCB0aGlzLm9wdGlvbnMuc29ydEJ5ICk7XG4gICAgICBpZiAoICF0aGlzLl9nZXRJc1NhbWVTb3J0QnkoIHNvcnRCeXMgKSApIHtcbiAgICAgICAgLy8gY29uY2F0IGFsbCBzb3J0QnkgYW5kIHNvcnRIaXN0b3J5LCBhZGQgdG8gZnJvbnQsIG9sZGVzdCBnb2VzIGluIGxhc3RcbiAgICAgICAgdGhpcy5zb3J0SGlzdG9yeSA9IHNvcnRCeXMuY29uY2F0KCB0aGlzLnNvcnRIaXN0b3J5ICk7XG4gICAgICB9XG4gICAgICAvLyBzb3J0IG1hZ2ljXG4gICAgICB2YXIgaXRlbVNvcnRlciA9IGdldEl0ZW1Tb3J0ZXIoIHRoaXMuc29ydEhpc3RvcnksIHRoaXMub3B0aW9ucy5zb3J0QXNjZW5kaW5nICk7XG4gICAgICB0aGlzLmZpbHRlcmVkSXRlbXMuc29ydCggaXRlbVNvcnRlciApO1xuICAgIH07XG4gIFxuICAgIC8vIGNoZWNrIGlmIHNvcnRCeXMgaXMgc2FtZSBhcyBzdGFydCBvZiBzb3J0SGlzdG9yeVxuICAgIHByb3RvLl9nZXRJc1NhbWVTb3J0QnkgPSBmdW5jdGlvbiggc29ydEJ5cyApIHtcbiAgICAgIGZvciAoIHZhciBpPTA7IGkgPCBzb3J0QnlzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBpZiAoIHNvcnRCeXNbaV0gIT0gdGhpcy5zb3J0SGlzdG9yeVtpXSApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIFxuICAgIC8vIHJldHVybnMgYSBmdW5jdGlvbiB1c2VkIGZvciBzb3J0aW5nXG4gICAgZnVuY3Rpb24gZ2V0SXRlbVNvcnRlciggc29ydEJ5cywgc29ydEFzYyApIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBzb3J0ZXIoIGl0ZW1BLCBpdGVtQiApIHtcbiAgICAgICAgLy8gY3ljbGUgdGhyb3VnaCBhbGwgc29ydEtleXNcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgc29ydEJ5cy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICB2YXIgc29ydEJ5ID0gc29ydEJ5c1tpXTtcbiAgICAgICAgICB2YXIgYSA9IGl0ZW1BLnNvcnREYXRhWyBzb3J0QnkgXTtcbiAgICAgICAgICB2YXIgYiA9IGl0ZW1CLnNvcnREYXRhWyBzb3J0QnkgXTtcbiAgICAgICAgICBpZiAoIGEgPiBiIHx8IGEgPCBiICkge1xuICAgICAgICAgICAgLy8gaWYgc29ydEFzYyBpcyBhbiBvYmplY3QsIHVzZSB0aGUgdmFsdWUgZ2l2ZW4gdGhlIHNvcnRCeSBrZXlcbiAgICAgICAgICAgIHZhciBpc0FzY2VuZGluZyA9IHNvcnRBc2NbIHNvcnRCeSBdICE9PSB1bmRlZmluZWQgPyBzb3J0QXNjWyBzb3J0QnkgXSA6IHNvcnRBc2M7XG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gaXNBc2NlbmRpbmcgPyAxIDogLTE7XG4gICAgICAgICAgICByZXR1cm4gKCBhID4gYiA/IDEgOiAtMSApICogZGlyZWN0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH07XG4gICAgfVxuICBcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBtZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG4gIFxuICAgIC8vIGdldCBsYXlvdXQgbW9kZVxuICAgIHByb3RvLl9tb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGF5b3V0TW9kZSA9IHRoaXMub3B0aW9ucy5sYXlvdXRNb2RlO1xuICAgICAgdmFyIG1vZGUgPSB0aGlzLm1vZGVzWyBsYXlvdXRNb2RlIF07XG4gICAgICBpZiAoICFtb2RlICkge1xuICAgICAgICAvLyBUT0RPIGNvbnNvbGUuZXJyb3JcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAnTm8gbGF5b3V0IG1vZGU6ICcgKyBsYXlvdXRNb2RlICk7XG4gICAgICB9XG4gICAgICAvLyBIQUNLIHN5bmMgbW9kZSdzIG9wdGlvbnNcbiAgICAgIC8vIGFueSBvcHRpb25zIHNldCBhZnRlciBpbml0IGZvciBsYXlvdXQgbW9kZSBuZWVkIHRvIGJlIHN5bmNlZFxuICAgICAgbW9kZS5vcHRpb25zID0gdGhpcy5vcHRpb25zWyBsYXlvdXRNb2RlIF07XG4gICAgICByZXR1cm4gbW9kZTtcbiAgICB9O1xuICBcbiAgICBwcm90by5fcmVzZXRMYXlvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIHRyaWdnZXIgb3JpZ2luYWwgcmVzZXQgbGF5b3V0XG4gICAgICBPdXRsYXllci5wcm90b3R5cGUuX3Jlc2V0TGF5b3V0LmNhbGwoIHRoaXMgKTtcbiAgICAgIHRoaXMuX21vZGUoKS5fcmVzZXRMYXlvdXQoKTtcbiAgICB9O1xuICBcbiAgICBwcm90by5fZ2V0SXRlbUxheW91dFBvc2l0aW9uID0gZnVuY3Rpb24oIGl0ZW0gICkge1xuICAgICAgcmV0dXJuIHRoaXMuX21vZGUoKS5fZ2V0SXRlbUxheW91dFBvc2l0aW9uKCBpdGVtICk7XG4gICAgfTtcbiAgXG4gICAgcHJvdG8uX21hbmFnZVN0YW1wID0gZnVuY3Rpb24oIHN0YW1wICkge1xuICAgICAgdGhpcy5fbW9kZSgpLl9tYW5hZ2VTdGFtcCggc3RhbXAgKTtcbiAgICB9O1xuICBcbiAgICBwcm90by5fZ2V0Q29udGFpbmVyU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21vZGUoKS5fZ2V0Q29udGFpbmVyU2l6ZSgpO1xuICAgIH07XG4gIFxuICAgIHByb3RvLm5lZWRzUmVzaXplTGF5b3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW9kZSgpLm5lZWRzUmVzaXplTGF5b3V0KCk7XG4gICAgfTtcbiAgXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gYWRkaW5nICYgcmVtb3ZpbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cbiAgXG4gICAgLy8gSEVBRFMgVVAgb3ZlcndyaXRlcyBkZWZhdWx0IE91dGxheWVyIGFwcGVuZGVkXG4gICAgcHJvdG8uYXBwZW5kZWQgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gICAgICB2YXIgaXRlbXMgPSB0aGlzLmFkZEl0ZW1zKCBlbGVtcyApO1xuICAgICAgaWYgKCAhaXRlbXMubGVuZ3RoICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBmaWx0ZXIsIGxheW91dCwgcmV2ZWFsIG5ldyBpdGVtc1xuICAgICAgdmFyIGZpbHRlcmVkSXRlbXMgPSB0aGlzLl9maWx0ZXJSZXZlYWxBZGRlZCggaXRlbXMgKTtcbiAgICAgIC8vIGFkZCB0byBmaWx0ZXJlZEl0ZW1zXG4gICAgICB0aGlzLmZpbHRlcmVkSXRlbXMgPSB0aGlzLmZpbHRlcmVkSXRlbXMuY29uY2F0KCBmaWx0ZXJlZEl0ZW1zICk7XG4gICAgfTtcbiAgXG4gICAgLy8gSEVBRFMgVVAgb3ZlcndyaXRlcyBkZWZhdWx0IE91dGxheWVyIHByZXBlbmRlZFxuICAgIHByb3RvLnByZXBlbmRlZCA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgICAgIHZhciBpdGVtcyA9IHRoaXMuX2l0ZW1pemUoIGVsZW1zICk7XG4gICAgICBpZiAoICFpdGVtcy5sZW5ndGggKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIHN0YXJ0IG5ldyBsYXlvdXRcbiAgICAgIHRoaXMuX3Jlc2V0TGF5b3V0KCk7XG4gICAgICB0aGlzLl9tYW5hZ2VTdGFtcHMoKTtcbiAgICAgIC8vIGZpbHRlciwgbGF5b3V0LCByZXZlYWwgbmV3IGl0ZW1zXG4gICAgICB2YXIgZmlsdGVyZWRJdGVtcyA9IHRoaXMuX2ZpbHRlclJldmVhbEFkZGVkKCBpdGVtcyApO1xuICAgICAgLy8gbGF5b3V0IHByZXZpb3VzIGl0ZW1zXG4gICAgICB0aGlzLmxheW91dEl0ZW1zKCB0aGlzLmZpbHRlcmVkSXRlbXMgKTtcbiAgICAgIC8vIGFkZCB0byBpdGVtcyBhbmQgZmlsdGVyZWRJdGVtc1xuICAgICAgdGhpcy5maWx0ZXJlZEl0ZW1zID0gZmlsdGVyZWRJdGVtcy5jb25jYXQoIHRoaXMuZmlsdGVyZWRJdGVtcyApO1xuICAgICAgdGhpcy5pdGVtcyA9IGl0ZW1zLmNvbmNhdCggdGhpcy5pdGVtcyApO1xuICAgIH07XG4gIFxuICAgIHByb3RvLl9maWx0ZXJSZXZlYWxBZGRlZCA9IGZ1bmN0aW9uKCBpdGVtcyApIHtcbiAgICAgIHZhciBmaWx0ZXJlZCA9IHRoaXMuX2ZpbHRlciggaXRlbXMgKTtcbiAgICAgIHRoaXMuaGlkZSggZmlsdGVyZWQubmVlZEhpZGUgKTtcbiAgICAgIC8vIHJldmVhbCBhbGwgbmV3IGl0ZW1zXG4gICAgICB0aGlzLnJldmVhbCggZmlsdGVyZWQubWF0Y2hlcyApO1xuICAgICAgLy8gbGF5b3V0IG5ldyBpdGVtcywgbm8gdHJhbnNpdGlvblxuICAgICAgdGhpcy5sYXlvdXRJdGVtcyggZmlsdGVyZWQubWF0Y2hlcywgdHJ1ZSApO1xuICAgICAgcmV0dXJuIGZpbHRlcmVkLm1hdGNoZXM7XG4gICAgfTtcbiAgXG4gICAgLyoqXG4gICAgICogRmlsdGVyLCBzb3J0LCBhbmQgbGF5b3V0IG5ld2x5LWFwcGVuZGVkIGl0ZW0gZWxlbWVudHNcbiAgICAgKiBAcGFyYW0ge0FycmF5IG9yIE5vZGVMaXN0IG9yIEVsZW1lbnR9IGVsZW1zXG4gICAgICovXG4gICAgcHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICAgICAgdmFyIGl0ZW1zID0gdGhpcy5hZGRJdGVtcyggZWxlbXMgKTtcbiAgICAgIGlmICggIWl0ZW1zLmxlbmd0aCApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gYXBwZW5kIGl0ZW0gZWxlbWVudHNcbiAgICAgIHZhciBpLCBpdGVtO1xuICAgICAgdmFyIGxlbiA9IGl0ZW1zLmxlbmd0aDtcbiAgICAgIGZvciAoIGk9MDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCggaXRlbS5lbGVtZW50ICk7XG4gICAgICB9XG4gICAgICAvLyBmaWx0ZXIgbmV3IHN0dWZmXG4gICAgICB2YXIgZmlsdGVyZWRJbnNlcnRJdGVtcyA9IHRoaXMuX2ZpbHRlciggaXRlbXMgKS5tYXRjaGVzO1xuICAgICAgLy8gc2V0IGZsYWdcbiAgICAgIGZvciAoIGk9MDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICBpdGVtc1tpXS5pc0xheW91dEluc3RhbnQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5hcnJhbmdlKCk7XG4gICAgICAvLyByZXNldCBmbGFnXG4gICAgICBmb3IgKCBpPTA7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgZGVsZXRlIGl0ZW1zW2ldLmlzTGF5b3V0SW5zdGFudDtcbiAgICAgIH1cbiAgICAgIHRoaXMucmV2ZWFsKCBmaWx0ZXJlZEluc2VydEl0ZW1zICk7XG4gICAgfTtcbiAgXG4gICAgdmFyIF9yZW1vdmUgPSBwcm90by5yZW1vdmU7XG4gICAgcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICAgICAgZWxlbXMgPSB1dGlscy5tYWtlQXJyYXkoIGVsZW1zICk7XG4gICAgICB2YXIgcmVtb3ZlSXRlbXMgPSB0aGlzLmdldEl0ZW1zKCBlbGVtcyApO1xuICAgICAgLy8gZG8gcmVndWxhciB0aGluZ1xuICAgICAgX3JlbW92ZS5jYWxsKCB0aGlzLCBlbGVtcyApO1xuICAgICAgLy8gYmFpbCBpZiBubyBpdGVtcyB0byByZW1vdmVcbiAgICAgIHZhciBsZW4gPSByZW1vdmVJdGVtcyAmJiByZW1vdmVJdGVtcy5sZW5ndGg7XG4gICAgICAvLyByZW1vdmUgZWxlbXMgZnJvbSBmaWx0ZXJlZEl0ZW1zXG4gICAgICBmb3IgKCB2YXIgaT0wOyBsZW4gJiYgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICB2YXIgaXRlbSA9IHJlbW92ZUl0ZW1zW2ldO1xuICAgICAgICAvLyByZW1vdmUgaXRlbSBmcm9tIGNvbGxlY3Rpb25cbiAgICAgICAgdXRpbHMucmVtb3ZlRnJvbSggdGhpcy5maWx0ZXJlZEl0ZW1zLCBpdGVtICk7XG4gICAgICB9XG4gICAgfTtcbiAgXG4gICAgcHJvdG8uc2h1ZmZsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gdXBkYXRlIHJhbmRvbSBzb3J0RGF0YVxuICAgICAgZm9yICggdmFyIGk9MDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5pdGVtc1tpXTtcbiAgICAgICAgaXRlbS5zb3J0RGF0YS5yYW5kb20gPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpb25zLnNvcnRCeSA9ICdyYW5kb20nO1xuICAgICAgdGhpcy5fc29ydCgpO1xuICAgICAgdGhpcy5fbGF5b3V0KCk7XG4gICAgfTtcbiAgXG4gICAgLyoqXG4gICAgICogdHJpZ2dlciBmbiB3aXRob3V0IHRyYW5zaXRpb25cbiAgICAgKiBraW5kIG9mIGhhY2t5IHRvIGhhdmUgdGhpcyBpbiB0aGUgZmlyc3QgcGxhY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3NcbiAgICAgKiBAcmV0dXJucyByZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHByb3RvLl9ub1RyYW5zaXRpb24gPSBmdW5jdGlvbiggZm4sIGFyZ3MgKSB7XG4gICAgICAvLyBzYXZlIHRyYW5zaXRpb25EdXJhdGlvbiBiZWZvcmUgZGlzYWJsaW5nXG4gICAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gdGhpcy5vcHRpb25zLnRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICAgIC8vIGRpc2FibGUgdHJhbnNpdGlvblxuICAgICAgdGhpcy5vcHRpb25zLnRyYW5zaXRpb25EdXJhdGlvbiA9IDA7XG4gICAgICAvLyBkbyBpdFxuICAgICAgdmFyIHJldHVyblZhbHVlID0gZm4uYXBwbHkoIHRoaXMsIGFyZ3MgKTtcbiAgICAgIC8vIHJlLWVuYWJsZSB0cmFuc2l0aW9uIGZvciByZXZlYWxcbiAgICAgIHRoaXMub3B0aW9ucy50cmFuc2l0aW9uRHVyYXRpb24gPSB0cmFuc2l0aW9uRHVyYXRpb247XG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfTtcbiAgXG4gICAgLy8gLS0tLS0gaGVscGVyIG1ldGhvZHMgLS0tLS0gLy9cbiAgXG4gICAgLyoqXG4gICAgICogZ2V0dGVyIG1ldGhvZCBmb3IgZ2V0dGluZyBmaWx0ZXJlZCBpdGVtIGVsZW1lbnRzXG4gICAgICogQHJldHVybnMge0FycmF5fSBlbGVtcyAtIGNvbGxlY3Rpb24gb2YgaXRlbSBlbGVtZW50c1xuICAgICAqL1xuICAgIHByb3RvLmdldEZpbHRlcmVkSXRlbUVsZW1lbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXJlZEl0ZW1zLm1hcCggZnVuY3Rpb24oIGl0ZW0gKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmVsZW1lbnQ7XG4gICAgICB9KTtcbiAgICB9O1xuICBcbiAgICAvLyAtLS0tLSAgLS0tLS0gLy9cbiAgXG4gICAgcmV0dXJuIElzb3RvcGU7XG4gIFxuICB9KSk7XG4gIFxuICAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/assets/js/isotope.js\n");

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ "use strict";
/******/ 
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["/js/vendor"], () => (__webpack_exec__("./resources/assets/js/isotope.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);